(function (global, factory) {
    window.juicebox = factory();
})(this, (function () { 'use strict';

    function div$1(options) {
      return create$1("div", options);
    }

    function create$1(tag, options) {
      const elem = document.createElement(tag);

      if (options) {
        if (options.class) {
          elem.classList.add(options.class);
        }

        if (options.id) {
          elem.id = options.id;
        }

        if (options.style) {
          applyStyle$1(elem, options.style);
        }
      }

      return elem;
    }

    function hide$1(elem) {
      const cssStyle = getComputedStyle(elem);

      if (cssStyle.display !== "none") {
        elem._initialDisplay = cssStyle.display;
      }

      elem.style.display = "none";
    }

    function offset$1(elem) {
      // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error
      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      const rect = elem.getBoundingClientRect();
      const win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    }

    function applyStyle$1(elem, style) {
      for (let key of Object.keys(style)) {
        elem.style[key] = style[key];
      }
    }

    function guid() {
      return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
    }

    let getMouseXY = (domElement, {
      clientX,
      clientY
    }) => {
      // DOMRect object with eight properties: left, top, right, bottom, x, y, width, height
      const {
        left,
        top,
        width,
        height
      } = domElement.getBoundingClientRect();
      const x = clientX - left;
      const y = clientY - top;
      return {
        x,
        y,
        xNormalized: x / width,
        yNormalized: y / height,
        width,
        height
      };
    };
    /**
     * Translate the mouse coordinates for the event to the coordinates for the given target element
     * @param event
     * @param domElement
     * @returns {{x: number, y: number}}
     */


    function translateMouseCoordinates(event, domElement) {
      const {
        clientX,
        clientY
      } = event;
      return getMouseXY(domElement, {
        clientX,
        clientY
      });
    }

    function createCheckbox$1(name, initialState) {
      const container = div$1({
        class: 'igv-ui-trackgear-popover-check-container'
      });
      const svg = iconMarkup$2('check', true === initialState ? '#444' : 'transparent');
      svg.style.borderColor = 'gray';
      svg.style.borderWidth = '1px';
      svg.style.borderStyle = 'solid';
      container.appendChild(svg);
      let label = div$1(); //{ class: 'igv-some-label-class' });

      label.textContent = name;
      container.appendChild(label);
      return container;
    }

    function createIcon$2(name, color) {
      return iconMarkup$2(name, color);
    }

    function iconMarkup$2(name, color) {
      color = color || "currentColor";
      let icon = icons$2[name];

      if (!icon) {
        console.error(`No icon named: ${name}`);
        icon = icons$2["question"];
      }

      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttributeNS(null, 'viewBox', '0 0 ' + icon[0] + ' ' + icon[1]);
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttributeNS(null, 'fill', color);
      path.setAttributeNS(null, 'd', icon[4]);
      svg.appendChild(path);
      return svg;
    }

    const icons$2 = {
      "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
      "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
      "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
      "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
      "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
      "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
      "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
      "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
      "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
      "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
      "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
      "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
      "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
      "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
      "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
      "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
      "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
      "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
      "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
      "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
      "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"]
    };

    function attachDialogCloseHandlerWithParent$1(parent, closeHandler) {
      var container = document.createElement("div");
      parent.appendChild(container);
      container.appendChild(createIcon$2("times"));
      container.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        closeHandler();
      });
    }

    /**
     * @fileoverview Zlib namespace. Zlib の仕様に準拠した圧縮は Zlib.Deflate で実装
     * されている. これは Inflate との共存を考慮している為.
     */
    const ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE$2 = 65000;
    var Zlib$2 = {
      Huffman: {},
      Util: {},
      CRC32: {}
    };
    /**
     * Compression Method
     * @enum {number}
     */

    Zlib$2.CompressionMethod = {
      DEFLATE: 8,
      RESERVED: 15
    };
    /**
     * @param {Object=} opt_params options.
     * @constructor
     */

    Zlib$2.Zip = function (opt_params) {
      opt_params = opt_params || {};
      /** @type {Array.<{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }>} */

      this.files = [];
      /** @type {(Array.<number>|Uint8Array)} */

      this.comment = opt_params['comment'];
      /** @type {(Array.<number>|Uint8Array)} */

      this.password;
    };
    /**
     * @enum {number}
     */


    Zlib$2.Zip.CompressionMethod = {
      STORE: 0,
      DEFLATE: 8
    };
    /**
     * @enum {number}
     */

    Zlib$2.Zip.OperatingSystem = {
      MSDOS: 0,
      UNIX: 3,
      MACINTOSH: 7
    };
    /**
     * @enum {number}
     */

    Zlib$2.Zip.Flags = {
      ENCRYPT: 0x0001,
      DESCRIPTOR: 0x0008,
      UTF8: 0x0800
    };
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$2.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$2.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$2.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];
    /**
     * @param {Array.<number>|Uint8Array} input
     * @param {Object=} opt_params options.
     */

    Zlib$2.Zip.prototype.addFile = function (input, opt_params) {
      opt_params = opt_params || {};
      /** @type {string} */

      opt_params['filename'];
      /** @type {boolean} */

      var compressed;
      /** @type {number} */

      var size = input.length;
      /** @type {number} */

      var crc32 = 0;

      if (input instanceof Array) {
        input = new Uint8Array(input);
      } // default


      if (typeof opt_params['compressionMethod'] !== 'number') {
        opt_params['compressionMethod'] = Zlib$2.Zip.CompressionMethod.DEFLATE;
      } // その場で圧縮する場合


      if (opt_params['compress']) {
        switch (opt_params['compressionMethod']) {
          case Zlib$2.Zip.CompressionMethod.STORE:
            break;

          case Zlib$2.Zip.CompressionMethod.DEFLATE:
            crc32 = Zlib$2.CRC32.calc(input);
            input = this.deflateWithOption(input, opt_params);
            compressed = true;
            break;

          default:
            throw new Error('unknown compression method:' + opt_params['compressionMethod']);
        }
      }

      this.files.push({
        buffer: input,
        option: opt_params,
        compressed: compressed,
        encrypted: false,
        size: size,
        crc32: crc32
      });
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     */


    Zlib$2.Zip.prototype.setPassword = function (password) {
      this.password = password;
    };

    Zlib$2.Zip.prototype.compress = function () {
      /** @type {Array.<{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }>} */
      var files = this.files;
      /** @type {{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }} */

      var file;
      /** @type {!(Array.<number>|Uint8Array)} */

      var output;
      /** @type {number} */

      var op1;
      /** @type {number} */

      var op2;
      /** @type {number} */

      var op3;
      /** @type {number} */

      var localFileSize = 0;
      /** @type {number} */

      var centralDirectorySize = 0;
      /** @type {number} */

      var endOfCentralDirectorySize;
      /** @type {number} */

      var offset;
      /** @type {number} */

      var needVersion;
      /** @type {number} */

      var flags;
      /** @type {Zlib.Zip.CompressionMethod} */

      var compressionMethod;
      /** @type {Date} */

      var date;
      /** @type {number} */

      var crc32;
      /** @type {number} */

      var size;
      /** @type {number} */

      var plainSize;
      /** @type {number} */

      var filenameLength;
      /** @type {number} */

      var extraFieldLength;
      /** @type {number} */

      var commentLength;
      /** @type {(Array.<number>|Uint8Array)} */

      var filename;
      /** @type {(Array.<number>|Uint8Array)} */

      var extraField;
      /** @type {(Array.<number>|Uint8Array)} */

      var comment;
      /** @type {(Array.<number>|Uint8Array)} */

      var buffer;
      /** @type {*} */

      var tmp;
      /** @type {Array.<number>|Uint32Array|Object} */

      var key;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {number} */

      var j;
      /** @type {number} */

      var jl; // ファイルの圧縮

      for (i = 0, il = files.length; i < il; ++i) {
        file = files[i];
        filenameLength = file.option['filename'] ? file.option['filename'].length : 0;
        extraFieldLength = file.option['extraField'] ? file.option['extraField'].length : 0;
        commentLength = file.option['comment'] ? file.option['comment'].length : 0; // 圧縮されていなかったら圧縮

        if (!file.compressed) {
          // 圧縮前に CRC32 の計算をしておく
          file.crc32 = Zlib$2.CRC32.calc(file.buffer);

          switch (file.option['compressionMethod']) {
            case Zlib$2.Zip.CompressionMethod.STORE:
              break;

            case Zlib$2.Zip.CompressionMethod.DEFLATE:
              file.buffer = this.deflateWithOption(file.buffer, file.option);
              file.compressed = true;
              break;

            default:
              throw new Error('unknown compression method:' + file.option['compressionMethod']);
          }
        } // encryption


        if (file.option['password'] !== void 0 || this.password !== void 0) {
          // init encryption
          key = this.createEncryptionKey(file.option['password'] || this.password); // add header

          buffer = file.buffer;

          {
            tmp = new Uint8Array(buffer.length + 12);
            tmp.set(buffer, 12);
            buffer = tmp;
          }

          for (j = 0; j < 12; ++j) {
            buffer[j] = this.encode(key, i === 11 ? file.crc32 & 0xff : Math.random() * 256 | 0);
          } // data encryption


          for (jl = buffer.length; j < jl; ++j) {
            buffer[j] = this.encode(key, buffer[j]);
          }

          file.buffer = buffer;
        } // 必要バッファサイズの計算


        localFileSize += // local file header
        30 + filenameLength + // file data
        file.buffer.length;
        centralDirectorySize += // file header
        46 + filenameLength + commentLength;
      } // end of central directory


      endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);
      output = new (Uint8Array )(localFileSize + centralDirectorySize + endOfCentralDirectorySize);
      op1 = 0;
      op2 = localFileSize;
      op3 = op2 + centralDirectorySize; // ファイルの圧縮

      for (i = 0, il = files.length; i < il; ++i) {
        file = files[i];
        filenameLength = file.option['filename'] ? file.option['filename'].length : 0;
        extraFieldLength = 0; // TODO

        commentLength = file.option['comment'] ? file.option['comment'].length : 0; //-------------------------------------------------------------------------
        // local file header & file header
        //-------------------------------------------------------------------------

        offset = op1; // signature
        // local file header

        output[op1++] = Zlib$2.Zip.LocalFileHeaderSignature[0];
        output[op1++] = Zlib$2.Zip.LocalFileHeaderSignature[1];
        output[op1++] = Zlib$2.Zip.LocalFileHeaderSignature[2];
        output[op1++] = Zlib$2.Zip.LocalFileHeaderSignature[3]; // file header

        output[op2++] = Zlib$2.Zip.FileHeaderSignature[0];
        output[op2++] = Zlib$2.Zip.FileHeaderSignature[1];
        output[op2++] = Zlib$2.Zip.FileHeaderSignature[2];
        output[op2++] = Zlib$2.Zip.FileHeaderSignature[3]; // compressor info

        needVersion = 20;
        output[op2++] = needVersion & 0xff;
        output[op2++] =
        /** @type {Zlib.Zip.OperatingSystem} */
        file.option['os'] || Zlib$2.Zip.OperatingSystem.MSDOS; // need version

        output[op1++] = output[op2++] = needVersion & 0xff;
        output[op1++] = output[op2++] = needVersion >> 8 & 0xff; // general purpose bit flag

        flags = 0;

        if (file.option['password'] || this.password) {
          flags |= Zlib$2.Zip.Flags.ENCRYPT;
        }

        output[op1++] = output[op2++] = flags & 0xff;
        output[op1++] = output[op2++] = flags >> 8 & 0xff; // compression method

        compressionMethod =
        /** @type {Zlib.Zip.CompressionMethod} */
        file.option['compressionMethod'];
        output[op1++] = output[op2++] = compressionMethod & 0xff;
        output[op1++] = output[op2++] = compressionMethod >> 8 & 0xff; // date

        date =
        /** @type {(Date|undefined)} */
        file.option['date'] || new Date();
        output[op1++] = output[op2++] = (date.getMinutes() & 0x7) << 5 | (date.getSeconds() / 2 | 0);
        output[op1++] = output[op2++] = date.getHours() << 3 | date.getMinutes() >> 3; //

        output[op1++] = output[op2++] = (date.getMonth() + 1 & 0x7) << 5 | date.getDate();
        output[op1++] = output[op2++] = (date.getFullYear() - 1980 & 0x7f) << 1 | date.getMonth() + 1 >> 3; // CRC-32

        crc32 = file.crc32;
        output[op1++] = output[op2++] = crc32 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 8 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 16 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 24 & 0xff; // compressed size

        size = file.buffer.length;
        output[op1++] = output[op2++] = size & 0xff;
        output[op1++] = output[op2++] = size >> 8 & 0xff;
        output[op1++] = output[op2++] = size >> 16 & 0xff;
        output[op1++] = output[op2++] = size >> 24 & 0xff; // uncompressed size

        plainSize = file.size;
        output[op1++] = output[op2++] = plainSize & 0xff;
        output[op1++] = output[op2++] = plainSize >> 8 & 0xff;
        output[op1++] = output[op2++] = plainSize >> 16 & 0xff;
        output[op1++] = output[op2++] = plainSize >> 24 & 0xff; // filename length

        output[op1++] = output[op2++] = filenameLength & 0xff;
        output[op1++] = output[op2++] = filenameLength >> 8 & 0xff; // extra field length

        output[op1++] = output[op2++] = extraFieldLength & 0xff;
        output[op1++] = output[op2++] = extraFieldLength >> 8 & 0xff; // file comment length

        output[op2++] = commentLength & 0xff;
        output[op2++] = commentLength >> 8 & 0xff; // disk number start

        output[op2++] = 0;
        output[op2++] = 0; // internal file attributes

        output[op2++] = 0;
        output[op2++] = 0; // external file attributes

        output[op2++] = 0;
        output[op2++] = 0;
        output[op2++] = 0;
        output[op2++] = 0; // relative offset of local header

        output[op2++] = offset & 0xff;
        output[op2++] = offset >> 8 & 0xff;
        output[op2++] = offset >> 16 & 0xff;
        output[op2++] = offset >> 24 & 0xff; // filename

        filename = file.option['filename'];

        if (filename) {
          {
            output.set(filename, op1);
            output.set(filename, op2);
            op1 += filenameLength;
            op2 += filenameLength;
          }
        } // extra field


        extraField = file.option['extraField'];

        if (extraField) {
          {
            output.set(extraField, op1);
            output.set(extraField, op2);
            op1 += extraFieldLength;
            op2 += extraFieldLength;
          }
        } // comment


        comment = file.option['comment'];

        if (comment) {
          {
            output.set(comment, op2);
            op2 += commentLength;
          }
        } //-------------------------------------------------------------------------
        // file data
        //-------------------------------------------------------------------------


        {
          output.set(file.buffer, op1);
          op1 += file.buffer.length;
        }
      } //-------------------------------------------------------------------------
      // end of central directory
      //-------------------------------------------------------------------------
      // signature


      output[op3++] = Zlib$2.Zip.CentralDirectorySignature[0];
      output[op3++] = Zlib$2.Zip.CentralDirectorySignature[1];
      output[op3++] = Zlib$2.Zip.CentralDirectorySignature[2];
      output[op3++] = Zlib$2.Zip.CentralDirectorySignature[3]; // number of this disk

      output[op3++] = 0;
      output[op3++] = 0; // number of the disk with the start of the central directory

      output[op3++] = 0;
      output[op3++] = 0; // total number of entries in the central directory on this disk

      output[op3++] = il & 0xff;
      output[op3++] = il >> 8 & 0xff; // total number of entries in the central directory

      output[op3++] = il & 0xff;
      output[op3++] = il >> 8 & 0xff; // size of the central directory

      output[op3++] = centralDirectorySize & 0xff;
      output[op3++] = centralDirectorySize >> 8 & 0xff;
      output[op3++] = centralDirectorySize >> 16 & 0xff;
      output[op3++] = centralDirectorySize >> 24 & 0xff; // offset of start of central directory with respect to the starting disk number

      output[op3++] = localFileSize & 0xff;
      output[op3++] = localFileSize >> 8 & 0xff;
      output[op3++] = localFileSize >> 16 & 0xff;
      output[op3++] = localFileSize >> 24 & 0xff; // .ZIP file comment length

      commentLength = this.comment ? this.comment.length : 0;
      output[op3++] = commentLength & 0xff;
      output[op3++] = commentLength >> 8 & 0xff; // .ZIP file comment

      if (this.comment) {
        {
          output.set(this.comment, op3);
          op3 += commentLength;
        }
      }

      return output;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input
     * @param {Object=} opt_params options.
     * @return {!(Array.<number>|Uint8Array)}
     */


    Zlib$2.Zip.prototype.deflateWithOption = function (input, opt_params) {
      /** @type {Zlib.RawDeflate} */
      var deflator = new Zlib$2.RawDeflate(input, opt_params['deflateOption']);
      return deflator.compress();
    };
    /**
     * @param {(Array.<number>|Uint32Array)} key
     * @return {number}
     */


    Zlib$2.Zip.prototype.getByte = function (key) {
      /** @type {number} */
      var tmp = key[2] & 0xffff | 2;
      return tmp * (tmp ^ 1) >> 8 & 0xff;
    };
    /**
     * @param {(Array.<number>|Uint32Array|Object)} key
     * @param {number} n
     * @return {number}
     */


    Zlib$2.Zip.prototype.encode = function (key, n) {
      /** @type {number} */
      var tmp = this.getByte(
      /** @type {(Array.<number>|Uint32Array)} */
      key);
      this.updateKeys(
      /** @type {(Array.<number>|Uint32Array)} */
      key, n);
      return tmp ^ n;
    };
    /**
     * @param {(Array.<number>|Uint32Array)} key
     * @param {number} n
     */


    Zlib$2.Zip.prototype.updateKeys = function (key, n) {
      key[0] = Zlib$2.CRC32.single(key[0], n);
      key[1] = (((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681 >>> 0) + 1 >>> 0;
      key[2] = Zlib$2.CRC32.single(key[2], key[1] >>> 24);
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     * @return {!(Array.<number>|Uint32Array|Object)}
     */


    Zlib$2.Zip.prototype.createEncryptionKey = function (password) {
      /** @type {!(Array.<number>|Uint32Array)} */
      var key = [305419896, 591751049, 878082192];
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;

      {
        key = new Uint32Array(key);
      }

      for (i = 0, il = password.length; i < il; ++i) {
        this.updateKeys(key, password[i] & 0xff);
      }

      return key;
    };
    /**
     * build huffman table from length list.
     * @param {!(Array.<number>|Uint8Array)} lengths length list.
     * @return {!Array} huffman table.
     */


    Zlib$2.Huffman.buildHuffmanTable = function (lengths) {
      /** @type {number} length list size. */
      var listSize = lengths.length;
      /** @type {number} max code length for table size. */

      var maxCodeLength = 0;
      /** @type {number} min code length for table size. */

      var minCodeLength = Number.POSITIVE_INFINITY;
      /** @type {number} table size. */

      var size;
      /** @type {!(Array|Uint8Array)} huffman code table. */

      var table;
      /** @type {number} bit length. */

      var bitLength;
      /** @type {number} huffman code. */

      var code;
      /**
       * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
       * @type {number} skip length for table filling.
       */

      var skip;
      /** @type {number} reversed code. */

      var reversed;
      /** @type {number} reverse temp. */

      var rtemp;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limit. */

      var il;
      /** @type {number} loop counter. */

      var j;
      /** @type {number} table value. */

      var value; // Math.max は遅いので最長の値は for-loop で取得する

      for (i = 0, il = listSize; i < il; ++i) {
        if (lengths[i] > maxCodeLength) {
          maxCodeLength = lengths[i];
        }

        if (lengths[i] < minCodeLength) {
          minCodeLength = lengths[i];
        }
      }

      size = 1 << maxCodeLength;
      table = new (Uint32Array )(size); // ビット長の短い順からハフマン符号を割り当てる

      for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
        for (i = 0; i < listSize; ++i) {
          if (lengths[i] === bitLength) {
            // ビットオーダーが逆になるためビット長分並びを反転する
            for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
              reversed = reversed << 1 | rtemp & 1;
              rtemp >>= 1;
            } // 最大ビット長をもとにテーブルを作るため、
            // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
            // そのどちらでも良い場所は同じ値で埋めることで
            // 本来のビット長以上のビット数取得しても問題が起こらないようにする


            value = bitLength << 16 | i;

            for (j = reversed; j < size; j += skip) {
              table[j] = value;
            }

            ++code;
          }
        } // 次のビット長へ


        ++bitLength;
        code <<= 1;
        skip <<= 1;
      }

      return [table, maxCodeLength, minCodeLength];
    }; //-----------------------------------------------------------------------------

    /** @define {number} buffer block size. */


    var ZLIB_RAW_INFLATE_BUFFER_SIZE$2 = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]
    //-----------------------------------------------------------------------------

    var buildHuffmanTable$2 = Zlib$2.Huffman.buildHuffmanTable;
    /**
     * @constructor
     * @param {!(Uint8Array|Array.<number>)} input input buffer.
     * @param {Object} opt_params option parameter.
     *
     * opt_params は以下のプロパティを指定する事ができます。
     *   - index: input buffer の deflate コンテナの開始位置.
     *   - blockSize: バッファのブロックサイズ.
     *   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
     *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
     */

    Zlib$2.RawInflate = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} inflated buffer */
      this.buffer;
      /** @type {!Array.<(Array.<number>|Uint8Array)>} */

      this.blocks = [];
      /** @type {number} block size. */

      this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE$2;
      /** @type {!number} total output buffer pointer. */

      this.totalpos = 0;
      /** @type {!number} input buffer pointer. */

      this.ip = 0;
      /** @type {!number} bit stream reader buffer. */

      this.bitsbuf = 0;
      /** @type {!number} bit stream reader buffer size. */

      this.bitsbuflen = 0;
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */

      this.input = new Uint8Array(input) ;
      /** @type {!(Uint8Array|Array.<number>)} output buffer. */

      this.output;
      /** @type {!number} output buffer pointer. */

      this.op;
      /** @type {boolean} is final block flag. */

      this.bfinal = false;
      /** @type {Zlib.RawInflate.BufferType} buffer management. */

      this.bufferType = Zlib$2.RawInflate.BufferType.ADAPTIVE;
      /** @type {boolean} resize flag for memory size optimization. */

      this.resize = false; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (opt_params['index']) {
          this.ip = opt_params['index'];
        }

        if (opt_params['bufferSize']) {
          this.bufferSize = opt_params['bufferSize'];
        }

        if (opt_params['bufferType']) {
          this.bufferType = opt_params['bufferType'];
        }

        if (opt_params['resize']) {
          this.resize = opt_params['resize'];
        }
      } // initialize


      switch (this.bufferType) {
        case Zlib$2.RawInflate.BufferType.BLOCK:
          this.op = Zlib$2.RawInflate.MaxBackwardLength;
          this.output = new (Uint8Array )(Zlib$2.RawInflate.MaxBackwardLength + this.bufferSize + Zlib$2.RawInflate.MaxCopyLength);
          break;

        case Zlib$2.RawInflate.BufferType.ADAPTIVE:
          this.op = 0;
          this.output = new (Uint8Array )(this.bufferSize);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * @enum {number}
     */


    Zlib$2.RawInflate.BufferType = {
      BLOCK: 0,
      ADAPTIVE: 1
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array.<number>)} inflated buffer.
     */

    Zlib$2.RawInflate.prototype.decompress = function () {
      while (!this.bfinal) {
        this.parseBlock();
      }

      switch (this.bufferType) {
        case Zlib$2.RawInflate.BufferType.BLOCK:
          return this.concatBufferBlock();

        case Zlib$2.RawInflate.BufferType.ADAPTIVE:
          return this.concatBufferDynamic();

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * @const
     * @type {number} max backward length for LZ77.
     */


    Zlib$2.RawInflate.MaxBackwardLength = 32768;
    /**
     * @const
     * @type {number} max copy length for LZ77.
     */

    Zlib$2.RawInflate.MaxCopyLength = 258;
    /**
     * huffman order
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */

    Zlib$2.RawInflate.Order = function (table) {
      return new Uint16Array(table) ;
    }([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    /**
     * huffman length code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib$2.RawInflate.LengthCodeTable = function (table) {
      return new Uint16Array(table) ;
    }([0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b, 0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3, 0x00e3, 0x0102, 0x0102, 0x0102]);
    /**
     * huffman length extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib$2.RawInflate.LengthExtraTable = function (table) {
      return new Uint8Array(table) ;
    }([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
    /**
     * huffman dist code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib$2.RawInflate.DistCodeTable = function (table) {
      return new Uint16Array(table) ;
    }([0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001]);
    /**
     * huffman dist extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib$2.RawInflate.DistExtraTable = function (table) {
      return new Uint8Array(table) ;
    }([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    /**
     * fixed huffman length code table
     * @const
     * @type {!Array}
     */


    Zlib$2.RawInflate.FixedLiteralLengthTable = function (table) {
      return table;
    }(function () {
      var lengths = new (Uint8Array )(288);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
      }

      return buildHuffmanTable$2(lengths);
    }());
    /**
     * fixed huffman distance code table
     * @const
     * @type {!Array}
     */


    Zlib$2.RawInflate.FixedDistanceTable = function (table) {
      return table;
    }(function () {
      var lengths = new (Uint8Array )(30);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = 5;
      }

      return buildHuffmanTable$2(lengths);
    }());
    /**
     * parse deflated block.
     */


    Zlib$2.RawInflate.prototype.parseBlock = function () {
      /** @type {number} header */
      var hdr = this.readBits(3); // BFINAL

      if (hdr & 0x1) {
        this.bfinal = true;
      } // BTYPE


      hdr >>>= 1;

      switch (hdr) {
        // uncompressed
        case 0:
          this.parseUncompressedBlock();
          break;
        // fixed huffman

        case 1:
          this.parseFixedHuffmanBlock();
          break;
        // dynamic huffman

        case 2:
          this.parseDynamicHuffmanBlock();
          break;
        // reserved or other

        default:
          throw new Error('unknown BTYPE: ' + hdr);
      }
    };
    /**
     * read inflate bits
     * @param {number} length bits length.
     * @return {number} read bits.
     */


    Zlib$2.RawInflate.prototype.readBits = function (length) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {number} input and output byte. */

      var octet; // input byte

      if (ip + (length - bitsbuflen + 7 >> 3) >= inputLength) {
        throw new Error('input buffer is broken');
      } // not enough buffer


      while (bitsbuflen < length) {
        bitsbuf |= input[ip++] << bitsbuflen;
        bitsbuflen += 8;
      } // output byte


      octet = bitsbuf &
      /* MASK */
      (1 << length) - 1;
      bitsbuf >>>= length;
      bitsbuflen -= length;
      this.bitsbuf = bitsbuf;
      this.bitsbuflen = bitsbuflen;
      this.ip = ip;
      return octet;
    };
    /**
     * read huffman code using table
     * @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.
     * @return {number} huffman code.
     */


    Zlib$2.RawInflate.prototype.readCodeByTable = function (table) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {!(Array.<number>|Uint8Array)} huffman code table */

      var codeTable = table[0];
      /** @type {number} */

      var maxCodeLength = table[1];
      /** @type {number} code length & code (16bit, 16bit) */

      var codeWithLength;
      /** @type {number} code bits length */

      var codeLength; // not enough buffer

      while (bitsbuflen < maxCodeLength) {
        if (ip >= inputLength) {
          break;
        }

        bitsbuf |= input[ip++] << bitsbuflen;
        bitsbuflen += 8;
      } // read max length


      codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
      codeLength = codeWithLength >>> 16;

      if (codeLength > bitsbuflen) {
        throw new Error('invalid code length: ' + codeLength);
      }

      this.bitsbuf = bitsbuf >> codeLength;
      this.bitsbuflen = bitsbuflen - codeLength;
      this.ip = ip;
      return codeWithLength & 0xffff;
    };
    /**
     * parse uncompressed block.
     */


    Zlib$2.RawInflate.prototype.parseUncompressedBlock = function () {
      var input = this.input;
      var ip = this.ip;
      var output = this.output;
      var op = this.op;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {number} block length */

      var len;
      /** @type {number} number for check block length */

      var nlen;
      /** @type {number} output buffer length */

      var olength = output.length;
      /** @type {number} copy counter */

      var preCopy; // skip buffered header bits

      this.bitsbuf = 0;
      this.bitsbuflen = 0; // len

      if (ip + 1 >= inputLength) {
        throw new Error('invalid uncompressed block header: LEN');
      }

      len = input[ip++] | input[ip++] << 8; // nlen

      if (ip + 1 >= inputLength) {
        throw new Error('invalid uncompressed block header: NLEN');
      }

      nlen = input[ip++] | input[ip++] << 8; // check len & nlen

      if (len === ~nlen) {
        throw new Error('invalid uncompressed block header: length verify');
      } // check size


      if (ip + len > input.length) {
        throw new Error('input buffer is broken');
      } // expand buffer


      switch (this.bufferType) {
        case Zlib$2.RawInflate.BufferType.BLOCK:
          // pre copy
          while (op + len > output.length) {
            preCopy = olength - op;
            len -= preCopy;

            {
              output.set(input.subarray(ip, ip + preCopy), op);
              op += preCopy;
              ip += preCopy;
            }

            this.op = op;
            output = this.expandBufferBlock();
            op = this.op;
          }

          break;

        case Zlib$2.RawInflate.BufferType.ADAPTIVE:
          while (op + len > output.length) {
            output = this.expandBufferAdaptive({
              fixRatio: 2
            });
          }

          break;

        default:
          throw new Error('invalid inflate mode');
      } // copy


      {
        output.set(input.subarray(ip, ip + len), op);
        op += len;
        ip += len;
      }

      this.ip = ip;
      this.op = op;
      this.output = output;
    };
    /**
     * parse fixed huffman block.
     */


    Zlib$2.RawInflate.prototype.parseFixedHuffmanBlock = function () {
      switch (this.bufferType) {
        case Zlib$2.RawInflate.BufferType.ADAPTIVE:
          this.decodeHuffmanAdaptive(Zlib$2.RawInflate.FixedLiteralLengthTable, Zlib$2.RawInflate.FixedDistanceTable);
          break;

        case Zlib$2.RawInflate.BufferType.BLOCK:
          this.decodeHuffmanBlock(Zlib$2.RawInflate.FixedLiteralLengthTable, Zlib$2.RawInflate.FixedDistanceTable);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * parse dynamic huffman block.
     */


    Zlib$2.RawInflate.prototype.parseDynamicHuffmanBlock = function () {
      /** @type {number} number of literal and length codes. */
      var hlit = this.readBits(5) + 257;
      /** @type {number} number of distance codes. */

      var hdist = this.readBits(5) + 1;
      /** @type {number} number of code lengths. */

      var hclen = this.readBits(4) + 4;
      /** @type {!(Uint8Array|Array.<number>)} code lengths. */

      var codeLengths = new (Uint8Array )(Zlib$2.RawInflate.Order.length);
      /** @type {!Array} code lengths table. */

      var codeLengthsTable;
      /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */

      var litlenTable;
      /** @type {!(Uint8Array|Array.<number>)} distance code table. */

      var distTable;
      /** @type {!(Uint8Array|Array.<number>)} code length table. */

      var lengthTable;
      /** @type {number} */

      var code;
      /** @type {number} */

      var prev;
      /** @type {number} */

      var repeat;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limit. */

      var il; // decode code lengths

      for (i = 0; i < hclen; ++i) {
        codeLengths[Zlib$2.RawInflate.Order[i]] = this.readBits(3);
      }


      codeLengthsTable = buildHuffmanTable$2(codeLengths);
      lengthTable = new (Uint8Array )(hlit + hdist);

      for (i = 0, il = hlit + hdist; i < il;) {
        code = this.readCodeByTable(codeLengthsTable);

        switch (code) {
          case 16:
            repeat = 3 + this.readBits(2);

            while (repeat--) {
              lengthTable[i++] = prev;
            }

            break;

          case 17:
            repeat = 3 + this.readBits(3);

            while (repeat--) {
              lengthTable[i++] = 0;
            }

            prev = 0;
            break;

          case 18:
            repeat = 11 + this.readBits(7);

            while (repeat--) {
              lengthTable[i++] = 0;
            }

            prev = 0;
            break;

          default:
            lengthTable[i++] = code;
            prev = code;
            break;
        }
      }

      litlenTable = buildHuffmanTable$2(lengthTable.subarray(0, hlit)) ;
      distTable = buildHuffmanTable$2(lengthTable.subarray(hlit)) ;

      switch (this.bufferType) {
        case Zlib$2.RawInflate.BufferType.ADAPTIVE:
          this.decodeHuffmanAdaptive(litlenTable, distTable);
          break;

        case Zlib$2.RawInflate.BufferType.BLOCK:
          this.decodeHuffmanBlock(litlenTable, distTable);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * decode huffman code
     * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
     * @param {!(Array.<number>|Uint8Array)} dist distination code table.
     */


    Zlib$2.RawInflate.prototype.decodeHuffmanBlock = function (litlen, dist) {
      var output = this.output;
      var op = this.op;
      this.currentLitlenTable = litlen;
      /** @type {number} output position limit. */

      var olength = output.length - Zlib$2.RawInflate.MaxCopyLength;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var lengthCodeTable = Zlib$2.RawInflate.LengthCodeTable;
      var lengthExtraTable = Zlib$2.RawInflate.LengthExtraTable;
      var distCodeTable = Zlib$2.RawInflate.DistCodeTable;
      var distExtraTable = Zlib$2.RawInflate.DistExtraTable;

      while ((code = this.readCodeByTable(litlen)) !== 256) {
        // literal
        if (code < 256) {
          if (op >= olength) {
            this.op = op;
            output = this.expandBufferBlock();
            op = this.op;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = lengthCodeTable[ti];

        if (lengthExtraTable[ti] > 0) {
          codeLength += this.readBits(lengthExtraTable[ti]);
        } // dist code


        code = this.readCodeByTable(dist);
        codeDist = distCodeTable[code];

        if (distExtraTable[code] > 0) {
          codeDist += this.readBits(distExtraTable[code]);
        } // lz77 decode


        if (op >= olength) {
          this.op = op;
          output = this.expandBufferBlock();
          op = this.op;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
    };
    /**
     * decode huffman code (adaptive)
     * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
     * @param {!(Array.<number>|Uint8Array)} dist distination code table.
     */


    Zlib$2.RawInflate.prototype.decodeHuffmanAdaptive = function (litlen, dist) {
      var output = this.output;
      var op = this.op;
      this.currentLitlenTable = litlen;
      /** @type {number} output position limit. */

      var olength = output.length;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var lengthCodeTable = Zlib$2.RawInflate.LengthCodeTable;
      var lengthExtraTable = Zlib$2.RawInflate.LengthExtraTable;
      var distCodeTable = Zlib$2.RawInflate.DistCodeTable;
      var distExtraTable = Zlib$2.RawInflate.DistExtraTable;

      while ((code = this.readCodeByTable(litlen)) !== 256) {
        // literal
        if (code < 256) {
          if (op >= olength) {
            output = this.expandBufferAdaptive();
            olength = output.length;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = lengthCodeTable[ti];

        if (lengthExtraTable[ti] > 0) {
          codeLength += this.readBits(lengthExtraTable[ti]);
        } // dist code


        code = this.readCodeByTable(dist);
        codeDist = distCodeTable[code];

        if (distExtraTable[code] > 0) {
          codeDist += this.readBits(distExtraTable[code]);
        } // lz77 decode


        if (op + codeLength > olength) {
          output = this.expandBufferAdaptive();
          olength = output.length;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
    };
    /**
     * expand output buffer.
     * @param {Object=} opt_param option parameters.
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib$2.RawInflate.prototype.expandBufferBlock = function (opt_param) {
      /** @type {!(Array.<number>|Uint8Array)} store buffer. */
      var buffer = new (Uint8Array )(this.op - Zlib$2.RawInflate.MaxBackwardLength);
      /** @type {number} backward base point */

      var backward = this.op - Zlib$2.RawInflate.MaxBackwardLength;
      var output = this.output; // copy to output buffer

      {
        buffer.set(output.subarray(Zlib$2.RawInflate.MaxBackwardLength, buffer.length));
      }

      this.blocks.push(buffer);
      this.totalpos += buffer.length; // copy to backward buffer

      {
        output.set(output.subarray(backward, backward + Zlib$2.RawInflate.MaxBackwardLength));
      }

      this.op = Zlib$2.RawInflate.MaxBackwardLength;
      return output;
    };
    /**
     * expand output buffer. (adaptive)
     * @param {Object=} opt_param option parameters.
     * @return {!(Array.<number>|Uint8Array)} output buffer pointer.
     */


    Zlib$2.RawInflate.prototype.expandBufferAdaptive = function (opt_param) {
      /** @type {!(Array.<number>|Uint8Array)} store buffer. */
      var buffer;
      /** @type {number} expantion ratio. */

      var ratio = this.input.length / this.ip + 1 | 0;
      /** @type {number} maximum number of huffman code. */

      var maxHuffCode;
      /** @type {number} new output buffer size. */

      var newSize;
      /** @type {number} max inflate size. */

      var maxInflateSize;
      var input = this.input;
      var output = this.output;

      if (opt_param) {
        if (typeof opt_param.fixRatio === 'number') {
          ratio = opt_param.fixRatio;
        }

        if (typeof opt_param.addRatio === 'number') {
          ratio += opt_param.addRatio;
        }
      } // calculate new buffer size


      if (ratio < 2) {
        maxHuffCode = (input.length - this.ip) / this.currentLitlenTable[2];
        maxInflateSize = maxHuffCode / 2 * 258 | 0;
        newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
      } else {
        newSize = output.length * ratio;
      } // buffer expantion


      {
        buffer = new Uint8Array(newSize);
        buffer.set(output);
      }

      this.output = buffer;
      return this.output;
    };
    /**
     * concat output buffer.
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib$2.RawInflate.prototype.concatBufferBlock = function () {
      /** @type {number} buffer pointer. */
      var pos = 0;
      /** @type {number} buffer pointer. */

      var limit = this.totalpos + (this.op - Zlib$2.RawInflate.MaxBackwardLength);
      /** @type {!(Array.<number>|Uint8Array)} output block array. */

      var output = this.output;
      /** @type {!Array} blocks array. */

      var blocks = this.blocks;
      /** @type {!(Array.<number>|Uint8Array)} output block array. */

      var block;
      /** @type {!(Array.<number>|Uint8Array)} output buffer. */

      var buffer = new (Uint8Array )(limit);
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limiter. */

      var il;
      /** @type {number} loop counter. */

      var j;
      /** @type {number} loop limiter. */

      var jl; // single buffer

      if (blocks.length === 0) {
        return this.output.subarray(Zlib$2.RawInflate.MaxBackwardLength, this.op) ;
      } // copy to buffer


      for (i = 0, il = blocks.length; i < il; ++i) {
        block = blocks[i];

        for (j = 0, jl = block.length; j < jl; ++j) {
          buffer[pos++] = block[j];
        }
      } // current buffer


      for (i = Zlib$2.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
        buffer[pos++] = output[i];
      }

      this.blocks = [];
      this.buffer = buffer;
      return this.buffer;
    };
    /**
     * concat output buffer. (dynamic)
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib$2.RawInflate.prototype.concatBufferDynamic = function () {
      /** @type {Array.<number>|Uint8Array} output buffer. */
      var buffer;
      var op = this.op;

      {
        if (this.resize) {
          buffer = new Uint8Array(op);
          buffer.set(this.output.subarray(0, op));
        } else {
          buffer = this.output.subarray(0, op);
        }
      }

      this.buffer = buffer;
      return this.buffer;
    };

    var buildHuffmanTable$2 = Zlib$2.Huffman.buildHuffmanTable;
    /**
     * @param {!(Uint8Array|Array.<number>)} input input buffer.
     * @param {number} ip input buffer pointer.
     * @param {number=} opt_buffersize buffer block size.
     * @constructor
     */

    Zlib$2.RawInflateStream = function (input, ip, opt_buffersize) {
      /** @type {!Array.<(Array|Uint8Array)>} */
      this.blocks = [];
      /** @type {number} block size. */

      this.bufferSize = opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE$2;
      /** @type {!number} total output buffer pointer. */

      this.totalpos = 0;
      /** @type {!number} input buffer pointer. */

      this.ip = ip === void 0 ? 0 : ip;
      /** @type {!number} bit stream reader buffer. */

      this.bitsbuf = 0;
      /** @type {!number} bit stream reader buffer size. */

      this.bitsbuflen = 0;
      /** @type {!(Array|Uint8Array)} input buffer. */

      this.input = new Uint8Array(input) ;
      /** @type {!(Uint8Array|Array)} output buffer. */

      this.output = new (Uint8Array )(this.bufferSize);
      /** @type {!number} output buffer pointer. */

      this.op = 0;
      /** @type {boolean} is final block flag. */

      this.bfinal = false;
      /** @type {number} uncompressed block length. */

      this.blockLength;
      /** @type {boolean} resize flag for memory size optimization. */

      this.resize = false;
      /** @type {Array} */

      this.litlenTable;
      /** @type {Array} */

      this.distTable;
      /** @type {number} */

      this.sp = 0; // stream pointer

      /** @type {Zlib.RawInflateStream.Status} */

      this.status = Zlib$2.RawInflateStream.Status.INITIALIZED; //
      // backup
      //

      /** @type {!number} */

      this.ip_;
      /** @type {!number} */

      this.bitsbuflen_;
      /** @type {!number} */

      this.bitsbuf_;
    };
    /**
     * @enum {number}
     */


    Zlib$2.RawInflateStream.BlockType = {
      UNCOMPRESSED: 0,
      FIXED: 1,
      DYNAMIC: 2
    };
    /**
     * @enum {number}
     */

    Zlib$2.RawInflateStream.Status = {
      INITIALIZED: 0,
      BLOCK_HEADER_START: 1,
      BLOCK_HEADER_END: 2,
      BLOCK_BODY_START: 3,
      BLOCK_BODY_END: 4,
      DECODE_BLOCK_START: 5,
      DECODE_BLOCK_END: 6
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */

    Zlib$2.RawInflateStream.prototype.decompress = function (newInput, ip) {
      /** @type {boolean} */
      var stop = false;

      if (newInput !== void 0) {
        this.input = newInput;
      }

      if (ip !== void 0) {
        this.ip = ip;
      } // decompress


      while (!stop) {
        switch (this.status) {
          // block header
          case Zlib$2.RawInflateStream.Status.INITIALIZED:
          case Zlib$2.RawInflateStream.Status.BLOCK_HEADER_START:
            if (this.readBlockHeader() < 0) {
              stop = true;
            }

            break;
          // block body

          case Zlib$2.RawInflateStream.Status.BLOCK_HEADER_END:
          /* FALLTHROUGH */

          case Zlib$2.RawInflateStream.Status.BLOCK_BODY_START:
            switch (this.currentBlockType) {
              case Zlib$2.RawInflateStream.BlockType.UNCOMPRESSED:
                if (this.readUncompressedBlockHeader() < 0) {
                  stop = true;
                }

                break;

              case Zlib$2.RawInflateStream.BlockType.FIXED:
                if (this.parseFixedHuffmanBlock() < 0) {
                  stop = true;
                }

                break;

              case Zlib$2.RawInflateStream.BlockType.DYNAMIC:
                if (this.parseDynamicHuffmanBlock() < 0) {
                  stop = true;
                }

                break;
            }

            break;
          // decode data

          case Zlib$2.RawInflateStream.Status.BLOCK_BODY_END:
          case Zlib$2.RawInflateStream.Status.DECODE_BLOCK_START:
            switch (this.currentBlockType) {
              case Zlib$2.RawInflateStream.BlockType.UNCOMPRESSED:
                if (this.parseUncompressedBlock() < 0) {
                  stop = true;
                }

                break;

              case Zlib$2.RawInflateStream.BlockType.FIXED:
              /* FALLTHROUGH */

              case Zlib$2.RawInflateStream.BlockType.DYNAMIC:
                if (this.decodeHuffman() < 0) {
                  stop = true;
                }

                break;
            }

            break;

          case Zlib$2.RawInflateStream.Status.DECODE_BLOCK_END:
            if (this.bfinal) {
              stop = true;
            } else {
              this.status = Zlib$2.RawInflateStream.Status.INITIALIZED;
            }

            break;
        }
      }

      return this.concatBuffer();
    };
    /**
     * @const
     * @type {number} max backward length for LZ77.
     */


    Zlib$2.RawInflateStream.MaxBackwardLength = 32768;
    /**
     * @const
     * @type {number} max copy length for LZ77.
     */

    Zlib$2.RawInflateStream.MaxCopyLength = 258;
    /**
     * huffman order
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */

    Zlib$2.RawInflateStream.Order = function (table) {
      return new Uint16Array(table) ;
    }([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    /**
     * huffman length code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib$2.RawInflateStream.LengthCodeTable = function (table) {
      return new Uint16Array(table) ;
    }([0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b, 0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3, 0x00e3, 0x0102, 0x0102, 0x0102]);
    /**
     * huffman length extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib$2.RawInflateStream.LengthExtraTable = function (table) {
      return new Uint8Array(table) ;
    }([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
    /**
     * huffman dist code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib$2.RawInflateStream.DistCodeTable = function (table) {
      return new Uint16Array(table) ;
    }([0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001]);
    /**
     * huffman dist extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib$2.RawInflateStream.DistExtraTable = function (table) {
      return new Uint8Array(table) ;
    }([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    /**
     * fixed huffman length code table
     * @const
     * @type {!Array}
     */


    Zlib$2.RawInflateStream.FixedLiteralLengthTable = function (table) {
      return table;
    }(function () {
      var lengths = new (Uint8Array )(288);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
      }

      return buildHuffmanTable$2(lengths);
    }());
    /**
     * fixed huffman distance code table
     * @const
     * @type {!Array}
     */


    Zlib$2.RawInflateStream.FixedDistanceTable = function (table) {
      return table;
    }(function () {
      var lengths = new (Uint8Array )(30);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = 5;
      }

      return buildHuffmanTable$2(lengths);
    }());
    /**
     * parse deflated block.
     */


    Zlib$2.RawInflateStream.prototype.readBlockHeader = function () {
      /** @type {number} header */
      var hdr;
      this.status = Zlib$2.RawInflateStream.Status.BLOCK_HEADER_START;
      this.save_();

      if ((hdr = this.readBits(3)) < 0) {
        this.restore_();
        return -1;
      } // BFINAL


      if (hdr & 0x1) {
        this.bfinal = true;
      } // BTYPE


      hdr >>>= 1;

      switch (hdr) {
        case 0:
          // uncompressed
          this.currentBlockType = Zlib$2.RawInflateStream.BlockType.UNCOMPRESSED;
          break;

        case 1:
          // fixed huffman
          this.currentBlockType = Zlib$2.RawInflateStream.BlockType.FIXED;
          break;

        case 2:
          // dynamic huffman
          this.currentBlockType = Zlib$2.RawInflateStream.BlockType.DYNAMIC;
          break;

        default:
          // reserved or other
          throw new Error('unknown BTYPE: ' + hdr);
      }

      this.status = Zlib$2.RawInflateStream.Status.BLOCK_HEADER_END;
    };
    /**
     * read inflate bits
     * @param {number} length bits length.
     * @return {number} read bits.
     */


    Zlib$2.RawInflateStream.prototype.readBits = function (length) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} input and output byte. */

      var octet; // not enough buffer

      while (bitsbuflen < length) {
        // input byte
        if (input.length <= ip) {
          return -1;
        }

        octet = input[ip++]; // concat octet

        bitsbuf |= octet << bitsbuflen;
        bitsbuflen += 8;
      } // output byte


      octet = bitsbuf &
      /* MASK */
      (1 << length) - 1;
      bitsbuf >>>= length;
      bitsbuflen -= length;
      this.bitsbuf = bitsbuf;
      this.bitsbuflen = bitsbuflen;
      this.ip = ip;
      return octet;
    };
    /**
     * read huffman code using table
     * @param {Array} table huffman code table.
     * @return {number} huffman code.
     */


    Zlib$2.RawInflateStream.prototype.readCodeByTable = function (table) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {!(Array|Uint8Array)} huffman code table */

      var codeTable = table[0];
      /** @type {number} */

      var maxCodeLength = table[1];
      /** @type {number} input byte */

      var octet;
      /** @type {number} code length & code (16bit, 16bit) */

      var codeWithLength;
      /** @type {number} code bits length */

      var codeLength; // not enough buffer

      while (bitsbuflen < maxCodeLength) {
        if (input.length <= ip) {
          return -1;
        }

        octet = input[ip++];
        bitsbuf |= octet << bitsbuflen;
        bitsbuflen += 8;
      } // read max length


      codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
      codeLength = codeWithLength >>> 16;

      if (codeLength > bitsbuflen) {
        throw new Error('invalid code length: ' + codeLength);
      }

      this.bitsbuf = bitsbuf >> codeLength;
      this.bitsbuflen = bitsbuflen - codeLength;
      this.ip = ip;
      return codeWithLength & 0xffff;
    };
    /**
     * read uncompressed block header
     */


    Zlib$2.RawInflateStream.prototype.readUncompressedBlockHeader = function () {
      /** @type {number} block length */
      var len;
      /** @type {number} number for check block length */

      var nlen;
      var input = this.input;
      var ip = this.ip;
      this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_START;

      if (ip + 4 >= input.length) {
        return -1;
      }

      len = input[ip++] | input[ip++] << 8;
      nlen = input[ip++] | input[ip++] << 8; // check len & nlen

      if (len === ~nlen) {
        throw new Error('invalid uncompressed block header: length verify');
      } // skip buffered header bits


      this.bitsbuf = 0;
      this.bitsbuflen = 0;
      this.ip = ip;
      this.blockLength = len;
      this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_END;
    };
    /**
     * parse uncompressed block.
     */


    Zlib$2.RawInflateStream.prototype.parseUncompressedBlock = function () {
      var input = this.input;
      var ip = this.ip;
      var output = this.output;
      var op = this.op;
      var len = this.blockLength;
      this.status = Zlib$2.RawInflateStream.Status.DECODE_BLOCK_START; // copy
      // XXX: とりあえず素直にコピー

      while (len--) {
        if (op === output.length) {
          output = this.expandBuffer({
            fixRatio: 2
          });
        } // not enough input buffer


        if (ip >= input.length) {
          this.ip = ip;
          this.op = op;
          this.blockLength = len + 1; // コピーしてないので戻す

          return -1;
        }

        output[op++] = input[ip++];
      }

      if (len < 0) {
        this.status = Zlib$2.RawInflateStream.Status.DECODE_BLOCK_END;
      }

      this.ip = ip;
      this.op = op;
      return 0;
    };
    /**
     * parse fixed huffman block.
     */


    Zlib$2.RawInflateStream.prototype.parseFixedHuffmanBlock = function () {
      this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_START;
      this.litlenTable = Zlib$2.RawInflateStream.FixedLiteralLengthTable;
      this.distTable = Zlib$2.RawInflateStream.FixedDistanceTable;
      this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_END;
      return 0;
    };
    /**
     * オブジェクトのコンテキストを別のプロパティに退避する.
     * @private
     */


    Zlib$2.RawInflateStream.prototype.save_ = function () {
      this.ip_ = this.ip;
      this.bitsbuflen_ = this.bitsbuflen;
      this.bitsbuf_ = this.bitsbuf;
    };
    /**
     * 別のプロパティに退避したコンテキストを復元する.
     * @private
     */


    Zlib$2.RawInflateStream.prototype.restore_ = function () {
      this.ip = this.ip_;
      this.bitsbuflen = this.bitsbuflen_;
      this.bitsbuf = this.bitsbuf_;
    };
    /**
     * parse dynamic huffman block.
     */


    Zlib$2.RawInflateStream.prototype.parseDynamicHuffmanBlock = function () {
      /** @type {number} number of literal and length codes. */
      var hlit;
      /** @type {number} number of distance codes. */

      var hdist;
      /** @type {number} number of code lengths. */

      var hclen;
      /** @type {!(Uint8Array|Array)} code lengths. */

      var codeLengths = new (Uint8Array )(Zlib$2.RawInflateStream.Order.length);
      /** @type {!Array} code lengths table. */

      var codeLengthsTable;
      this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_START;
      this.save_();
      hlit = this.readBits(5) + 257;
      hdist = this.readBits(5) + 1;
      hclen = this.readBits(4) + 4;

      if (hlit < 0 || hdist < 0 || hclen < 0) {
        this.restore_();
        return -1;
      }

      try {
        parseDynamicHuffmanBlockImpl.call(this);
      } catch (e) {
        this.restore_();
        return -1;
      }

      function parseDynamicHuffmanBlockImpl() {
        /** @type {number} */
        var bits;
        var code;
        var prev = 0;
        var repeat;
        /** @type {!(Uint8Array|Array.<number>)} code length table. */

        var lengthTable;
        /** @type {number} loop counter. */

        var i;
        /** @type {number} loop limit. */

        var il; // decode code lengths

        for (i = 0; i < hclen; ++i) {
          if ((bits = this.readBits(3)) < 0) {
            throw new Error('not enough input');
          }

          codeLengths[Zlib$2.RawInflateStream.Order[i]] = bits;
        } // decode length table


        codeLengthsTable = buildHuffmanTable$2(codeLengths);
        lengthTable = new (Uint8Array )(hlit + hdist);

        for (i = 0, il = hlit + hdist; i < il;) {
          code = this.readCodeByTable(codeLengthsTable);

          if (code < 0) {
            throw new Error('not enough input');
          }

          switch (code) {
            case 16:
              if ((bits = this.readBits(2)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 3 + bits;

              while (repeat--) {
                lengthTable[i++] = prev;
              }

              break;

            case 17:
              if ((bits = this.readBits(3)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 3 + bits;

              while (repeat--) {
                lengthTable[i++] = 0;
              }

              prev = 0;
              break;

            case 18:
              if ((bits = this.readBits(7)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 11 + bits;

              while (repeat--) {
                lengthTable[i++] = 0;
              }

              prev = 0;
              break;

            default:
              lengthTable[i++] = code;
              prev = code;
              break;
          }
        } // literal and length code
        this.litlenTable = buildHuffmanTable$2(lengthTable.subarray(0, hlit)) ;
        this.distTable = buildHuffmanTable$2(lengthTable.subarray(hlit)) ;
      }

      this.status = Zlib$2.RawInflateStream.Status.BLOCK_BODY_END;
      return 0;
    };
    /**
     * decode huffman code (dynamic)
     * @return {(number|undefined)} -1 is error.
     */


    Zlib$2.RawInflateStream.prototype.decodeHuffman = function () {
      var output = this.output;
      var op = this.op;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var litlen = this.litlenTable;
      var dist = this.distTable;
      var olength = output.length;
      var bits;
      this.status = Zlib$2.RawInflateStream.Status.DECODE_BLOCK_START;

      while (true) {
        this.save_();
        code = this.readCodeByTable(litlen);

        if (code < 0) {
          this.op = op;
          this.restore_();
          return -1;
        }

        if (code === 256) {
          break;
        } // literal


        if (code < 256) {
          if (op === olength) {
            output = this.expandBuffer();
            olength = output.length;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = Zlib$2.RawInflateStream.LengthCodeTable[ti];

        if (Zlib$2.RawInflateStream.LengthExtraTable[ti] > 0) {
          bits = this.readBits(Zlib$2.RawInflateStream.LengthExtraTable[ti]);

          if (bits < 0) {
            this.op = op;
            this.restore_();
            return -1;
          }

          codeLength += bits;
        } // dist code


        code = this.readCodeByTable(dist);

        if (code < 0) {
          this.op = op;
          this.restore_();
          return -1;
        }

        codeDist = Zlib$2.RawInflateStream.DistCodeTable[code];

        if (Zlib$2.RawInflateStream.DistExtraTable[code] > 0) {
          bits = this.readBits(Zlib$2.RawInflateStream.DistExtraTable[code]);

          if (bits < 0) {
            this.op = op;
            this.restore_();
            return -1;
          }

          codeDist += bits;
        } // lz77 decode


        if (op + codeLength >= olength) {
          output = this.expandBuffer();
          olength = output.length;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        } // break


        if (this.ip === this.input.length) {
          this.op = op;
          return -1;
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
      this.status = Zlib$2.RawInflateStream.Status.DECODE_BLOCK_END;
    };
    /**
     * expand output buffer. (dynamic)
     * @param {Object=} opt_param option parameters.
     * @return {!(Array|Uint8Array)} output buffer pointer.
     */


    Zlib$2.RawInflateStream.prototype.expandBuffer = function (opt_param) {
      /** @type {!(Array|Uint8Array)} store buffer. */
      var buffer;
      /** @type {number} expantion ratio. */

      var ratio = this.input.length / this.ip + 1 | 0;
      /** @type {number} maximum number of huffman code. */

      var maxHuffCode;
      /** @type {number} new output buffer size. */

      var newSize;
      /** @type {number} max inflate size. */

      var maxInflateSize;
      var input = this.input;
      var output = this.output;

      if (opt_param) {
        if (typeof opt_param.fixRatio === 'number') {
          ratio = opt_param.fixRatio;
        }

        if (typeof opt_param.addRatio === 'number') {
          ratio += opt_param.addRatio;
        }
      } // calculate new buffer size


      if (ratio < 2) {
        maxHuffCode = (input.length - this.ip) / this.litlenTable[2];
        maxInflateSize = maxHuffCode / 2 * 258 | 0;
        newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
      } else {
        newSize = output.length * ratio;
      } // buffer expantion


      {
        buffer = new Uint8Array(newSize);
        buffer.set(output);
      }

      this.output = buffer;
      return this.output;
    };
    /**
     * concat output buffer. (dynamic)
     * @return {!(Array|Uint8Array)} output buffer.
     */


    Zlib$2.RawInflateStream.prototype.concatBuffer = function () {
      /** @type {!(Array|Uint8Array)} output buffer. */
      var buffer;
      /** @type {number} */

      var op = this.op;
      /** @type {Uint8Array} */

      var tmp;

      if (this.resize) {
        {
          buffer = new Uint8Array(this.output.subarray(this.sp, op));
        }
      } else {
        buffer = this.output.subarray(this.sp, op) ;
      }

      this.sp = op; // compaction

      if (op > Zlib$2.RawInflateStream.MaxBackwardLength + this.bufferSize) {
        this.op = this.sp = Zlib$2.RawInflateStream.MaxBackwardLength;

        {
          tmp =
          /** @type {Uint8Array} */
          this.output;
          this.output = new Uint8Array(this.bufferSize + Zlib$2.RawInflateStream.MaxBackwardLength);
          this.output.set(tmp.subarray(op - Zlib$2.RawInflateStream.MaxBackwardLength, op));
        }
      }

      return buffer;
    };
    /**
     * @constructor
     * @param {!(Uint8Array|Array)} input deflated buffer.
     * @param {Object=} opt_params option parameters.
     *
     * opt_params は以下のプロパティを指定する事ができます。
     *   - index: input buffer の deflate コンテナの開始位置.
     *   - blockSize: バッファのブロックサイズ.
     *   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
     *   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
     *       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
     */


    Zlib$2.Inflate = function (input, opt_params) {
      /** @type {number} */

      var cmf;
      /** @type {number} */

      var flg;
      /** @type {!(Uint8Array|Array)} */

      this.input = input;
      /** @type {number} */

      this.ip = 0;
      /** @type {Zlib.RawInflate} */

      this.rawinflate;
      /** @type {(boolean|undefined)} verify flag. */

      this.verify; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (opt_params['index']) {
          this.ip = opt_params['index'];
        }

        if (opt_params['verify']) {
          this.verify = opt_params['verify'];
        }
      } // Compression Method and Flags


      cmf = input[this.ip++];
      flg = input[this.ip++]; // compression method

      switch (cmf & 0x0f) {
        case Zlib$2.CompressionMethod.DEFLATE:
          this.method = Zlib$2.CompressionMethod.DEFLATE;
          break;

        default:
          throw new Error('unsupported compression method');
      } // fcheck


      if (((cmf << 8) + flg) % 31 !== 0) {
        throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
      } // fdict (not supported)


      if (flg & 0x20) {
        throw new Error('fdict flag is not supported');
      } // RawInflate


      this.rawinflate = new Zlib$2.RawInflate(input, {
        'index': this.ip,
        'bufferSize': opt_params['bufferSize'],
        'bufferType': opt_params['bufferType'],
        'resize': opt_params['resize']
      });
    };
    /**
     * @enum {number}
     */


    Zlib$2.Inflate.BufferType = Zlib$2.RawInflate.BufferType;
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */

    Zlib$2.Inflate.prototype.decompress = function () {
      /** @type {!(Array|Uint8Array)} input buffer. */
      var input = this.input;
      /** @type {!(Uint8Array|Array)} inflated buffer. */

      var buffer;
      /** @type {number} adler-32 checksum */

      var adler32;
      buffer = this.rawinflate.decompress();
      this.ip = this.rawinflate.ip; // verify adler-32

      if (this.verify) {
        adler32 = (input[this.ip++] << 24 | input[this.ip++] << 16 | input[this.ip++] << 8 | input[this.ip++]) >>> 0;

        if (adler32 !== Zlib$2.Adler32(buffer)) {
          throw new Error('invalid adler-32 checksum');
        }
      }

      return buffer;
    };
    /* vim:set expandtab ts=2 sw=2 tw=80: */

    /**
     * @param {!(Uint8Array|Array)} input deflated buffer.
     * @constructor
     */


    Zlib$2.InflateStream = function (input) {
      /** @type {!(Uint8Array|Array)} */
      this.input = input === void 0 ? new (Uint8Array )() : input;
      /** @type {number} */

      this.ip = 0;
      /** @type {Zlib.RawInflateStream} */

      this.rawinflate = new Zlib$2.RawInflateStream(this.input, this.ip);
      /** @type {Zlib.CompressionMethod} */

      this.method;
      /** @type {!(Array|Uint8Array)} */

      this.output = this.rawinflate.output;
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */


    Zlib$2.InflateStream.prototype.decompress = function (input) {
      /** @type {!(Uint8Array|Array)} inflated buffer. */
      var buffer;
      // XXX Array, Uint8Array のチェックを行うか確認する

      if (input !== void 0) {
        {
          var tmp = new Uint8Array(this.input.length + input.length);
          tmp.set(this.input, 0);
          tmp.set(input, this.input.length);
          this.input = tmp;
        }
      }

      if (this.method === void 0) {
        if (this.readHeader() < 0) {
          return new (Uint8Array )();
        }
      }

      buffer = this.rawinflate.decompress(this.input, this.ip);

      if (this.rawinflate.ip !== 0) {
        this.input = this.input.subarray(this.rawinflate.ip) ;
        this.ip = 0;
      } // verify adler-32

      /*
      if (this.verify) {
        adler32 =
          input[this.ip++] << 24 | input[this.ip++] << 16 |
          input[this.ip++] << 8 | input[this.ip++];
         if (adler32 !== Zlib.Adler32(buffer)) {
          throw new Error('invalid adler-32 checksum');
        }
      }
      */


      return buffer;
    };

    Zlib$2.InflateStream.prototype.readHeader = function () {
      var ip = this.ip;
      var input = this.input; // Compression Method and Flags

      var cmf = input[ip++];
      var flg = input[ip++];

      if (cmf === void 0 || flg === void 0) {
        return -1;
      } // compression method


      switch (cmf & 0x0f) {
        case Zlib$2.CompressionMethod.DEFLATE:
          this.method = Zlib$2.CompressionMethod.DEFLATE;
          break;

        default:
          throw new Error('unsupported compression method');
      } // fcheck


      if (((cmf << 8) + flg) % 31 !== 0) {
        throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
      } // fdict (not supported)


      if (flg & 0x20) {
        throw new Error('fdict flag is not supported');
      }

      this.ip = ip;
    };
    /**
     * @fileoverview GZIP (RFC1952) 展開コンテナ実装.
     */

    /**
     * @constructor
     * @param {!(Array|Uint8Array)} input input buffer.
     * @param {Object=} opt_params option parameters.
     */


    Zlib$2.Gunzip = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */
      this.input = input;
      /** @type {number} input buffer pointer. */

      this.ip = 0;
      /** @type {Array.<Zlib.GunzipMember>} */

      this.member = [];
      /** @type {boolean} */

      this.decompressed = false;
    };
    /**
     * @return {Array.<Zlib.GunzipMember>}
     */


    Zlib$2.Gunzip.prototype.getMembers = function () {
      if (!this.decompressed) {
        this.decompress();
      }

      return this.member.slice();
    };
    /**
     * inflate gzip data.
     * @return {!(Array.<number>|Uint8Array)} inflated buffer.
     */


    Zlib$2.Gunzip.prototype.decompress = function () {
      /** @type {number} input length. */
      var il = this.input.length;

      while (this.ip < il) {
        this.decodeMember();
      }

      this.decompressed = true;
      return this.concatMember();
    };
    /**
     * decode gzip member.
     */


    Zlib$2.Gunzip.prototype.decodeMember = function () {
      /** @type {Zlib.GunzipMember} */
      var member = new Zlib$2.GunzipMember();
      /** @type {number} */

      var isize;
      /** @type {Zlib.RawInflate} RawInflate implementation. */

      var rawinflate;
      /** @type {!(Array.<number>|Uint8Array)} inflated data. */

      var inflated;
      /** @type {number} inflate size */

      var inflen;
      /** @type {number} character code */

      var c;
      /** @type {number} character index in string. */

      var ci;
      /** @type {Array.<string>} character array. */

      var str;
      /** @type {number} modification time. */

      var mtime;
      /** @type {number} */

      var crc32;
      var input = this.input;
      var ip = this.ip;
      member.id1 = input[ip++];
      member.id2 = input[ip++]; // check signature

      if (member.id1 !== 0x1f || member.id2 !== 0x8b) {
        throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);
      } // check compression method


      member.cm = input[ip++];

      switch (member.cm) {
        case 8:
          /* XXX: use Zlib const */
          break;

        default:
          throw new Error('unknown compression method: ' + member.cm);
      } // flags


      member.flg = input[ip++]; // modification time

      mtime = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24;
      member.mtime = new Date(mtime * 1000); // extra flags

      member.xfl = input[ip++]; // operating system

      member.os = input[ip++]; // extra

      if ((member.flg & Zlib$2.Gzip.FlagsMask.FEXTRA) > 0) {
        member.xlen = input[ip++] | input[ip++] << 8;
        ip = this.decodeSubField(ip, member.xlen);
      } // fname


      if ((member.flg & Zlib$2.Gzip.FlagsMask.FNAME) > 0) {
        for (str = [], ci = 0; (c = input[ip++]) > 0;) {
          str[ci++] = String.fromCharCode(c);
        }

        member.name = str.join('');
      } // fcomment


      if ((member.flg & Zlib$2.Gzip.FlagsMask.FCOMMENT) > 0) {
        for (str = [], ci = 0; (c = input[ip++]) > 0;) {
          str[ci++] = String.fromCharCode(c);
        }

        member.comment = str.join('');
      } // fhcrc


      if ((member.flg & Zlib$2.Gzip.FlagsMask.FHCRC) > 0) {
        member.crc16 = Zlib$2.CRC32.calc(input, 0, ip) & 0xffff;

        if (member.crc16 !== (input[ip++] | input[ip++] << 8)) {
          throw new Error('invalid header crc16');
        }
      } // isize を事前に取得すると展開後のサイズが分かるため、
      // inflate処理のバッファサイズが事前に分かり、高速になる


      isize = input[input.length - 4] | input[input.length - 3] << 8 | input[input.length - 2] << 16 | input[input.length - 1] << 24; // isize の妥当性チェック
      // ハフマン符号では最小 2-bit のため、最大で 1/4 になる
      // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、
      // 1/128 になるとする
      // ここから入力バッファの残りが isize の 512 倍以上だったら
      // サイズ指定のバッファ確保は行わない事とする

      if (input.length - ip -
      /* CRC-32 */
      4 -
      /* ISIZE */
      4 < isize * 512) {
        inflen = isize;
      } // compressed block


      rawinflate = new Zlib$2.RawInflate(input, {
        'index': ip,
        'bufferSize': inflen
      });
      member.data = inflated = rawinflate.decompress();
      ip = rawinflate.ip; // crc32

      member.crc32 = crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;

      if (Zlib$2.CRC32.calc(inflated) !== crc32) {
        throw new Error('invalid CRC-32 checksum: 0x' + Zlib$2.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));
      } // input size


      member.isize = isize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;

      if ((inflated.length & 0xffffffff) !== isize) {
        throw new Error('invalid input size: ' + (inflated.length & 0xffffffff) + ' / ' + isize);
      }

      this.member.push(member);
      this.ip = ip;
    };
    /**
     * サブフィールドのデコード
     * XXX: 現在は何もせずスキップする
     */


    Zlib$2.Gunzip.prototype.decodeSubField = function (ip, length) {
      return ip + length;
    };
    /**
     * @return {!(Array.<number>|Uint8Array)}
     */


    Zlib$2.Gunzip.prototype.concatMember = function () {
      /** @type {Array.<Zlib.GunzipMember>} */
      var member = this.member;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {number} */

      var p = 0;
      /** @type {number} */

      var size = 0;
      /** @type {!(Array.<number>|Uint8Array)} */

      var buffer;

      for (i = 0, il = member.length; i < il; ++i) {
        size += member[i].data.length;
      }

      {
        buffer = new Uint8Array(size);

        for (i = 0; i < il; ++i) {
          buffer.set(member[i].data, p);
          p += member[i].data.length;
        }
      }

      return buffer;
    };
    /**
     * @constructor
     */


    Zlib$2.GunzipMember = function () {
      /** @type {number} signature first byte. */
      this.id1;
      /** @type {number} signature second byte. */

      this.id2;
      /** @type {number} compression method. */

      this.cm;
      /** @type {number} flags. */

      this.flg;
      /** @type {Date} modification time. */

      this.mtime;
      /** @type {number} extra flags. */

      this.xfl;
      /** @type {number} operating system number. */

      this.os;
      /** @type {number} CRC-16 value for FHCRC flag. */

      this.crc16;
      /** @type {number} extra length. */

      this.xlen;
      /** @type {number} CRC-32 value for verification. */

      this.crc32;
      /** @type {number} input size modulo 32 value. */

      this.isize;
      /** @type {string} filename. */

      this.name;
      /** @type {string} comment. */

      this.comment;
      /** @type {!(Uint8Array|Array.<number>)} */

      this.data;
    };

    Zlib$2.GunzipMember.prototype.getName = function () {
      return this.name;
    };

    Zlib$2.GunzipMember.prototype.getData = function () {
      return this.data;
    };

    Zlib$2.GunzipMember.prototype.getMtime = function () {
      return this.mtime;
    };
    /**
     * @fileoverview GZIP (RFC1952) 実装.
     */

    /**
     * @constructor
     * @param {!(Array|Uint8Array)} input input buffer.
     * @param {Object=} opt_params option parameters.
     */


    Zlib$2.Gzip = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */
      this.input = input;
      /** @type {number} input buffer pointer. */

      this.ip = 0;
      /** @type {!(Array.<number>|Uint8Array)} output buffer. */

      this.output;
      /** @type {number} output buffer. */

      this.op = 0;
      /** @type {!Object} flags option flags. */

      this.flags = {};
      /** @type {!string} filename. */

      this.filename;
      /** @type {!string} comment. */

      this.comment;
      /** @type {!Object} deflate options. */

      this.deflateOptions; // option parameters

      if (opt_params) {
        if (opt_params['flags']) {
          this.flags = opt_params['flags'];
        }

        if (typeof opt_params['filename'] === 'string') {
          this.filename = opt_params['filename'];
        }

        if (typeof opt_params['comment'] === 'string') {
          this.comment = opt_params['comment'];
        }

        if (opt_params['deflateOptions']) {
          this.deflateOptions = opt_params['deflateOptions'];
        }
      }

      if (!this.deflateOptions) {
        this.deflateOptions = {};
      }
    };
    /**
     * @type {number}
     * @const
     */


    Zlib$2.Gzip.DefaultBufferSize = 0x8000;
    /**
     * encode gzip members.
     * @return {!(Array|Uint8Array)} gzip binary array.
     */

    Zlib$2.Gzip.prototype.compress = function () {
      /** @type {number} flags. */
      var flg;
      /** @type {number} modification time. */

      var mtime;
      /** @type {number} CRC-16 value for FHCRC flag. */

      var crc16;
      /** @type {number} CRC-32 value for verification. */

      var crc32;
      /** @type {!Zlib.RawDeflate} raw deflate object. */

      var rawdeflate;
      /** @type {number} character code */

      var c;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limiter. */

      var il;
      /** @type {!(Array|Uint8Array)} output buffer. */

      var output = new (Uint8Array )(Zlib$2.Gzip.DefaultBufferSize);
      /** @type {number} output buffer pointer. */

      var op = 0;
      var input = this.input;
      var ip = this.ip;
      var filename = this.filename;
      var comment = this.comment; // check signature

      output[op++] = 0x1f;
      output[op++] = 0x8b; // check compression method

      output[op++] = 8;
      /* XXX: use Zlib const */
      // flags

      flg = 0;
      if (this.flags['fname']) flg |= Zlib$2.Gzip.FlagsMask.FNAME;
      if (this.flags['fcomment']) flg |= Zlib$2.Gzip.FlagsMask.FCOMMENT;
      if (this.flags['fhcrc']) flg |= Zlib$2.Gzip.FlagsMask.FHCRC; // XXX: FTEXT
      // XXX: FEXTRA

      output[op++] = flg; // modification time

      mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;
      output[op++] = mtime & 0xff;
      output[op++] = mtime >>> 8 & 0xff;
      output[op++] = mtime >>> 16 & 0xff;
      output[op++] = mtime >>> 24 & 0xff; // extra flags

      output[op++] = 0; // operating system

      output[op++] = Zlib$2.Gzip.OperatingSystem.UNKNOWN; // extra

      /* NOP */
      // fname

      if (this.flags['fname'] !== void 0) {
        for (i = 0, il = filename.length; i < il; ++i) {
          c = filename.charCodeAt(i);

          if (c > 0xff) {
            output[op++] = c >>> 8 & 0xff;
          }

          output[op++] = c & 0xff;
        }

        output[op++] = 0; // null termination
      } // fcomment


      if (this.flags['comment']) {
        for (i = 0, il = comment.length; i < il; ++i) {
          c = comment.charCodeAt(i);

          if (c > 0xff) {
            output[op++] = c >>> 8 & 0xff;
          }

          output[op++] = c & 0xff;
        }

        output[op++] = 0; // null termination
      } // fhcrc


      if (this.flags['fhcrc']) {
        crc16 = Zlib$2.CRC32.calc(output, 0, op) & 0xffff;
        output[op++] = crc16 & 0xff;
        output[op++] = crc16 >>> 8 & 0xff;
      } // add compress option


      this.deflateOptions['outputBuffer'] = output;
      this.deflateOptions['outputIndex'] = op; // compress

      rawdeflate = new Zlib$2.RawDeflate(input, this.deflateOptions);
      output = rawdeflate.compress();
      op = rawdeflate.op; // expand buffer

      {
        if (op + 8 > output.buffer.byteLength) {
          this.output = new Uint8Array(op + 8);
          this.output.set(new Uint8Array(output.buffer));
          output = this.output;
        } else {
          output = new Uint8Array(output.buffer);
        }
      } // crc32


      crc32 = Zlib$2.CRC32.calc(input);
      output[op++] = crc32 & 0xff;
      output[op++] = crc32 >>> 8 & 0xff;
      output[op++] = crc32 >>> 16 & 0xff;
      output[op++] = crc32 >>> 24 & 0xff; // input size

      il = input.length;
      output[op++] = il & 0xff;
      output[op++] = il >>> 8 & 0xff;
      output[op++] = il >>> 16 & 0xff;
      output[op++] = il >>> 24 & 0xff;
      this.ip = ip;

      if (op < output.length) {
        this.output = output = output.subarray(0, op);
      }

      return output;
    };
    /** @enum {number} */


    Zlib$2.Gzip.OperatingSystem = {
      FAT: 0,
      AMIGA: 1,
      VMS: 2,
      UNIX: 3,
      VM_CMS: 4,
      ATARI_TOS: 5,
      HPFS: 6,
      MACINTOSH: 7,
      Z_SYSTEM: 8,
      CP_M: 9,
      TOPS_20: 10,
      NTFS: 11,
      QDOS: 12,
      ACORN_RISCOS: 13,
      UNKNOWN: 255
    };
    /** @enum {number} */

    Zlib$2.Gzip.FlagsMask = {
      FTEXT: 0x01,
      FHCRC: 0x02,
      FEXTRA: 0x04,
      FNAME: 0x08,
      FCOMMENT: 0x10
    };
    /**
     * @fileoverview Heap Sort 実装. ハフマン符号化で使用する.
     */

    /**
     * カスタムハフマン符号で使用するヒープ実装
     * @param {number} length ヒープサイズ.
     * @constructor
     */

    Zlib$2.Heap = function (length) {
      this.buffer = new (Uint16Array )(length * 2);
      this.length = 0;
    };
    /**
     * 親ノードの index 取得
     * @param {number} index 子ノードの index.
     * @return {number} 親ノードの index.
     *
     */


    Zlib$2.Heap.prototype.getParent = function (index) {
      return ((index - 2) / 4 | 0) * 2;
    };
    /**
     * 子ノードの index 取得
     * @param {number} index 親ノードの index.
     * @return {number} 子ノードの index.
     */


    Zlib$2.Heap.prototype.getChild = function (index) {
      return 2 * index + 2;
    };
    /**
     * Heap に値を追加する
     * @param {number} index キー index.
     * @param {number} value 値.
     * @return {number} 現在のヒープ長.
     */


    Zlib$2.Heap.prototype.push = function (index, value) {
      var current,
          parent,
          heap = this.buffer,
          swap;
      current = this.length;
      heap[this.length++] = value;
      heap[this.length++] = index; // ルートノードにたどり着くまで入れ替えを試みる

      while (current > 0) {
        parent = this.getParent(current); // 親ノードと比較して親の方が小さければ入れ替える

        if (heap[current] > heap[parent]) {
          swap = heap[current];
          heap[current] = heap[parent];
          heap[parent] = swap;
          swap = heap[current + 1];
          heap[current + 1] = heap[parent + 1];
          heap[parent + 1] = swap;
          current = parent; // 入れ替えが必要なくなったらそこで抜ける
        } else {
          break;
        }
      }

      return this.length;
    };
    /**
     * Heapから一番大きい値を返す
     * @return {{index: number, value: number, length: number}} {index: キーindex,
     *     value: 値, length: ヒープ長} の Object.
     */


    Zlib$2.Heap.prototype.pop = function () {
      var index,
          value,
          heap = this.buffer,
          swap,
          current,
          parent;
      value = heap[0];
      index = heap[1]; // 後ろから値を取る

      this.length -= 2;
      heap[0] = heap[this.length];
      heap[1] = heap[this.length + 1];
      parent = 0; // ルートノードから下がっていく

      while (true) {
        current = this.getChild(parent); // 範囲チェック

        if (current >= this.length) {
          break;
        } // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択


        if (current + 2 < this.length && heap[current + 2] > heap[current]) {
          current += 2;
        } // 親ノードと比較して親の方が小さい場合は入れ替える


        if (heap[current] > heap[parent]) {
          swap = heap[parent];
          heap[parent] = heap[current];
          heap[current] = swap;
          swap = heap[parent + 1];
          heap[parent + 1] = heap[current + 1];
          heap[current + 1] = swap;
        } else {
          break;
        }

        parent = current;
      }

      return {
        index: index,
        value: value,
        length: this.length
      };
    };
    /* vim:set expandtab ts=2 sw=2 tw=80: */

    /**
     * @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.
     */

    /**
     * Raw Deflate 実装
     *
     * @constructor
     * @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.
     * @param {Object=} opt_params option parameters.
     *
     * typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に
     * 変換されます.
     * 別のオブジェクトになるため出力バッファを参照している変数などは
     * 更新する必要があります.
     */


    Zlib$2.RawDeflate = function (input, opt_params) {
      /** @type {Zlib.RawDeflate.CompressionType} */
      this.compressionType = Zlib$2.RawDeflate.CompressionType.DYNAMIC;
      /** @type {number} */

      this.lazy = 0;
      /** @type {!(Array.<number>|Uint32Array)} */

      this.freqsLitLen;
      /** @type {!(Array.<number>|Uint32Array)} */

      this.freqsDist;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.input = input instanceof Array ? new Uint8Array(input) : input;
      /** @type {!(Array.<number>|Uint8Array)} output output buffer. */

      this.output;
      /** @type {number} pos output buffer position. */

      this.op = 0; // option parameters

      if (opt_params) {
        if (opt_params['lazy']) {
          this.lazy = opt_params['lazy'];
        }

        if (typeof opt_params['compressionType'] === 'number') {
          this.compressionType = opt_params['compressionType'];
        }

        if (opt_params['outputBuffer']) {
          this.output = opt_params['outputBuffer'] instanceof Array ? new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];
        }

        if (typeof opt_params['outputIndex'] === 'number') {
          this.op = opt_params['outputIndex'];
        }
      }

      if (!this.output) {
        this.output = new (Uint8Array )(0x8000);
      }
    };
    /**
     * @enum {number}
     */


    Zlib$2.RawDeflate.CompressionType = {
      NONE: 0,
      FIXED: 1,
      DYNAMIC: 2,
      RESERVED: 3
    };
    /**
     * LZ77 の最小マッチ長
     * @const
     * @type {number}
     */

    Zlib$2.RawDeflate.Lz77MinLength = 3;
    /**
     * LZ77 の最大マッチ長
     * @const
     * @type {number}
     */

    Zlib$2.RawDeflate.Lz77MaxLength = 258;
    /**
     * LZ77 のウィンドウサイズ
     * @const
     * @type {number}
     */

    Zlib$2.RawDeflate.WindowSize = 0x8000;
    /**
     * 最長の符号長
     * @const
     * @type {number}
     */

    Zlib$2.RawDeflate.MaxCodeLength = 16;
    /**
     * ハフマン符号の最大数値
     * @const
     * @type {number}
     */

    Zlib$2.RawDeflate.HUFMAX = 286;
    /**
     * 固定ハフマン符号の符号化テーブル
     * @const
     * @type {Array.<Array.<number, number>>}
     */

    Zlib$2.RawDeflate.FixedHuffmanTable = function () {
      var table = [],
          i;

      for (i = 0; i < 288; i++) {
        switch (true) {
          case i <= 143:
            table.push([i + 0x030, 8]);
            break;

          case i <= 255:
            table.push([i - 144 + 0x190, 9]);
            break;

          case i <= 279:
            table.push([i - 256 + 0x000, 7]);
            break;

          case i <= 287:
            table.push([i - 280 + 0x0C0, 8]);
            break;

          default:
            throw 'invalid literal: ' + i;
        }
      }

      return table;
    }();
    /**
     * DEFLATE ブロックの作成
     * @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.
     */


    Zlib$2.RawDeflate.prototype.compress = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var blockArray;
      /** @type {number} */

      var position;
      /** @type {number} */

      var length;
      var input = this.input; // compression

      switch (this.compressionType) {
        case Zlib$2.RawDeflate.CompressionType.NONE:
          // each 65535-Byte (length header: 16-bit)
          for (position = 0, length = input.length; position < length;) {
            blockArray = input.subarray(position, position + 0xffff) ;
            position += blockArray.length;
            this.makeNocompressBlock(blockArray, position === length);
          }

          break;

        case Zlib$2.RawDeflate.CompressionType.FIXED:
          this.output = this.makeFixedHuffmanBlock(input, true);
          this.op = this.output.length;
          break;

        case Zlib$2.RawDeflate.CompressionType.DYNAMIC:
          this.output = this.makeDynamicHuffmanBlock(input, true);
          this.op = this.output.length;
          break;

        default:
          throw 'invalid compression type';
      }

      return this.output;
    };
    /**
     * 非圧縮ブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.
     */


    Zlib$2.RawDeflate.prototype.makeNocompressBlock = function (blockArray, isFinalBlock) {
      /** @type {number} */
      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {number} */

      var len;
      /** @type {number} */

      var nlen;
      var output = this.output;
      var op = this.op; // expand buffer

      {
        output = new Uint8Array(this.output.buffer);

        while (output.length <= op + blockArray.length + 5) {
          output = new Uint8Array(output.length << 1);
        }

        output.set(this.output);
      } // header


      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib$2.RawDeflate.CompressionType.NONE;
      output[op++] = bfinal | btype << 1; // length

      len = blockArray.length;
      nlen = ~len + 0x10000 & 0xffff;
      output[op++] = len & 0xff;
      output[op++] = len >>> 8 & 0xff;
      output[op++] = nlen & 0xff;
      output[op++] = nlen >>> 8 & 0xff; // copy buffer

      {
        output.set(blockArray, op);
        op += blockArray.length;
        output = output.subarray(0, op);
      }

      this.op = op;
      this.output = output;
      return output;
    };
    /**
     * 固定ハフマンブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.
     */


    Zlib$2.RawDeflate.prototype.makeFixedHuffmanBlock = function (blockArray, isFinalBlock) {
      /** @type {Zlib.BitStream} */
      var stream = new Zlib$2.BitStream(new Uint8Array(this.output.buffer) , this.op);
      /** @type {number} */

      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {!(Array.<number>|Uint16Array)} */

      var data; // header

      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib$2.RawDeflate.CompressionType.FIXED;
      stream.writeBits(bfinal, 1, true);
      stream.writeBits(btype, 2, true);
      data = this.lz77(blockArray);
      this.fixedHuffman(data, stream);
      return stream.finish();
    };
    /**
     * 動的ハフマンブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.
     */


    Zlib$2.RawDeflate.prototype.makeDynamicHuffmanBlock = function (blockArray, isFinalBlock) {
      /** @type {Zlib.BitStream} */
      var stream = new Zlib$2.BitStream(new Uint8Array(this.output.buffer) , this.op);
      /** @type {number} */

      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {!(Array.<number>|Uint16Array)} */

      var data;
      /** @type {number} */

      var hlit;
      /** @type {number} */

      var hdist;
      /** @type {number} */

      var hclen;
      /** @const @type {Array.<number>} */

      var hclenOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      /** @type {!(Array.<number>|Uint8Array)} */

      var litLenLengths;
      /** @type {!(Array.<number>|Uint16Array)} */

      var litLenCodes;
      /** @type {!(Array.<number>|Uint8Array)} */

      var distLengths;
      /** @type {!(Array.<number>|Uint16Array)} */

      var distCodes;
      /** @type {{
       *   codes: !(Array.<number>|Uint32Array),
       *   freqs: !(Array.<number>|Uint8Array)
       * }} */

      var treeSymbols;
      /** @type {!(Array.<number>|Uint8Array)} */

      var treeLengths;
      /** @type {Array} */

      var transLengths = new Array(19);
      /** @type {!(Array.<number>|Uint16Array)} */

      var treeCodes;
      /** @type {number} */

      var code;
      /** @type {number} */

      var bitlen;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il; // header

      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib$2.RawDeflate.CompressionType.DYNAMIC;
      stream.writeBits(bfinal, 1, true);
      stream.writeBits(btype, 2, true);
      data = this.lz77(blockArray); // リテラル・長さ, 距離のハフマン符号と符号長の算出

      litLenLengths = this.getLengths_(this.freqsLitLen, 15);
      litLenCodes = this.getCodesFromLengths_(litLenLengths);
      distLengths = this.getLengths_(this.freqsDist, 7);
      distCodes = this.getCodesFromLengths_(distLengths); // HLIT, HDIST の決定

      for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}

      for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {} // HCLEN


      treeSymbols = this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
      treeLengths = this.getLengths_(treeSymbols.freqs, 7);

      for (i = 0; i < 19; i++) {
        transLengths[i] = treeLengths[hclenOrder[i]];
      }

      for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}

      treeCodes = this.getCodesFromLengths_(treeLengths); // 出力

      stream.writeBits(hlit - 257, 5, true);
      stream.writeBits(hdist - 1, 5, true);
      stream.writeBits(hclen - 4, 4, true);

      for (i = 0; i < hclen; i++) {
        stream.writeBits(transLengths[i], 3, true);
      } // ツリーの出力


      for (i = 0, il = treeSymbols.codes.length; i < il; i++) {
        code = treeSymbols.codes[i];
        stream.writeBits(treeCodes[code], treeLengths[code], true); // extra bits

        if (code >= 16) {
          i++;

          switch (code) {
            case 16:
              bitlen = 2;
              break;

            case 17:
              bitlen = 3;
              break;

            case 18:
              bitlen = 7;
              break;

            default:
              throw 'invalid code: ' + code;
          }

          stream.writeBits(treeSymbols.codes[i], bitlen, true);
        }
      }

      this.dynamicHuffman(data, [litLenCodes, litLenLengths], [distCodes, distLengths], stream);
      return stream.finish();
    };
    /**
     * 動的ハフマン符号化(カスタムハフマンテーブル)
     * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
     * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
     * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
     */


    Zlib$2.RawDeflate.prototype.dynamicHuffman = function (dataArray, litLen, dist, stream) {
      /** @type {number} */
      var index;
      /** @type {number} */

      var length;
      /** @type {number} */

      var literal;
      /** @type {number} */

      var code;
      /** @type {number} */

      var litLenCodes;
      /** @type {number} */

      var litLenLengths;
      /** @type {number} */

      var distCodes;
      /** @type {number} */

      var distLengths;
      litLenCodes = litLen[0];
      litLenLengths = litLen[1];
      distCodes = dist[0];
      distLengths = dist[1]; // 符号を BitStream に書き込んでいく

      for (index = 0, length = dataArray.length; index < length; ++index) {
        literal = dataArray[index]; // literal or length

        stream.writeBits(litLenCodes[literal], litLenLengths[literal], true); // 長さ・距離符号

        if (literal > 256) {
          // length extra
          stream.writeBits(dataArray[++index], dataArray[++index], true); // distance

          code = dataArray[++index];
          stream.writeBits(distCodes[code], distLengths[code], true); // distance extra

          stream.writeBits(dataArray[++index], dataArray[++index], true); // 終端
        } else if (literal === 256) {
          break;
        }
      }

      return stream;
    };
    /**
     * 固定ハフマン符号化
     * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
     * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
     * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
     */


    Zlib$2.RawDeflate.prototype.fixedHuffman = function (dataArray, stream) {
      /** @type {number} */
      var index;
      /** @type {number} */

      var length;
      /** @type {number} */

      var literal; // 符号を BitStream に書き込んでいく

      for (index = 0, length = dataArray.length; index < length; index++) {
        literal = dataArray[index]; // 符号の書き込み

        Zlib$2.BitStream.prototype.writeBits.apply(stream, Zlib$2.RawDeflate.FixedHuffmanTable[literal]); // 長さ・距離符号

        if (literal > 0x100) {
          // length extra
          stream.writeBits(dataArray[++index], dataArray[++index], true); // distance

          stream.writeBits(dataArray[++index], 5); // distance extra

          stream.writeBits(dataArray[++index], dataArray[++index], true); // 終端
        } else if (literal === 0x100) {
          break;
        }
      }

      return stream;
    };
    /**
     * マッチ情報
     * @param {!number} length マッチした長さ.
     * @param {!number} backwardDistance マッチ位置との距離.
     * @constructor
     */


    Zlib$2.RawDeflate.Lz77Match = function (length, backwardDistance) {
      /** @type {number} match length. */
      this.length = length;
      /** @type {number} backward distance. */

      this.backwardDistance = backwardDistance;
    };
    /**
     * 長さ符号テーブル.
     * [コード, 拡張ビット, 拡張ビット長] の配列となっている.
     * @const
     * @type {!(Array.<number>|Uint32Array)}
     */


    Zlib$2.RawDeflate.Lz77Match.LengthCodeTable = function (table) {
      return new Uint32Array(table) ;
    }(function () {
      /** @type {!Array} */
      var table = [];
      /** @type {number} */

      var i;
      /** @type {!Array.<number>} */

      var c;

      for (i = 3; i <= 258; i++) {
        c = code(i);
        table[i] = c[2] << 24 | c[1] << 16 | c[0];
      }
      /**
       * @param {number} length lz77 length.
       * @return {!Array.<number>} lz77 codes.
       */


      function code(length) {
        switch (true) {
          case length === 3:
            return [257, length - 3, 0];

          case length === 4:
            return [258, length - 4, 0];

          case length === 5:
            return [259, length - 5, 0];

          case length === 6:
            return [260, length - 6, 0];

          case length === 7:
            return [261, length - 7, 0];

          case length === 8:
            return [262, length - 8, 0];

          case length === 9:
            return [263, length - 9, 0];

          case length === 10:
            return [264, length - 10, 0];

          case length <= 12:
            return [265, length - 11, 1];

          case length <= 14:
            return [266, length - 13, 1];

          case length <= 16:
            return [267, length - 15, 1];

          case length <= 18:
            return [268, length - 17, 1];

          case length <= 22:
            return [269, length - 19, 2];

          case length <= 26:
            return [270, length - 23, 2];

          case length <= 30:
            return [271, length - 27, 2];

          case length <= 34:
            return [272, length - 31, 2];

          case length <= 42:
            return [273, length - 35, 3];

          case length <= 50:
            return [274, length - 43, 3];

          case length <= 58:
            return [275, length - 51, 3];

          case length <= 66:
            return [276, length - 59, 3];

          case length <= 82:
            return [277, length - 67, 4];

          case length <= 98:
            return [278, length - 83, 4];

          case length <= 114:
            return [279, length - 99, 4];

          case length <= 130:
            return [280, length - 115, 4];

          case length <= 162:
            return [281, length - 131, 5];

          case length <= 194:
            return [282, length - 163, 5];

          case length <= 226:
            return [283, length - 195, 5];

          case length <= 257:
            return [284, length - 227, 5];

          case length === 258:
            return [285, length - 258, 0];

          default:
            throw 'invalid length: ' + length;
        }
      }

      return table;
    }());
    /**
     * 距離符号テーブル
     * @param {!number} dist 距離.
     * @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.
     * @private
     */


    Zlib$2.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function (dist) {
      /** @type {!Array.<number>} distance code table. */
      var r;

      switch (true) {
        case dist === 1:
          r = [0, dist - 1, 0];
          break;

        case dist === 2:
          r = [1, dist - 2, 0];
          break;

        case dist === 3:
          r = [2, dist - 3, 0];
          break;

        case dist === 4:
          r = [3, dist - 4, 0];
          break;

        case dist <= 6:
          r = [4, dist - 5, 1];
          break;

        case dist <= 8:
          r = [5, dist - 7, 1];
          break;

        case dist <= 12:
          r = [6, dist - 9, 2];
          break;

        case dist <= 16:
          r = [7, dist - 13, 2];
          break;

        case dist <= 24:
          r = [8, dist - 17, 3];
          break;

        case dist <= 32:
          r = [9, dist - 25, 3];
          break;

        case dist <= 48:
          r = [10, dist - 33, 4];
          break;

        case dist <= 64:
          r = [11, dist - 49, 4];
          break;

        case dist <= 96:
          r = [12, dist - 65, 5];
          break;

        case dist <= 128:
          r = [13, dist - 97, 5];
          break;

        case dist <= 192:
          r = [14, dist - 129, 6];
          break;

        case dist <= 256:
          r = [15, dist - 193, 6];
          break;

        case dist <= 384:
          r = [16, dist - 257, 7];
          break;

        case dist <= 512:
          r = [17, dist - 385, 7];
          break;

        case dist <= 768:
          r = [18, dist - 513, 8];
          break;

        case dist <= 1024:
          r = [19, dist - 769, 8];
          break;

        case dist <= 1536:
          r = [20, dist - 1025, 9];
          break;

        case dist <= 2048:
          r = [21, dist - 1537, 9];
          break;

        case dist <= 3072:
          r = [22, dist - 2049, 10];
          break;

        case dist <= 4096:
          r = [23, dist - 3073, 10];
          break;

        case dist <= 6144:
          r = [24, dist - 4097, 11];
          break;

        case dist <= 8192:
          r = [25, dist - 6145, 11];
          break;

        case dist <= 12288:
          r = [26, dist - 8193, 12];
          break;

        case dist <= 16384:
          r = [27, dist - 12289, 12];
          break;

        case dist <= 24576:
          r = [28, dist - 16385, 13];
          break;

        case dist <= 32768:
          r = [29, dist - 24577, 13];
          break;

        default:
          throw 'invalid distance';
      }

      return r;
    };
    /**
     * マッチ情報を LZ77 符号化配列で返す.
     * なお、ここでは以下の内部仕様で符号化している
     * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]
     * @return {!Array.<number>} LZ77 符号化 byte array.
     */


    Zlib$2.RawDeflate.Lz77Match.prototype.toLz77Array = function () {
      /** @type {number} */
      var length = this.length;
      /** @type {number} */

      var dist = this.backwardDistance;
      /** @type {Array} */

      var codeArray = [];
      /** @type {number} */

      var pos = 0;
      /** @type {!Array.<number>} */

      var code; // length

      code = Zlib$2.RawDeflate.Lz77Match.LengthCodeTable[length];
      codeArray[pos++] = code & 0xffff;
      codeArray[pos++] = code >> 16 & 0xff;
      codeArray[pos++] = code >> 24; // distance

      code = this.getDistanceCode_(dist);
      codeArray[pos++] = code[0];
      codeArray[pos++] = code[1];
      codeArray[pos++] = code[2];
      return codeArray;
    };
    /**
     * LZ77 実装
     * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.
     * @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.
     */


    Zlib$2.RawDeflate.prototype.lz77 = function (dataArray) {
      /** @type {number} input position */
      var position;
      /** @type {number} input length */

      var length;
      /** @type {number} loop counter */

      var i;
      /** @type {number} loop limiter */

      var il;
      /** @type {number} chained-hash-table key */

      var matchKey;
      /** @type {Object.<number, Array.<number>>} chained-hash-table */

      var table = {};
      /** @const @type {number} */

      var windowSize = Zlib$2.RawDeflate.WindowSize;
      /** @type {Array.<number>} match list */

      var matchList;
      /** @type {Zlib.RawDeflate.Lz77Match} longest match */

      var longestMatch;
      /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */

      var prevMatch;
      /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */

      var lz77buf = new Uint16Array(dataArray.length * 2) ;
      /** @type {number} lz77 output buffer pointer */

      var pos = 0;
      /** @type {number} lz77 skip length */

      var skipLength = 0;
      /** @type {!(Array.<number>|Uint32Array)} */

      var freqsLitLen = new (Uint32Array )(286);
      /** @type {!(Array.<number>|Uint32Array)} */

      var freqsDist = new (Uint32Array )(30);
      /** @type {number} */

      var lazy = this.lazy;
      /** @type {*} temporary variable */

      var tmp; // 初期化

      freqsLitLen[256] = 1; // EOB の最低出現回数は 1

      /**
       * マッチデータの書き込み
       * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.
       * @param {!number} offset スキップ開始位置(相対指定).
       * @private
       */

      function writeMatch(match, offset) {
        /** @type {Array.<number>} */
        var lz77Array = match.toLz77Array();
        /** @type {number} */

        var i;
        /** @type {number} */

        var il;

        for (i = 0, il = lz77Array.length; i < il; ++i) {
          lz77buf[pos++] = lz77Array[i];
        }

        freqsLitLen[lz77Array[0]]++;
        freqsDist[lz77Array[3]]++;
        skipLength = match.length + offset - 1;
        prevMatch = null;
      } // LZ77 符号化


      for (position = 0, length = dataArray.length; position < length; ++position) {
        // ハッシュキーの作成
        for (matchKey = 0, i = 0, il = Zlib$2.RawDeflate.Lz77MinLength; i < il; ++i) {
          if (position + i === length) {
            break;
          }

          matchKey = matchKey << 8 | dataArray[position + i];
        } // テーブルが未定義だったら作成する


        if (table[matchKey] === void 0) {
          table[matchKey] = [];
        }

        matchList = table[matchKey]; // skip

        if (skipLength-- > 0) {
          matchList.push(position);
          continue;
        } // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)


        while (matchList.length > 0 && position - matchList[0] > windowSize) {
          matchList.shift();
        } // データ末尾でマッチしようがない場合はそのまま流しこむ


        if (position + Zlib$2.RawDeflate.Lz77MinLength >= length) {
          if (prevMatch) {
            writeMatch(prevMatch, -1);
          }

          for (i = 0, il = length - position; i < il; ++i) {
            tmp = dataArray[position + i];
            lz77buf[pos++] = tmp;
            ++freqsLitLen[tmp];
          }

          break;
        } // マッチ候補から最長のものを探す


        if (matchList.length > 0) {
          longestMatch = this.searchLongestMatch_(dataArray, position, matchList);

          if (prevMatch) {
            // 現在のマッチの方が前回のマッチよりも長い
            if (prevMatch.length < longestMatch.length) {
              // write previous literal
              tmp = dataArray[position - 1];
              lz77buf[pos++] = tmp;
              ++freqsLitLen[tmp]; // write current match

              writeMatch(longestMatch, 0);
            } else {
              // write previous match
              writeMatch(prevMatch, -1);
            }
          } else if (longestMatch.length < lazy) {
            prevMatch = longestMatch;
          } else {
            writeMatch(longestMatch, 0);
          } // 前回マッチしていて今回マッチがなかったら前回のを採用

        } else if (prevMatch) {
          writeMatch(prevMatch, -1);
        } else {
          tmp = dataArray[position];
          lz77buf[pos++] = tmp;
          ++freqsLitLen[tmp];
        }

        matchList.push(position); // マッチテーブルに現在の位置を保存
      } // 終端処理


      lz77buf[pos++] = 256;
      freqsLitLen[256]++;
      this.freqsLitLen = freqsLitLen;
      this.freqsDist = freqsDist;
      return (
        /** @type {!(Uint16Array|Array.<number>)} */
        lz77buf.subarray(0, pos) 
      );
    };
    /**
     * マッチした候補の中から最長一致を探す
     * @param {!Object} data plain data byte array.
     * @param {!number} position plain data byte array position.
     * @param {!Array.<number>} matchList 候補となる位置の配列.
     * @return {!Zlib.RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.
     * @private
     */


    Zlib$2.RawDeflate.prototype.searchLongestMatch_ = function (data, position, matchList) {
      var match,
          currentMatch,
          matchMax = 0,
          matchLength,
          i,
          j,
          l,
          dl = data.length; // 候補を後ろから 1 つずつ絞り込んでゆく

      permatch: for (i = 0, l = matchList.length; i < l; i++) {
        match = matchList[l - i - 1];
        matchLength = Zlib$2.RawDeflate.Lz77MinLength; // 前回までの最長一致を末尾から一致検索する

        if (matchMax > Zlib$2.RawDeflate.Lz77MinLength) {
          for (j = matchMax; j > Zlib$2.RawDeflate.Lz77MinLength; j--) {
            if (data[match + j - 1] !== data[position + j - 1]) {
              continue permatch;
            }
          }

          matchLength = matchMax;
        } // 最長一致探索


        while (matchLength < Zlib$2.RawDeflate.Lz77MaxLength && position + matchLength < dl && data[match + matchLength] === data[position + matchLength]) {
          ++matchLength;
        } // マッチ長が同じ場合は後方を優先


        if (matchLength > matchMax) {
          currentMatch = match;
          matchMax = matchLength;
        } // 最長が確定したら後の処理は省略


        if (matchLength === Zlib$2.RawDeflate.Lz77MaxLength) {
          break;
        }
      }

      return new Zlib$2.RawDeflate.Lz77Match(matchMax, position - currentMatch);
    };
    /**
     * Tree-Transmit Symbols の算出
     * reference: PuTTY Deflate implementation
     * @param {number} hlit HLIT.
     * @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.
     * @param {number} hdist HDIST.
     * @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.
     * @return {{
     *   codes: !(Array.<number>|Uint32Array),
     *   freqs: !(Array.<number>|Uint8Array)
     * }} Tree-Transmit Symbols.
     */


    Zlib$2.RawDeflate.prototype.getTreeSymbols_ = function (hlit, litlenLengths, hdist, distLengths) {
      var src = new (Uint32Array )(hlit + hdist),
          i,
          j,
          runLength,
          l,
          result = new (Uint32Array )(286 + 30),
          nResult,
          rpt,
          freqs = new (Uint8Array )(19);
      j = 0;

      for (i = 0; i < hlit; i++) {
        src[j++] = litlenLengths[i];
      }

      for (i = 0; i < hdist; i++) {
        src[j++] = distLengths[i];
      } // 初期化


      nResult = 0;

      for (i = 0, l = src.length; i < l; i += j) {
        // Run Length Encoding
        for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}

        runLength = j;

        if (src[i] === 0) {
          // 0 の繰り返しが 3 回未満ならばそのまま
          if (runLength < 3) {
            while (runLength-- > 0) {
              result[nResult++] = 0;
              freqs[0]++;
            }
          } else {
            while (runLength > 0) {
              // 繰り返しは最大 138 までなので切り詰める
              rpt = runLength < 138 ? runLength : 138;

              if (rpt > runLength - 3 && rpt < runLength) {
                rpt = runLength - 3;
              } // 3-10 回 -> 17


              if (rpt <= 10) {
                result[nResult++] = 17;
                result[nResult++] = rpt - 3;
                freqs[17]++; // 11-138 回 -> 18
              } else {
                result[nResult++] = 18;
                result[nResult++] = rpt - 11;
                freqs[18]++;
              }

              runLength -= rpt;
            }
          }
        } else {
          result[nResult++] = src[i];
          freqs[src[i]]++;
          runLength--; // 繰り返し回数が3回未満ならばランレングス符号は要らない

          if (runLength < 3) {
            while (runLength-- > 0) {
              result[nResult++] = src[i];
              freqs[src[i]]++;
            } // 3 回以上ならばランレングス符号化

          } else {
            while (runLength > 0) {
              // runLengthを 3-6 で分割
              rpt = runLength < 6 ? runLength : 6;

              if (rpt > runLength - 3 && rpt < runLength) {
                rpt = runLength - 3;
              }

              result[nResult++] = 16;
              result[nResult++] = rpt - 3;
              freqs[16]++;
              runLength -= rpt;
            }
          }
        }
      }

      return {
        codes: result.subarray(0, nResult) ,
        freqs: freqs
      };
    };
    /**
     * ハフマン符号の長さを取得する
     * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.
     * @param {number} limit 符号長の制限.
     * @return {!(Array.<number>|Uint8Array)} 符号長配列.
     * @private
     */


    Zlib$2.RawDeflate.prototype.getLengths_ = function (freqs, limit) {
      /** @type {number} */
      var nSymbols = freqs.length;
      /** @type {Zlib.Heap} */

      var heap = new Zlib$2.Heap(2 * Zlib$2.RawDeflate.HUFMAX);
      /** @type {!(Array.<number>|Uint8Array)} */

      var length = new (Uint8Array )(nSymbols);
      /** @type {Array} */

      var nodes;
      /** @type {!(Array.<number>|Uint32Array)} */

      var values;
      /** @type {!(Array.<number>|Uint8Array)} */

      var codeLength;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il; // 配列の初期化


      for (i = 0; i < nSymbols; ++i) {
        if (freqs[i] > 0) {
          heap.push(i, freqs[i]);
        }
      }

      nodes = new Array(heap.length / 2);
      values = new (Uint32Array )(heap.length / 2); // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了

      if (nodes.length === 1) {
        length[heap.pop().index] = 1;
        return length;
      } // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定


      for (i = 0, il = heap.length / 2; i < il; ++i) {
        nodes[i] = heap.pop();
        values[i] = nodes[i].value;
      }

      codeLength = this.reversePackageMerge_(values, values.length, limit);

      for (i = 0, il = nodes.length; i < il; ++i) {
        length[nodes[i].index] = codeLength[i];
      }

      return length;
    };
    /**
     * Reverse Package Merge Algorithm.
     * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.
     * @param {number} symbols number of symbols.
     * @param {number} limit code length limit.
     * @return {!(Array.<number>|Uint8Array)} code lengths.
     */


    Zlib$2.RawDeflate.prototype.reversePackageMerge_ = function (freqs, symbols, limit) {
      /** @type {!(Array.<number>|Uint16Array)} */
      var minimumCost = new (Uint16Array )(limit);
      /** @type {!(Array.<number>|Uint8Array)} */

      var flag = new (Uint8Array )(limit);
      /** @type {!(Array.<number>|Uint8Array)} */

      var codeLength = new (Uint8Array )(symbols);
      /** @type {Array} */

      var value = new Array(limit);
      /** @type {Array} */

      var type = new Array(limit);
      /** @type {Array.<number>} */

      var currentPosition = new Array(limit);
      /** @type {number} */

      var excess = (1 << limit) - symbols;
      /** @type {number} */

      var half = 1 << limit - 1;
      /** @type {number} */

      var i;
      /** @type {number} */

      var j;
      /** @type {number} */

      var t;
      /** @type {number} */

      var weight;
      /** @type {number} */

      var next;
      /**
       * @param {number} j
       */

      function takePackage(j) {
        /** @type {number} */
        var x = type[j][currentPosition[j]];

        if (x === symbols) {
          takePackage(j + 1);
          takePackage(j + 1);
        } else {
          --codeLength[x];
        }

        ++currentPosition[j];
      }

      minimumCost[limit - 1] = symbols;

      for (j = 0; j < limit; ++j) {
        if (excess < half) {
          flag[j] = 0;
        } else {
          flag[j] = 1;
          excess -= half;
        }

        excess <<= 1;
        minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols;
      }

      minimumCost[0] = flag[0];
      value[0] = new Array(minimumCost[0]);
      type[0] = new Array(minimumCost[0]);

      for (j = 1; j < limit; ++j) {
        if (minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {
          minimumCost[j] = 2 * minimumCost[j - 1] + flag[j];
        }

        value[j] = new Array(minimumCost[j]);
        type[j] = new Array(minimumCost[j]);
      }

      for (i = 0; i < symbols; ++i) {
        codeLength[i] = limit;
      }

      for (t = 0; t < minimumCost[limit - 1]; ++t) {
        value[limit - 1][t] = freqs[t];
        type[limit - 1][t] = t;
      }

      for (i = 0; i < limit; ++i) {
        currentPosition[i] = 0;
      }

      if (flag[limit - 1] === 1) {
        --codeLength[0];
        ++currentPosition[limit - 1];
      }

      for (j = limit - 2; j >= 0; --j) {
        i = 0;
        weight = 0;
        next = currentPosition[j + 1];

        for (t = 0; t < minimumCost[j]; t++) {
          weight = value[j + 1][next] + value[j + 1][next + 1];

          if (weight > freqs[i]) {
            value[j][t] = weight;
            type[j][t] = symbols;
            next += 2;
          } else {
            value[j][t] = freqs[i];
            type[j][t] = i;
            ++i;
          }
        }

        currentPosition[j] = 0;

        if (flag[j] === 1) {
          takePackage(j);
        }
      }

      return codeLength;
    };
    /**
     * 符号長配列からハフマン符号を取得する
     * reference: PuTTY Deflate implementation
     * @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.
     * @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.
     * @private
     */


    Zlib$2.RawDeflate.prototype.getCodesFromLengths_ = function (lengths) {
      var codes = new (Uint16Array )(lengths.length),
          count = [],
          startCode = [],
          code = 0,
          i,
          il,
          j,
          m; // Count the codes of each length.

      for (i = 0, il = lengths.length; i < il; i++) {
        count[lengths[i]] = (count[lengths[i]] | 0) + 1;
      } // Determine the starting code for each length block.


      for (i = 1, il = Zlib$2.RawDeflate.MaxCodeLength; i <= il; i++) {
        startCode[i] = code;
        code += count[i] | 0;
        code <<= 1;
      } // Determine the code for each symbol. Mirrored, of course.


      for (i = 0, il = lengths.length; i < il; i++) {
        code = startCode[lengths[i]];
        startCode[lengths[i]] += 1;
        codes[i] = 0;

        for (j = 0, m = lengths[i]; j < m; j++) {
          codes[i] = codes[i] << 1 | code & 1;
          code >>>= 1;
        }
      }

      return codes;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {Object=} opt_params options.
     * @constructor
     */


    Zlib$2.Unzip = function (input, opt_params) {
      opt_params = opt_params || {};
      /** @type {!(Array.<number>|Uint8Array)} */

      this.input = input instanceof Array ? new Uint8Array(input) : input;
      /** @type {number} */

      this.ip = 0;
      /** @type {number} */

      this.eocdrOffset;
      /** @type {number} */

      this.numberOfThisDisk;
      /** @type {number} */

      this.startDisk;
      /** @type {number} */

      this.totalEntriesThisDisk;
      /** @type {number} */

      this.totalEntries;
      /** @type {number} */

      this.centralDirectorySize;
      /** @type {number} */

      this.centralDirectoryOffset;
      /** @type {number} */

      this.commentLength;
      /** @type {(Array.<number>|Uint8Array)} */

      this.comment;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      this.fileHeaderList;
      /** @type {Object.<string, number>} */

      this.filenameToIndex;
      /** @type {boolean} */

      this.verify = opt_params['verify'] || false;
      /** @type {(Array.<number>|Uint8Array)} */

      this.password = opt_params['password'];
    };

    Zlib$2.Unzip.CompressionMethod = Zlib$2.Zip.CompressionMethod;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$2.Unzip.FileHeaderSignature = Zlib$2.Zip.FileHeaderSignature;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$2.Unzip.LocalFileHeaderSignature = Zlib$2.Zip.LocalFileHeaderSignature;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$2.Unzip.CentralDirectorySignature = Zlib$2.Zip.CentralDirectorySignature;
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {number} ip input position.
     * @constructor
     */

    Zlib$2.Unzip.FileHeader = function (input, ip) {
      /** @type {!(Array.<number>|Uint8Array)} */
      this.input = input;
      /** @type {number} */

      this.offset = ip;
      /** @type {number} */

      this.length;
      /** @type {number} */

      this.version;
      /** @type {number} */

      this.os;
      /** @type {number} */

      this.needVersion;
      /** @type {number} */

      this.flags;
      /** @type {number} */

      this.compression;
      /** @type {number} */

      this.time;
      /** @type {number} */

      this.date;
      /** @type {number} */

      this.crc32;
      /** @type {number} */

      this.compressedSize;
      /** @type {number} */

      this.plainSize;
      /** @type {number} */

      this.fileNameLength;
      /** @type {number} */

      this.extraFieldLength;
      /** @type {number} */

      this.fileCommentLength;
      /** @type {number} */

      this.diskNumberStart;
      /** @type {number} */

      this.internalFileAttributes;
      /** @type {number} */

      this.externalFileAttributes;
      /** @type {number} */

      this.relativeOffset;
      /** @type {string} */

      this.filename;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.extraField;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.comment;
    };

    Zlib$2.Unzip.FileHeader.prototype.parse = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip = this.offset; // central file header signature

      if (input[ip++] !== Zlib$2.Unzip.FileHeaderSignature[0] || input[ip++] !== Zlib$2.Unzip.FileHeaderSignature[1] || input[ip++] !== Zlib$2.Unzip.FileHeaderSignature[2] || input[ip++] !== Zlib$2.Unzip.FileHeaderSignature[3]) {
        throw new Error('invalid file header signature');
      } // version made by


      this.version = input[ip++];
      this.os = input[ip++]; // version needed to extract

      this.needVersion = input[ip++] | input[ip++] << 8; // general purpose bit flag

      this.flags = input[ip++] | input[ip++] << 8; // compression method

      this.compression = input[ip++] | input[ip++] << 8; // last mod file time

      this.time = input[ip++] | input[ip++] << 8; //last mod file date

      this.date = input[ip++] | input[ip++] << 8; // crc-32

      this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // compressed size

      this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // uncompressed size

      this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name length

      this.fileNameLength = input[ip++] | input[ip++] << 8; // extra field length

      this.extraFieldLength = input[ip++] | input[ip++] << 8; // file comment length

      this.fileCommentLength = input[ip++] | input[ip++] << 8; // disk number start

      this.diskNumberStart = input[ip++] | input[ip++] << 8; // internal file attributes

      this.internalFileAttributes = input[ip++] | input[ip++] << 8; // external file attributes

      this.externalFileAttributes = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24; // relative offset of local header

      this.relativeOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name

      this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength) ); // extra field

      this.extraField = input.subarray(ip, ip += this.extraFieldLength) ; // file comment

      this.comment = input.subarray(ip, ip + this.fileCommentLength) ;
      this.length = ip - this.offset;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {number} ip input position.
     * @constructor
     */


    Zlib$2.Unzip.LocalFileHeader = function (input, ip) {
      /** @type {!(Array.<number>|Uint8Array)} */
      this.input = input;
      /** @type {number} */

      this.offset = ip;
      /** @type {number} */

      this.length;
      /** @type {number} */

      this.needVersion;
      /** @type {number} */

      this.flags;
      /** @type {number} */

      this.compression;
      /** @type {number} */

      this.time;
      /** @type {number} */

      this.date;
      /** @type {number} */

      this.crc32;
      /** @type {number} */

      this.compressedSize;
      /** @type {number} */

      this.plainSize;
      /** @type {number} */

      this.fileNameLength;
      /** @type {number} */

      this.extraFieldLength;
      /** @type {string} */

      this.filename;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.extraField;
    };

    Zlib$2.Unzip.LocalFileHeader.Flags = Zlib$2.Zip.Flags;

    Zlib$2.Unzip.LocalFileHeader.prototype.parse = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip = this.offset; // local file header signature

      if (input[ip++] !== Zlib$2.Unzip.LocalFileHeaderSignature[0] || input[ip++] !== Zlib$2.Unzip.LocalFileHeaderSignature[1] || input[ip++] !== Zlib$2.Unzip.LocalFileHeaderSignature[2] || input[ip++] !== Zlib$2.Unzip.LocalFileHeaderSignature[3]) {
        throw new Error('invalid local file header signature');
      } // version needed to extract


      this.needVersion = input[ip++] | input[ip++] << 8; // general purpose bit flag

      this.flags = input[ip++] | input[ip++] << 8; // compression method

      this.compression = input[ip++] | input[ip++] << 8; // last mod file time

      this.time = input[ip++] | input[ip++] << 8; //last mod file date

      this.date = input[ip++] | input[ip++] << 8; // crc-32

      this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // compressed size

      this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // uncompressed size

      this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name length

      this.fileNameLength = input[ip++] | input[ip++] << 8; // extra field length

      this.extraFieldLength = input[ip++] | input[ip++] << 8; // file name

      this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength) ); // extra field

      this.extraField = input.subarray(ip, ip += this.extraFieldLength) ;
      this.length = ip - this.offset;
    };

    Zlib$2.Unzip.prototype.searchEndOfCentralDirectoryRecord = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip;

      for (ip = input.length - 12; ip > 0; --ip) {
        if (input[ip] === Zlib$2.Unzip.CentralDirectorySignature[0] && input[ip + 1] === Zlib$2.Unzip.CentralDirectorySignature[1] && input[ip + 2] === Zlib$2.Unzip.CentralDirectorySignature[2] && input[ip + 3] === Zlib$2.Unzip.CentralDirectorySignature[3]) {
          this.eocdrOffset = ip;
          return;
        }
      }

      throw new Error('End of Central Directory Record not found');
    };

    Zlib$2.Unzip.prototype.parseEndOfCentralDirectoryRecord = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip;

      if (!this.eocdrOffset) {
        this.searchEndOfCentralDirectoryRecord();
      }

      ip = this.eocdrOffset; // signature

      if (input[ip++] !== Zlib$2.Unzip.CentralDirectorySignature[0] || input[ip++] !== Zlib$2.Unzip.CentralDirectorySignature[1] || input[ip++] !== Zlib$2.Unzip.CentralDirectorySignature[2] || input[ip++] !== Zlib$2.Unzip.CentralDirectorySignature[3]) {
        throw new Error('invalid signature');
      } // number of this disk


      this.numberOfThisDisk = input[ip++] | input[ip++] << 8; // number of the disk with the start of the central directory

      this.startDisk = input[ip++] | input[ip++] << 8; // total number of entries in the central directory on this disk

      this.totalEntriesThisDisk = input[ip++] | input[ip++] << 8; // total number of entries in the central directory

      this.totalEntries = input[ip++] | input[ip++] << 8; // size of the central directory

      this.centralDirectorySize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // offset of start of central directory with respect to the starting disk number

      this.centralDirectoryOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // .ZIP file comment length

      this.commentLength = input[ip++] | input[ip++] << 8; // .ZIP file comment

      this.comment = input.subarray(ip, ip + this.commentLength) ;
    };

    Zlib$2.Unzip.prototype.parseFileHeader = function () {
      /** @type {Array.<Zlib.Unzip.FileHeader>} */
      var filelist = [];
      /** @type {Object.<string, number>} */

      var filetable = {};
      /** @type {number} */

      var ip;
      /** @type {Zlib.Unzip.FileHeader} */

      var fileHeader;
      /*: @type {number} */

      var i;
      /*: @type {number} */

      var il;

      if (this.fileHeaderList) {
        return;
      }

      if (this.centralDirectoryOffset === void 0) {
        this.parseEndOfCentralDirectoryRecord();
      }

      ip = this.centralDirectoryOffset;

      for (i = 0, il = this.totalEntries; i < il; ++i) {
        fileHeader = new Zlib$2.Unzip.FileHeader(this.input, ip);
        fileHeader.parse();
        ip += fileHeader.length;
        filelist[i] = fileHeader;
        filetable[fileHeader.filename] = i;
      }

      if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {
        throw new Error('invalid file header size');
      }

      this.fileHeaderList = filelist;
      this.filenameToIndex = filetable;
    };
    /**
     * @param {number} index file header index.
     * @param {Object=} opt_params
     * @return {!(Array.<number>|Uint8Array)} file data.
     */


    Zlib$2.Unzip.prototype.getFileData = function (index, opt_params) {
      opt_params = opt_params || {};
      /** @type {!(Array.<number>|Uint8Array)} */

      var input = this.input;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      var fileHeaderList = this.fileHeaderList;
      /** @type {Zlib.Unzip.LocalFileHeader} */

      var localFileHeader;
      /** @type {number} */

      var offset;
      /** @type {number} */

      var length;
      /** @type {!(Array.<number>|Uint8Array)} */

      var buffer;
      /** @type {number} */

      var crc32;
      /** @type {Array.<number>|Uint32Array|Object} */

      var key;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;

      if (!fileHeaderList) {
        this.parseFileHeader();
      }

      if (fileHeaderList[index] === void 0) {
        throw new Error('wrong index');
      }

      offset = fileHeaderList[index].relativeOffset;
      localFileHeader = new Zlib$2.Unzip.LocalFileHeader(this.input, offset);
      localFileHeader.parse();
      offset += localFileHeader.length;
      length = localFileHeader.compressedSize; // decryption

      if ((localFileHeader.flags & Zlib$2.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {
        if (!(opt_params['password'] || this.password)) {
          throw new Error('please set password');
        }

        key = this.createDecryptionKey(opt_params['password'] || this.password); // encryption header

        for (i = offset, il = offset + 12; i < il; ++i) {
          this.decode(key, input[i]);
        }

        offset += 12;
        length -= 12; // decryption

        for (i = offset, il = offset + length; i < il; ++i) {
          input[i] = this.decode(key, input[i]);
        }
      }

      switch (localFileHeader.compression) {
        case Zlib$2.Unzip.CompressionMethod.STORE:
          buffer = this.input.subarray(offset, offset + length) ;
          break;

        case Zlib$2.Unzip.CompressionMethod.DEFLATE:
          buffer = new Zlib$2.RawInflate(this.input, {
            'index': offset,
            'bufferSize': localFileHeader.plainSize
          }).decompress();
          break;

        default:
          throw new Error('unknown compression type');
      }

      if (this.verify) {
        crc32 = Zlib$2.CRC32.calc(buffer);

        if (localFileHeader.crc32 !== crc32) {
          throw new Error('wrong crc: file=0x' + localFileHeader.crc32.toString(16) + ', data=0x' + crc32.toString(16));
        }
      }

      return buffer;
    };
    /**
     * @return {Array.<string>}
     */


    Zlib$2.Unzip.prototype.getFilenames = function () {
      /** @type {Array.<string>} */
      var filenameList = [];
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      var fileHeaderList;

      if (!this.fileHeaderList) {
        this.parseFileHeader();
      }

      fileHeaderList = this.fileHeaderList;

      for (i = 0, il = fileHeaderList.length; i < il; ++i) {
        filenameList[i] = fileHeaderList[i].filename;
      }

      return filenameList;
    };
    /**
     * @param {string} filename extract filename.
     * @param {Object=} opt_params
     * @return {!(Array.<number>|Uint8Array)} decompressed data.
     */


    Zlib$2.Unzip.prototype.decompress = function (filename, opt_params) {
      /** @type {number} */
      var index;

      if (!this.filenameToIndex) {
        this.parseFileHeader();
      }

      index = this.filenameToIndex[filename];

      if (index === void 0) {
        throw new Error(filename + ' not found');
      }

      return this.getFileData(index, opt_params);
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     */


    Zlib$2.Unzip.prototype.setPassword = function (password) {
      this.password = password;
    };
    /**
     * @param {(Array.<number>|Uint32Array|Object)} key
     * @param {number} n
     * @return {number}
     */


    Zlib$2.Unzip.prototype.decode = function (key, n) {
      n ^= this.getByte(
      /** @type {(Array.<number>|Uint32Array)} */
      key);
      this.updateKeys(
      /** @type {(Array.<number>|Uint32Array)} */
      key, n);
      return n;
    }; // common method


    Zlib$2.Unzip.prototype.updateKeys = Zlib$2.Zip.prototype.updateKeys;
    Zlib$2.Unzip.prototype.createDecryptionKey = Zlib$2.Zip.prototype.createEncryptionKey;
    Zlib$2.Unzip.prototype.getByte = Zlib$2.Zip.prototype.getByte;
    /**
     * @fileoverview 雑多な関数群をまとめたモジュール実装.
     */

    /**
     * Byte String から Byte Array に変換.
     * @param {!string} str byte string.
     * @return {!Array.<number>} byte array.
     */

    Zlib$2.Util.stringToByteArray = function (str) {
      /** @type {!Array.<(string|number)>} */
      var tmp = str.split('');
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;

      for (i = 0, il = tmp.length; i < il; i++) {
        tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;
      }

      return tmp;
    };
    /**
     * @fileoverview Adler32 checksum 実装.
     */

    /**
     * Adler32 ハッシュ値の作成
     * @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
     * @return {number} Adler32 ハッシュ値.
     */


    Zlib$2.Adler32 = function (array) {
      if (typeof array === 'string') {
        array = Zlib$2.Util.stringToByteArray(array);
      }

      return Zlib$2.Adler32.update(1, array);
    };
    /**
     * Adler32 ハッシュ値の更新
     * @param {number} adler 現在のハッシュ値.
     * @param {!(Array|Uint8Array)} array 更新に使用する byte array.
     * @return {number} Adler32 ハッシュ値.
     */


    Zlib$2.Adler32.update = function (adler, array) {
      /** @type {number} */
      var s1 = adler & 0xffff;
      /** @type {number} */

      var s2 = adler >>> 16 & 0xffff;
      /** @type {number} array length */

      var len = array.length;
      /** @type {number} loop length (don't overflow) */

      var tlen;
      /** @type {number} array index */

      var i = 0;

      while (len > 0) {
        tlen = len > Zlib$2.Adler32.OptimizationParameter ? Zlib$2.Adler32.OptimizationParameter : len;
        len -= tlen;

        do {
          s1 += array[i++];
          s2 += s1;
        } while (--tlen);

        s1 %= 65521;
        s2 %= 65521;
      }

      return (s2 << 16 | s1) >>> 0;
    };
    /**
     * Adler32 最適化パラメータ
     * 現状では 1024 程度が最適.
     * @see http://jsperf.com/adler-32-simple-vs-optimized/3
     * @define {number}
     */


    Zlib$2.Adler32.OptimizationParameter = 1024;
    /**
     * ビットストリーム
     * @constructor
     * @param {!(Array|Uint8Array)=} buffer output buffer.
     * @param {number=} bufferPosition start buffer pointer.
     */

    Zlib$2.BitStream = function (buffer, bufferPosition) {
      /** @type {number} buffer index. */
      this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;
      /** @type {number} bit index. */

      this.bitindex = 0;
      /** @type {!(Array|Uint8Array)} bit-stream output buffer. */

      this.buffer = buffer instanceof (Uint8Array ) ? buffer : new (Uint8Array )(Zlib$2.BitStream.DefaultBlockSize); // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする

      if (this.buffer.length * 2 <= this.index) {
        throw new Error("invalid index");
      } else if (this.buffer.length <= this.index) {
        this.expandBuffer();
      }
    };
    /**
     * デフォルトブロックサイズ.
     * @const
     * @type {number}
     */


    Zlib$2.BitStream.DefaultBlockSize = 0x8000;
    /**
     * expand buffer.
     * @return {!(Array|Uint8Array)} new buffer.
     */

    Zlib$2.BitStream.prototype.expandBuffer = function () {
      /** @type {!(Array|Uint8Array)} old buffer. */
      var oldbuf = this.buffer;
      /** @type {number} loop limiter. */

      var il = oldbuf.length;
      /** @type {!(Array|Uint8Array)} new buffer. */

      var buffer = new (Uint8Array )(il << 1); // copy buffer

      {
        buffer.set(oldbuf);
      }

      return this.buffer = buffer;
    };
    /**
     * 数値をビットで指定した数だけ書き込む.
     * @param {number} number 書き込む数値.
     * @param {number} n 書き込むビット数.
     * @param {boolean=} reverse 逆順に書き込むならば true.
     */


    Zlib$2.BitStream.prototype.writeBits = function (number, n, reverse) {
      var buffer = this.buffer;
      var index = this.index;
      var bitindex = this.bitindex;
      /** @type {number} current octet. */

      var current = buffer[index];
      /** @type {number} loop counter. */

      var i;
      /**
       * 32-bit 整数のビット順を逆にする
       * @param {number} n 32-bit integer.
       * @return {number} reversed 32-bit integer.
       * @private
       */

      function rev32_(n) {
        return Zlib$2.BitStream.ReverseTable[n & 0xFF] << 24 | Zlib$2.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16 | Zlib$2.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8 | Zlib$2.BitStream.ReverseTable[n >>> 24 & 0xFF];
      }

      if (reverse && n > 1) {
        number = n > 8 ? rev32_(number) >> 32 - n : Zlib$2.BitStream.ReverseTable[number] >> 8 - n;
      } // Byte 境界を超えないとき


      if (n + bitindex < 8) {
        current = current << n | number;
        bitindex += n; // Byte 境界を超えるとき
      } else {
        for (i = 0; i < n; ++i) {
          current = current << 1 | number >> n - i - 1 & 1; // next byte

          if (++bitindex === 8) {
            bitindex = 0;
            buffer[index++] = Zlib$2.BitStream.ReverseTable[current];
            current = 0; // expand

            if (index === buffer.length) {
              buffer = this.expandBuffer();
            }
          }
        }
      }

      buffer[index] = current;
      this.buffer = buffer;
      this.bitindex = bitindex;
      this.index = index;
    };
    /**
     * ストリームの終端処理を行う
     * @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.
     */


    Zlib$2.BitStream.prototype.finish = function () {
      var buffer = this.buffer;
      var index = this.index;
      /** @type {!(Array|Uint8Array)} output buffer. */

      var output; // bitindex が 0 の時は余分に index が進んでいる状態

      if (this.bitindex > 0) {
        buffer[index] <<= 8 - this.bitindex;
        buffer[index] = Zlib$2.BitStream.ReverseTable[buffer[index]];
        index++;
      } // array truncation


      {
        output = buffer.subarray(0, index);
      }

      return output;
    };
    /**
     * 0-255 のビット順を反転したテーブル
     * @const
     * @type {!(Uint8Array|Array.<number>)}
     */


    Zlib$2.BitStream.ReverseTable = function (table) {
      return table;
    }(function () {
      /** @type {!(Array|Uint8Array)} reverse table. */
      var table = new (Uint8Array )(256);
      /** @type {number} loop counter. */

      var i; // generate

      for (i = 0; i < 256; ++i) {
        table[i] = function (n) {
          var r = n;
          var s = 7;

          for (n >>>= 1; n; n >>>= 1) {
            r <<= 1;
            r |= n & 1;
            --s;
          }

          return (r << s & 0xff) >>> 0;
        }(i);
      }

      return table;
    }());
    /**
     * CRC32 ハッシュ値を取得
     * @param {!(Array.<number>|Uint8Array)} data data byte array.
     * @param {number=} pos data position.
     * @param {number=} length data length.
     * @return {number} CRC32.
     */

    Zlib$2.CRC32.calc = function (data, pos, length) {
      return Zlib$2.CRC32.update(data, 0, pos, length);
    };
    /**
     * CRC32ハッシュ値を更新
     * @param {!(Array.<number>|Uint8Array)} data data byte array.
     * @param {number} crc CRC32.
     * @param {number=} pos data position.
     * @param {number=} length data length.
     * @return {number} CRC32.
     */


    Zlib$2.CRC32.update = function (data, crc, pos, length) {
      var table = Zlib$2.CRC32.Table;
      var i = typeof pos === 'number' ? pos : pos = 0;
      var il = typeof length === 'number' ? length : data.length;
      crc ^= 0xffffffff; // loop unrolling for performance

      for (i = il & 7; i--; ++pos) {
        crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 0xff];
      }

      for (i = il >> 3; i--; pos += 8) {
        crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 1]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 2]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 3]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 4]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 5]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 6]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 7]) & 0xff];
      }

      return (crc ^ 0xffffffff) >>> 0;
    };
    /**
     * @param {number} num
     * @param {number} crc
     * @returns {number}
     */


    Zlib$2.CRC32.single = function (num, crc) {
      return (Zlib$2.CRC32.Table[(num ^ crc) & 0xff] ^ num >>> 8) >>> 0;
    };
    /**
     * @type {Array.<number>}
     * @const
     * @private
     */


    Zlib$2.CRC32.Table_ = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d];
    /**
     * @type {!(Array.<number>|Uint32Array)} CRC-32 Table.
     * @const
     */

    Zlib$2.CRC32.Table = new Uint32Array(Zlib$2.CRC32.Table_) ;
    /**
     * @fileoverview Deflate (RFC1951) 実装.
     * Deflateアルゴリズム本体は Zlib.RawDeflate で実装されている.
     */

    /**
     * Zlib Deflate
     * @constructor
     * @param {!(Array|Uint8Array)} input 符号化する対象の byte array.
     * @param {Object=} opt_params option parameters.
     */

    Zlib$2.Deflate = function (input, opt_params) {
      /** @type {!(Array|Uint8Array)} */
      this.input = input;
      /** @type {!(Array|Uint8Array)} */

      this.output = new (Uint8Array )(Zlib$2.Deflate.DefaultBufferSize);
      /** @type {Zlib.Deflate.CompressionType} */

      this.compressionType = Zlib$2.Deflate.CompressionType.DYNAMIC;
      /** @type {Zlib.RawDeflate} */

      this.rawDeflate;
      /** @type {Object} */

      var rawDeflateOption = {};
      /** @type {string} */

      var prop; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (typeof opt_params['compressionType'] === 'number') {
          this.compressionType = opt_params['compressionType'];
        }
      } // copy options


      for (prop in opt_params) {
        rawDeflateOption[prop] = opt_params[prop];
      } // set raw-deflate output buffer


      rawDeflateOption['outputBuffer'] = this.output;
      this.rawDeflate = new Zlib$2.RawDeflate(this.input, rawDeflateOption);
    };
    /**
     * @const
     * @type {number} デフォルトバッファサイズ.
     */


    Zlib$2.Deflate.DefaultBufferSize = 0x8000;
    /**
     * @enum {number}
     */

    Zlib$2.Deflate.CompressionType = Zlib$2.RawDeflate.CompressionType;
    /**
     * 直接圧縮に掛ける.
     * @param {!(Array|Uint8Array)} input target buffer.
     * @param {Object=} opt_params option parameters.
     * @return {!(Array|Uint8Array)} compressed data byte array.
     */

    Zlib$2.Deflate.compress = function (input, opt_params) {
      return new Zlib$2.Deflate(input, opt_params).compress();
    };
    /**
     * Deflate Compression.
     * @return {!(Array|Uint8Array)} compressed data byte array.
     */


    Zlib$2.Deflate.prototype.compress = function () {
      /** @type {Zlib.CompressionMethod} */
      var cm;
      /** @type {number} */

      var cinfo;
      /** @type {number} */

      var cmf;
      /** @type {number} */

      var flg;
      /** @type {number} */

      var fcheck;
      /** @type {number} */

      var fdict;
      /** @type {number} */

      var flevel;
      /** @type {number} */

      var adler;
      /** @type {!(Array|Uint8Array)} */

      var output;
      /** @type {number} */

      var pos = 0;
      output = this.output; // Compression Method and Flags

      cm = Zlib$2.CompressionMethod.DEFLATE;

      switch (cm) {
        case Zlib$2.CompressionMethod.DEFLATE:
          cinfo = Math.LOG2E * Math.log(Zlib$2.RawDeflate.WindowSize) - 8;
          break;

        default:
          throw new Error('invalid compression method');
      }

      cmf = cinfo << 4 | cm;
      output[pos++] = cmf; // Flags

      fdict = 0;

      switch (cm) {
        case Zlib$2.CompressionMethod.DEFLATE:
          switch (this.compressionType) {
            case Zlib$2.Deflate.CompressionType.NONE:
              flevel = 0;
              break;

            case Zlib$2.Deflate.CompressionType.FIXED:
              flevel = 1;
              break;

            case Zlib$2.Deflate.CompressionType.DYNAMIC:
              flevel = 2;
              break;

            default:
              throw new Error('unsupported compression type');
          }

          break;

        default:
          throw new Error('invalid compression method');
      }

      flg = flevel << 6 | fdict << 5;
      fcheck = 31 - (cmf * 256 + flg) % 31;
      flg |= fcheck;
      output[pos++] = flg; // Adler-32 checksum

      adler = Zlib$2.Adler32(this.input);
      this.rawDeflate.op = pos;
      output = this.rawDeflate.compress();
      pos = output.length;

      {
        // subarray 分を元にもどす
        output = new Uint8Array(output.buffer); // expand buffer

        if (output.length <= pos + 4) {
          this.output = new Uint8Array(output.length + 4);
          this.output.set(output);
          output = this.output;
        }

        output = output.subarray(0, pos + 4);
      } // adler32


      output[pos++] = adler >> 24 & 0xff;
      output[pos++] = adler >> 16 & 0xff;
      output[pos++] = adler >> 8 & 0xff;
      output[pos++] = adler & 0xff;
      return output;
    };

    let _btoa;

    if (typeof btoa === 'undefined') {
      _btoa = require('btoa');
    } else {
      _btoa = btoa;
    }
    /**
     * Covers string literals and String objects
     * @param x
     * @returns {boolean}
     */


    function isString$2(x) {
      return typeof x === "string" || x instanceof String;
    } // StackOverflow: http://stackoverflow.com/a/10810674/116169


    function numberFormatter(rawNumber) {
      var dec = String(rawNumber).split(/[.,]/),
          sep = ',',
          decsep = '.';
      return dec[0].split('').reverse().reduce(function (prev, now, i) {
        return i % 3 === 0 ? prev + sep + now : prev + now;
      }).split('').reverse().join('') + (dec[1] ? decsep + dec[1] : '');
    }

    const numberUnFormatter = formatedNumber => formatedNumber.split(",").join().replace(",", "", "g");

    const splitLines = function (string) {
      return string.split(/\n|\r\n|\r/g);
    };

    function splitStringRespectingQuotes(string, delim) {
      var tokens = [],
          len = string.length,
          i,
          n = 0,
          quote = false,
          c;

      if (len > 0) {
        tokens[n] = string.charAt(0);

        for (i = 1; i < len; i++) {
          c = string.charAt(i);

          if (c === '"') {
            quote = !quote;
          } else if (!quote && c === delim) {
            n++;
            tokens[n] = "";
          } else {
            tokens[n] += c;
          }
        }
      }

      return tokens;
    }

    function stripQuotes(str) {
      if (str === undefined) {
        return str;
      }

      if (str.startsWith("'") || str.startsWith('"')) {
        str = str.substring(1);
      }

      if (str.endsWith("'") || str.endsWith('"')) {
        str = str.substring(0, str.length - 1);
      }

      return str;
    }
    /**
     * Compress string and encode in a url safe form
     * @param s
     */


    function compressString(str) {
      const bytes = [];

      for (var i = 0; i < str.length; i++) {
        bytes.push(str.charCodeAt(i));
      }

      const compressedBytes = new Zlib$2.RawDeflate(bytes).compress(); // UInt8Arry

      const compressedString = String.fromCharCode.apply(null, compressedBytes); // Convert to string

      let enc = _btoa(compressedString);

      return enc.replace(/\+/g, '.').replace(/\//g, '_').replace(/=/g, '-'); // URL safe
    }
    /**
     * Uncompress the url-safe encoded compressed string, presumably created by compressString above
     *
     * @param enc
     * @returns {string}
     */


    function uncompressString(enc) {
      enc = enc.replace(/\./g, '+').replace(/_/g, '/').replace(/-/g, '=');
      const compressedString = atob(enc);
      const compressedBytes = [];

      for (let i = 0; i < compressedString.length; i++) {
        compressedBytes.push(compressedString.charCodeAt(i));
      }

      const bytes = new Zlib$2.RawInflate(compressedBytes).decompress();
      let str = '';

      for (let b of bytes) {
        str += String.fromCharCode(b);
      }

      return str;
    }

    function capitalize(str) {
      return str.length > 0 ? str.charAt(0).toUpperCase() + str.slice(1) : str;
    }

    const FileFormats = {
      gwascatalog: {
        fields: ['bin', 'chr', 'start', 'end', 'name', 'pubMedID', 'author', 'pubDate', 'journal', 'title', 'trait', 'initSample', 'replSample', 'region', 'genes', 'riskAllele', 'riskAlFreq', 'pValue', 'pValueDesc', 'orOrBeta', 'ci95', 'platform', 'cnv']
      },
      wgrna: {
        fields: ['bin', 'chr', 'start', 'end', 'name', 'score', 'strand', 'thickStart', 'thickEnd', 'type']
      },
      cpgislandext: {
        fields: ['bin', 'chr', 'start', 'end', 'name', 'length', 'cpgNum', 'gcNum', 'perCpg', 'perGc', 'obsExp']
      },
      clinVarMain: {
        fields: ['chr1', 'start', 'end', 'name', 'score', 'strand', 'thickStart', 'thickEnd', 'reserved', 'blockCount', // Number of blocks
        'blockSizes', // Comma separated list of block sizes
        'chromStarts', // Start positions relative to chromStart
        'origName', // NM_198053.2(CD247):c.462C>T (p.Asp154=)	ClinVar Variation Report
        'clinSign', // Likely benign	Clinical significance
        'reviewStatus', // 	based on: criteria provided,single submitter	Review Status
        'type', // single nucleotide variant	Type of Variant
        'geneId', // CD247	Gene Symbol
        'snpId', //	181656780	dbSNP ID
        'nsvId', //		dbVar ID
        'rcvAcc', //	RCV000642347	ClinVar Allele Submission
        'testedInGtr', //	N	Genetic Testing Registry
        'phenotypeList', //	Immunodeficiency due to defect in cd3-zeta	Phenotypes
        'phenotype', //	MedGen:C1857798, OMIM:610163	Phenotype identifiers
        'origin', //	germline	Data origin
        'assembly', //	GRCh37	Genome assembly
        'cytogenetic', //	1q24.2	Cytogenetic status
        'hgvsCod', //	NM_198053.2:c.462C>T	Nucleotide HGVS
        'hgvsProt', //	NP_932170.1:p.Asp154=	Protein HGVS
        'numSubmit', //	1	Number of submitters
        'lastEval', //	Dec 19,2017	Last evaluation
        'guidelines', //		Guidelines
        'otherIds']
      }
    };

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    const knownFileExtensions = new Set(["narrowpeak", "broadpeak", "regionpeak", "peaks", "bedgraph", "wig", "gff3", "gff", "gtf", "fusionjuncspan", "refflat", "seg", "aed", "bed", "vcf", "bb", "bigbed", "bw", "bigwig", "bam", "tdf", "refgene", "genepred", "genepredext", "bedpe", "bp", "snp", "rmsk", "cram", "gwas"]);
    /**
     * Return a custom format object with the given name.
     * @param name
     * @returns {*}
     */

    function getFormat(name) {
      if (FileFormats && FileFormats[name]) {
        return expandFormat(FileFormats[name]);
      } else {
        return undefined;
      }

      function expandFormat(format) {
        const fields = format.fields;
        const keys = ['chr', 'start', 'end'];

        for (let i = 0; i < fields.length; i++) {
          for (let key of keys) {
            if (key === fields[i]) {
              format[key] = i;
            }
          }
        }

        return format;
      }
    }

    function inferFileFormat(fn) {
      var idx, ext;
      fn = fn.toLowerCase(); // Special case -- UCSC refgene files

      if (fn.endsWith("refgene.txt.gz") || fn.endsWith("refgene.txt.bgz") || fn.endsWith("refgene.txt") || fn.endsWith("refgene.sorted.txt.gz") || fn.endsWith("refgene.sorted.txt.bgz")) {
        return "refgene";
      } //Strip parameters -- handle local files later


      idx = fn.indexOf("?");

      if (idx > 0) {
        fn = fn.substr(0, idx);
      } //Strip aux extensions .gz, .tab, and .txt


      if (fn.endsWith(".gz")) {
        fn = fn.substr(0, fn.length - 3);
      }

      if (fn.endsWith(".txt") || fn.endsWith(".tab") || fn.endsWith(".bgz")) {
        fn = fn.substr(0, fn.length - 4);
      }

      idx = fn.lastIndexOf(".");
      ext = idx < 0 ? fn : fn.substr(idx + 1);

      switch (ext) {
        case "bw":
          return "bigwig";

        case "bb":
          return "bigbed";

        default:
          if (knownFileExtensions.has(ext)) {
            return ext;
          } else {
            return undefined;
          }

      }
    }

    function isGoogleURL(url) {
      return url.includes("googleapis") && !url.includes("urlshortener") || isGoogleStorageURL(url) || isGoogleDriveURL(url);
    }

    function isGoogleStorageURL(url) {
      return url.startsWith("gs://") || url.startsWith("https://www.googleapis.com/storage") || url.startsWith("https://storage.cloud.google.com") || url.startsWith("https://storage.googleapis.com");
    }

    function isGoogleDriveURL(url) {
      return url.indexOf("drive.google.com") >= 0 || url.indexOf("www.googleapis.com/drive") > 0;
    }

    function translateGoogleCloudURL(gsUrl) {
      var i, bucket, object, qIdx, objectString, paramString;
      i = gsUrl.indexOf('/', 5);
      qIdx = gsUrl.indexOf('?');

      if (i < 0) {
        console.log("Invalid gs url: " + gsUrl);
        return gsUrl;
      }

      bucket = gsUrl.substring(5, i);
      objectString = qIdx < 0 ? gsUrl.substring(i + 1) : gsUrl.substring(i + 1, qIdx);
      object = encodeURIComponent(objectString);

      if (qIdx > 0) {
        paramString = gsUrl.substring(qIdx);
      }

      return "https://www.googleapis.com/storage/v1/b/" + bucket + "/o/" + object + (paramString ? paramString + "&alt=media" : "?alt=media");
    }

    function driveDownloadURL(link) {
      // Return a google drive download url for the sharable link
      //https://drive.google.com/open?id=0B-lleX9c2pZFbDJ4VVRxakJzVGM
      //https://drive.google.com/file/d/1_FC4kCeO8E3V4dJ1yIW7A0sn1yURKIX-/view?usp=sharing
      var id = getGoogleDriveFileID(link);
      return id ? "https://www.googleapis.com/drive/v3/files/" + id + "?alt=media&supportsTeamDrives=true" : link;
    }

    function getGoogleDriveFileID(link) {
      //https://drive.google.com/file/d/1_FC4kCeO8E3V4dJ1yIW7A0sn1yURKIX-/view?usp=sharing
      //https://www.googleapis.com/drive/v3/files/1w-tvo6p1SH4p1OaQSVxpkV_EJgGIstWF?alt=media&supportsTeamDrives=true"
      if (link.includes("/open?id=")) {
        const i1 = link.indexOf("/open?id=") + 9;
        const i2 = link.indexOf("&");

        if (i1 > 0 && i2 > i1) {
          return link.substring(i1, i2);
        } else if (i1 > 0) {
          return link.substring(i1);
        }
      } else if (link.includes("/file/d/")) {
        const i1 = link.indexOf("/file/d/") + 8;
        const i2 = link.lastIndexOf("/");
        return link.substring(i1, i2);
      } else if (link.startsWith("https://www.googleapis.com/drive")) {
        let i1 = link.indexOf("/files/");
        const i2 = link.indexOf("?");

        if (i1 > 0) {
          i1 += 7;
          return i2 > 0 ? link.substring(i1, i2) : link.substring(i1);
        }
      }

      throw Error("Unknown Google Drive url format: " + link);
    }

    // Convenience functions for the gapi oAuth library.
    const FIVE_MINUTES = 5 * 60 * 1000;

    function isInitialized() {
      return typeof gapi !== "undefined" && gapi.auth2 && gapi.auth2.getAuthInstance();
    }

    let inProgress = false;

    async function getAccessToken(scope) {
      if (typeof gapi === "undefined") {
        throw Error("Google authentication requires the 'gapi' library");
      }

      if (!gapi.auth2) {
        throw Error("Google 'auth2' has not been initialized");
      }

      if (inProgress) {
        return new Promise(function (resolve, reject) {
          let intervalID;

          const checkForToken = () => {
            // Wait for inProgress to equal "false"
            try {
              if (inProgress === false) {
                //console.log("Delayed resolution for " + scope);
                resolve(getAccessToken(scope));
                clearInterval(intervalID);
              }
            } catch (e) {
              clearInterval(intervalID);
              reject(e);
            }
          };

          intervalID = setInterval(checkForToken, 100);
        });
      } else {
        inProgress = true;

        try {
          let currentUser = gapi.auth2.getAuthInstance().currentUser.get();
          let token;

          if (currentUser.isSignedIn()) {
            if (!currentUser.hasGrantedScopes(scope)) {
              await currentUser.grant({
                scope
              });
            }

            const {
              access_token,
              expires_at
            } = currentUser.getAuthResponse();

            if (Date.now() < expires_at - FIVE_MINUTES) {
              token = {
                access_token,
                expires_at
              };
            } else {
              const {
                access_token,
                expires_at
              } = currentUser.reloadAuthResponse();
              token = {
                access_token,
                expires_at
              };
            }
          } else {
            currentUser = await signIn(scope);
            const {
              access_token,
              expires_at
            } = currentUser.getAuthResponse();
            token = {
              access_token,
              expires_at
            };
          }

          return token;
        } finally {
          inProgress = false;
        }
      }
    }
    /**
     * Return the current access token if the user is signed in, or undefined otherwise.  This function does not
     * attempt a signIn or request any specfic scopes.
     *
     * @returns access_token || undefined
     */


    function getCurrentAccessToken() {
      let currentUser = gapi.auth2.getAuthInstance().currentUser.get();

      if (currentUser && currentUser.isSignedIn()) {
        const {
          access_token,
          expires_at
        } = currentUser.getAuthResponse();
        return {
          access_token,
          expires_at
        };
      } else {
        return undefined;
      }
    }

    async function signIn(scope) {
      const options = new gapi.auth2.SigninOptionsBuilder();
      options.setPrompt('select_account');
      options.setScope(scope);
      return gapi.auth2.getAuthInstance().signIn(options);
    }

    function getScopeForURL(url) {
      if (isGoogleDriveURL(url)) {
        return "https://www.googleapis.com/auth/drive.file";
      } else if (isGoogleStorageURL(url)) {
        return "https://www.googleapis.com/auth/devstorage.read_only";
      } else {
        return 'https://www.googleapis.com/auth/userinfo.profile';
      }
    }

    function getApiKey() {
      return gapi.apiKey;
    }

    async function getDriveFileInfo(googleDriveURL) {
      const id = getGoogleDriveFileID(googleDriveURL);
      let endPoint = "https://www.googleapis.com/drive/v3/files/" + id + "?supportsTeamDrives=true";
      const apiKey = getApiKey();

      if (apiKey) {
        endPoint += "&key=" + apiKey;
      }

      const response = await fetch(endPoint);
      let json = await response.json();

      if (json.error && json.error.code === 404) {
        const {
          access_token
        } = await getAccessToken("https://www.googleapis.com/auth/drive.readonly");

        if (access_token) {
          const response = await fetch(endPoint, {
            headers: {
              'Authorization': `Bearer ${access_token}`
            }
          });
          json = await response.json();

          if (json.error) {
            throw Error(json.error);
          }
        } else {
          throw Error(json.error);
        }
      }

      return json;
    }

    if (typeof process === 'object' && typeof window === 'undefined') {
      global.atob = function (str) {
        return Buffer.from(str, 'base64').toString('binary');
      };
    }
    /**
     * @param dataURI
     * @returns {Array<number>|Uint8Array}
     */


    function decodeDataURI(dataURI) {
      const split = dataURI.split(',');
      const info = split[0].split(':')[1];
      let dataString = split[1];

      if (info.indexOf('base64') >= 0) {
        dataString = atob(dataString);
      } else {
        dataString = decodeURI(dataString); // URL encoded string -- not currently used of tested
      }

      const bytes = new Uint8Array(dataString.length);

      for (let i = 0; i < dataString.length; i++) {
        bytes[i] = dataString.charCodeAt(i);
      }

      let plain;

      if (info.indexOf('gzip') > 0) {
        const inflate = new Zlib$2.Gunzip(bytes);
        plain = inflate.decompress();
      } else {
        plain = bytes;
      }

      return plain;
    }

    function parseUri(str) {
      var o = options,
          m = o.parser["loose"].exec(str),
          uri = {},
          i = 14;

      while (i--) uri[o.key[i]] = m[i] || "";

      uri[o.q.name] = {};
      uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
        if ($1) uri[o.q.name][$1] = $2;
      });
      return uri;
    }

    const options = {
      strictMode: false,
      key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
      q: {
        name: "queryKey",
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
      },
      parser: {
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
      }
    };
    /**
     * Resolve a url, which might be a string, function (that returns a string or Promse), or Promise (that resolves to a string)
     *
     * @param url
     * @returns {Promise<*>}
     */


    async function resolveURL(url) {
      return typeof url === 'function' ? url() : url;
    }

    /**
     * Return the filename from the path.   Example
     *   https://foo.com/bar.bed?param=2   => bar.bed
     * @param urlOrFile
     */


    function getFilename$2(urlOrFile) {
      if (urlOrFile instanceof File) {
        return urlOrFile.name;
      } else if (isString$2(urlOrFile)) {
        let index = urlOrFile.lastIndexOf("/");
        let filename = index < 0 ? urlOrFile : urlOrFile.substr(index + 1); //Strip parameters -- handle local files later

        index = filename.indexOf("?");

        if (index > 0) {
          filename = filename.substr(0, index);
        }

        return filename;
      } else {
        throw Error(`Expected File or string, got ${typeof urlOrFile}`);
      }
    }

    async function getFilenameExtended(path) {
      if (path instanceof File) {
        return path.name;
      } else if (isGoogleDriveURL(path)) {
        if (typeof gapi === "undefined") {
          throw Error(`Google initialization with API key is required to load Google urls (${path})`);
        }

        const info = await getDriveFileInfo(path);
        return info.name || info.originalFileName;
      } else {
        const result = parseUri(path);
        return result.file;
      }
    }

    function isFilePath(path) {
      return path instanceof File;
    }

    // Uncompress data,  assumed to be series of bgzipped blocks

    function unbgzf(data, lim) {
      const oBlockList = [];
      let ptr = 0;
      let totalSize = 0;
      lim = lim || data.byteLength - 18;

      while (ptr < lim) {
        try {
          const ba = new Uint8Array(data, ptr, 18);
          const xlen = ba[11] << 8 | ba[10];
          const si1 = ba[12];
          const si2 = ba[13];
          const slen = ba[15] << 8 | ba[14];
          const bsize = (ba[17] << 8 | ba[16]) + 1;
          const start = 12 + xlen + ptr; // Start of CDATA

          const bytesLeft = data.byteLength - start;
          const cDataSize = bsize - xlen - 19;
          if (bytesLeft < cDataSize || cDataSize <= 0) break;
          const a = new Uint8Array(data, start, cDataSize);
          const inflate = new Zlib$2.RawInflate(a);
          const unc = inflate.decompress();
          ptr += inflate.ip + 26;
          totalSize += unc.byteLength;
          oBlockList.push(unc);
        } catch (e) {
          console.error(e);
          break;
        }
      } // Concatenate decompressed blocks


      if (oBlockList.length === 1) {
        return oBlockList[0];
      } else {
        const out = new Uint8Array(totalSize);
        let cursor = 0;

        for (let i = 0; i < oBlockList.length; ++i) {
          var b = new Uint8Array(oBlockList[i]);
          arrayCopy(b, 0, out, cursor, b.length);
          cursor += b.length;
        }

        return out;
      }
    }

    function bgzBlockSize(data) {
      const ba = new Uint8Array(data);
      const bsize = ba[17] << 8 | ba[16] + 1;
      return bsize;
    } // From Thomas Down's zlib implementation


    const testArray = new Uint8Array(1);
    const hasSubarray = typeof testArray.subarray === 'function';
    /* (typeof testArray.slice === 'function'); */
    // Chrome slice performance is so dire that we're currently not using it...

    function arrayCopy(src, srcOffset, dest, destOffset, count) {
      if (count === 0) {
        return;
      }

      if (!src) {
        throw "Undef src";
      } else if (!dest) {
        throw "Undef dest";
      }

      if (srcOffset === 0 && count === src.length) {
        arrayCopy_fast(src, dest, destOffset);
      } else if (hasSubarray) {
        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset);
      } else if (src.BYTES_PER_ELEMENT === 1 && count > 100) {
        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);
      } else {
        arrayCopy_slow(src, srcOffset, dest, destOffset, count);
      }
    }

    function arrayCopy_slow(src, srcOffset, dest, destOffset, count) {
      for (let i = 0; i < count; ++i) {
        dest[destOffset + i] = src[srcOffset + i];
      }
    }

    function arrayCopy_fast(src, dest, destOffset) {
      dest.set(src, destOffset);
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     * Author: Jim Robinson
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    const IGVMath = {
      lerp: (v0, v1, t) => {
        return (1 - t) * v0 + t * v1;
      },
      mean: function (array) {
        var t = 0,
            n = 0,
            i;

        for (i = 0; i < array.length; i++) {
          if (!isNaN(array[i])) {
            t += array[i];
            n++;
          }
        }

        return n > 0 ? t / n : 0;
      },
      meanAndStdev: function (array) {
        var v,
            t = 0,
            t2 = 0,
            n = 0,
            i;

        for (i = 0; i < array.length; i++) {
          v = array[i];

          if (!isNaN(v)) {
            t += v;
            t2 += v * v;
            n++;
          }
        }

        return n > 0 ? {
          mean: t / n,
          stdev: Math.sqrt(t2 - t * t / n)
        } : {
          mean: 0,
          stdev: 0
        };
      },
      median: function (numbers) {
        // median of [3, 5, 4, 4, 1, 1, 2, 3] = 3
        var median = 0,
            numsLen = numbers.length;
        numbers.sort();

        if (numsLen % 2 === 0 // is even
        ) {
          // average of two middle numbers
          median = (numbers[numsLen / 2 - 1] + numbers[numsLen / 2]) / 2;
        } else {
          // is odd
          // middle number only
          median = numbers[(numsLen - 1) / 2];
        }

        return median;
      },
      // Fast percentile function for "p" near edges.  This needs profiled for p in middle (e.g. median)
      percentile: function (array, p) {
        if (array.length === 0) return undefined;
        var k = Math.floor(array.length * ((100 - p) / 100));

        if (k === 0) {
          array.sort(function (a, b) {
            return b - a;
          });
          return array[k];
        } else {
          return selectElement(array, k);
        }
      },
      clamp: function (value, min, max) {
        return Math.min(Math.max(value, min), max);
      },
      log2: function (x) {
        return Math.log(x) / Math.LN2;
      }
    };

    function selectElement(array, k) {
      // Credit Steve Hanov http://stevehanov.ca/blog/index.php?id=122
      var heap = new BinaryHeap(),
          i;

      for (i = 0; i < array.length; i++) {
        var item = array[i]; // If we have not yet found k items, or the current item is larger than
        // the smallest item on the heap, add current item

        if (heap.content.length < k || item > heap.content[0]) {
          // If the heap is full, remove the smallest element on the heap.
          if (heap.content.length === k) {
            heap.pop();
          }

          heap.push(item);
        }
      }

      return heap.content[0];
    }

    function BinaryHeap() {
      this.content = [];
    }

    BinaryHeap.prototype = {
      push: function (element) {
        // Add the new element to the end of the array.
        this.content.push(element); // Allow it to bubble up.

        this.bubbleUp(this.content.length - 1);
      },
      pop: function () {
        // Store the first element so we can return it later.
        var result = this.content[0]; // Get the element at the end of the array.

        var end = this.content.pop(); // If there are any elements left, put the end element at the
        // start, and let it sink down.

        if (this.content.length > 0) {
          this.content[0] = end;
          this.sinkDown(0);
        }

        return result;
      },
      remove: function (node) {
        var length = this.content.length; // To remove a value, we must search through the array to find
        // it.

        for (var i = 0; i < length; i++) {
          if (this.content[i] !== node) continue; // When it is found, the process seen in 'pop' is repeated
          // to fill up the hole.

          var end = this.content.pop(); // If the element we popped was the one we needed to remove,
          // we're done.

          if (i === length - 1) break; // Otherwise, we replace the removed element with the popped
          // one, and allow it to float up or sink down as appropriate.

          this.content[i] = end;
          this.bubbleUp(i);
          this.sinkDown(i);
          break;
        }
      },
      size: function () {
        return this.content.length;
      },
      bubbleUp: function (n) {
        // Fetch the element that has to be moved.
        var element = this.content[n],
            score = element; // When at 0, an element can not go up any further.

        while (n > 0) {
          // Compute the parent element's index, and fetch it.
          var parentN = Math.floor((n + 1) / 2) - 1,
              parent = this.content[parentN]; // If the parent has a lesser score, things are in order and we
          // are done.

          if (score >= parent) break; // Otherwise, swap the parent with the current element and
          // continue.

          this.content[parentN] = element;
          this.content[n] = parent;
          n = parentN;
        }
      },
      sinkDown: function (n) {
        // Look up the target element and its score.
        var length = this.content.length,
            element = this.content[n],
            elemScore = element;

        while (true) {
          // Compute the indices of the child elements.
          var child2N = (n + 1) * 2,
              child1N = child2N - 1; // This is used to store the new position of the element,
          // if any.

          var swap = null; // If the first child exists (is inside the array)...

          if (child1N < length) {
            // Look it up and compute its score.
            var child1 = this.content[child1N],
                child1Score = child1; // If the score is less than our element's, we need to swap.

            if (child1Score < elemScore) swap = child1N;
          } // Do the same checks for the other child.


          if (child2N < length) {
            var child2 = this.content[child2N],
                child2Score = child2;
            if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;
          } // No need to swap further, we are done.


          if (swap == null) break; // Otherwise, swap and continue.

          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        }
      }
    };

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    const IGVColor = {
      rgbListFromHSV: () => {
        let s = 1;
        let accumulation = [];

        for (let v = 1; v >= 0.5; v -= .1) {
          for (let h = 0; h < 1; h += 1 / 28) {
            const r = "rgb(" + IGVColor.hsvToRgb(h, s, v).join(",") + ")";
            accumulation.push(r);
          }
        } // add black


        accumulation.pop();
        accumulation.push(IGVColor.rgbColor(16, 16, 16));
        return accumulation;
      },
      rgbToHex: function (rgb) {
        rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
        return rgb && rgb.length === 4 ? "#" + ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2) : '';
      },
      hexToRgb: function (hex) {
        var cooked = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

        if (null === cooked) {
          return undefined;
        }

        return "rgb(" + parseInt(cooked[1], 16) + "," + parseInt(cooked[2], 16) + "," + parseInt(cooked[3], 16) + ")";
      },

      /**
       * Converts an HSV color value to RGB. Conversion formula
       * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
       * Assumes h, s, and v are contained in the set [0, 1] and
       * returns r, g, and b in the set [0, 255].
       *
       * Credit: https://gist.githubusercontent.com/mjackson/5311256
       *
       * @param   h       The hue
       * @param   s       The saturation
       * @param   v       The value
       * @return  Array   The RGB representation
       */
      hsvToRgb: function (h, s, v) {
        var r, g, b;
        var i = Math.floor(h * 6);
        var f = h * 6 - i;
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);

        switch (i % 6) {
          case 0:
            r = v, g = t, b = p;
            break;

          case 1:
            r = q, g = v, b = p;
            break;

          case 2:
            r = p, g = v, b = t;
            break;

          case 3:
            r = p, g = q, b = v;
            break;

          case 4:
            r = t, g = p, b = v;
            break;

          case 5:
            r = v, g = p, b = q;
            break;
        }

        return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
      },

      /**
       * Converts an HSL color value to RGB. Conversion formula
       * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
       * Assumes h, s, and l are contained in the set [0, 1] and
       * returns r, g, and b in the set [0, 255].
       *
       * Credit: https://gist.githubusercontent.com/mjackson/5311256
       *
       * @param   h       The hue
       * @param   s       The saturation
       * @param   l       The lightness
       * @return  Array   The RGB representation
       */
      hslToRgb: function (h, s, l) {
        var r, g, b;

        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = IGVColor.hue2rgb(p, q, h + 1 / 3);
          g = IGVColor.hue2rgb(p, q, h);
          b = IGVColor.hue2rgb(p, q, h - 1 / 3);
        }

        return [r * 255, g * 255, b * 255];
      },
      hue2rgb: (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      },
      rgbaColor: function (r, g, b, a) {
        r = IGVMath.clamp(r, 0, 255);
        g = IGVMath.clamp(g, 0, 255);
        b = IGVMath.clamp(b, 0, 255);
        a = IGVMath.clamp(a, 0.0, 1.0);
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
      },
      rgbColor: function (r, g, b) {
        r = IGVMath.clamp(r, 0, 255);
        g = IGVMath.clamp(g, 0, 255);
        b = IGVMath.clamp(b, 0, 255);
        return "rgb(" + r + "," + g + "," + b + ")";
      },
      greyScale: function (value) {
        var grey = IGVMath.clamp(value, 0, 255);
        return "rgb(" + grey + "," + grey + "," + grey + ")";
      },
      randomGrey: function (min, max) {
        min = IGVMath.clamp(min, 0, 255);
        max = IGVMath.clamp(max, 0, 255);
        var g = Math.round(Math.random(min, max)).toString(10);
        return "rgb(" + g + "," + g + "," + g + ")";
      },
      randomRGB: function (min, max) {
        min = IGVMath.clamp(min, 0, 255);
        max = IGVMath.clamp(max, 0, 255);
        var r = Math.round(Math.random(min, max)).toString(10);
        var g = Math.round(Math.random(min, max)).toString(10);
        var b = Math.round(Math.random(min, max)).toString(10);
        return "rgb(" + r + "," + g + "," + b + ")";
      },
      randomRGBConstantAlpha: function (min, max, alpha) {
        min = IGVMath.clamp(min, 0, 255);
        max = IGVMath.clamp(max, 0, 255);
        var r = Math.round(Math.random(min, max)).toString(10);
        var g = Math.round(Math.random(min, max)).toString(10);
        var b = Math.round(Math.random(min, max)).toString(10);
        return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
      },
      addAlpha: function (color, alpha) {
        if (color === "0" || color === ".") {
          color = "rgb(0,0,0)";
        } else {
          const c = this.colorNameToHex(color);

          if (c) {
            color = c;
          }
        }

        var isHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);

        if (color.startsWith("rgba")) {
          const idx = color.lastIndexOf(",");
          return color.substring(0, idx + 1) + alpha.toString() + ")";
        }

        if (isHex) {
          color = IGVColor.hexToRgb(color);
        }

        if (color.startsWith("rgb")) {
          return color.replace("rgb", "rgba").replace(")", ", " + alpha + ")");
        } else {
          console.log(color + " is not an rgb style string");
          return color;
        }
      },
      rgbComponents: function (color) {
        if (color === "0" || color === ".") {
          return [0, 0, 0];
        }

        const isHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);

        if (isHex) {
          color = IGVColor.hexToRgb(color);
        } else {
          if (!color.startsWith("rgb")) {
            const hex = this.colorNameToHex(color);
            color = this.hexToRgb(hex);
          }
        }

        if (color.startsWith("rgb(")) {
          return color.substring(4, color.length - 1).split(",").map(s => Number.parseInt(s.trim()));
        } else if (color.startsWith("rgba(")) {
          return color.substring(5, color.length - 1).split(",").map((s, i) => {
            s = s.trim();
            return i === 3 ? Number.parseFloat(s) : Number.parseInt(s);
          });
        } else {
          throw Error("Unrecognized color string: color");
        }
      },

      /**
       *
       * @param dest  RGB components as an array
       * @param src  RGB components as an array
       * @param alpha   alpha transparancy in the range 0-1
       * @returns {}
       */
      getCompositeColor: function (dest, src, alpha) {
        var r = Math.floor(alpha * src[0] + (1 - alpha) * dest[0]),
            g = Math.floor(alpha * src[1] + (1 - alpha) * dest[1]),
            b = Math.floor(alpha * src[2] + (1 - alpha) * dest[2]);
        return "rgb(" + r + "," + g + "," + b + ")";
      },
      createColorString: function (str) {
        // Excel will quote color strings, strip all quotes
        str = stripQuotes(str);

        if (str.includes(",")) {
          return str.startsWith("rgb") ? str : "rgb(" + str + ")";
        } else {
          return str;
        }
      },
      darkenLighten: function (color, amt) {
        let src;
        let hexColor = this.colorNameToHex(color);

        if (hexColor) {
          src = IGVColor.hexToRgb(hexColor);
        } else {
          src = color.startsWith('rgb(') ? color : IGVColor.hexToRgb(color);
        }

        const components = src.replace(")", "").substring(4).split(",");
        const r = Math.max(0, Math.min(255, Number.parseInt(components[0].trim()) + amt));
        const g = Math.max(0, Math.min(255, Number.parseInt(components[1].trim()) + amt));
        const b = Math.max(0, Math.min(255, Number.parseInt(components[2].trim()) + amt));
        return 'rgb(' + r.toString() + ',' + g.toString() + ',' + b.toString() + ')';
      },

      /**
       * Convert html/css color name to hex value.  Adapted from https://gist.github.com/mxfh/4719348
       * @param colorName
       * @returns {*}
       */
      colorNameToHex: function (colorName) {
        // color list from http://stackoverflow.com/q/1573053/731179  with added gray/gray
        const definedColorNames = {
          "aliceblue": "#f0f8ff",
          "antiquewhite": "#faebd7",
          "aqua": "#00ffff",
          "aquamarine": "#7fffd4",
          "azure": "#f0ffff",
          "beige": "#f5f5dc",
          "bisque": "#ffe4c4",
          "black": "#000000",
          "blanchedalmond": "#ffebcd",
          "blue": "#0000ff",
          "blueviolet": "#8a2be2",
          "brown": "#a52a2a",
          "burlywood": "#deb887",
          "cadetblue": "#5f9ea0",
          "chartreuse": "#7fff00",
          "chocolate": "#d2691e",
          "coral": "#ff7f50",
          "cornflowerblue": "#6495ed",
          "cornsilk": "#fff8dc",
          "crimson": "#dc143c",
          "cyan": "#00ffff",
          "darkblue": "#00008b",
          "darkcyan": "#008b8b",
          "darkgoldenrod": "#b8860b",
          "darkgray": "#a9a9a9",
          "darkgreen": "#006400",
          "darkkhaki": "#bdb76b",
          "darkmagenta": "#8b008b",
          "darkolivegreen": "#556b2f",
          "darkorange": "#ff8c00",
          "darkorchid": "#9932cc",
          "darkred": "#8b0000",
          "darksalmon": "#e9967a",
          "darkseagreen": "#8fbc8f",
          "darkslateblue": "#483d8b",
          "darkslategray": "#2f4f4f",
          "darkturquoise": "#00ced1",
          "darkviolet": "#9400d3",
          "deeppink": "#ff1493",
          "deepskyblue": "#00bfff",
          "dimgray": "#696969",
          "dodgerblue": "#1e90ff",
          "firebrick": "#b22222",
          "floralwhite": "#fffaf0",
          "forestgreen": "#228b22",
          "fuchsia": "#ff00ff",
          "gainsboro": "#dcdcdc",
          "ghostwhite": "#f8f8ff",
          "gold": "#ffd700",
          "goldenrod": "#daa520",
          "gray": "#808080",
          "green": "#008000",
          "greenyellow": "#adff2f",
          "honeydew": "#f0fff0",
          "hotpink": "#ff69b4",
          "indianred ": "#cd5c5c",
          "indigo ": "#4b0082",
          "ivory": "#fffff0",
          "khaki": "#f0e68c",
          "lavender": "#e6e6fa",
          "lavenderblush": "#fff0f5",
          "lawngreen": "#7cfc00",
          "lemonchiffon": "#fffacd",
          "lightblue": "#add8e6",
          "lightcoral": "#f08080",
          "lightcyan": "#e0ffff",
          "lightgoldenrodyellow": "#fafad2",
          "lightgrey": "#d3d3d3",
          "lightgreen": "#90ee90",
          "lightpink": "#ffb6c1",
          "lightsalmon": "#ffa07a",
          "lightseagreen": "#20b2aa",
          "lightskyblue": "#87cefa",
          "lightslategray": "#778899",
          "lightsteelblue": "#b0c4de",
          "lightyellow": "#ffffe0",
          "lime": "#00ff00",
          "limegreen": "#32cd32",
          "linen": "#faf0e6",
          "magenta": "#ff00ff",
          "maroon": "#800000",
          "mediumaquamarine": "#66cdaa",
          "mediumblue": "#0000cd",
          "mediumorchid": "#ba55d3",
          "mediumpurple": "#9370d8",
          "mediumseagreen": "#3cb371",
          "mediumslateblue": "#7b68ee",
          "mediumspringgreen": "#00fa9a",
          "mediumturquoise": "#48d1cc",
          "mediumvioletred": "#c71585",
          "midnightblue": "#191970",
          "mintcream": "#f5fffa",
          "mistyrose": "#ffe4e1",
          "moccasin": "#ffe4b5",
          "navajowhite": "#ffdead",
          "navy": "#000080",
          "oldlace": "#fdf5e6",
          "olive": "#808000",
          "olivedrab": "#6b8e23",
          "orange": "#ffa500",
          "orangered": "#ff4500",
          "orchid": "#da70d6",
          "palegoldenrod": "#eee8aa",
          "palegreen": "#98fb98",
          "paleturquoise": "#afeeee",
          "palevioletred": "#d87093",
          "papayawhip": "#ffefd5",
          "peachpuff": "#ffdab9",
          "peru": "#cd853f",
          "pink": "#ffc0cb",
          "plum": "#dda0dd",
          "powderblue": "#b0e0e6",
          "purple": "#800080",
          "red": "#ff0000",
          "rosybrown": "#bc8f8f",
          "royalblue": "#4169e1",
          "saddlebrown": "#8b4513",
          "salmon": "#fa8072",
          "sandybrown": "#f4a460",
          "seagreen": "#2e8b57",
          "seashell": "#fff5ee",
          "sienna": "#a0522d",
          "silver": "#c0c0c0",
          "skyblue": "#87ceeb",
          "slateblue": "#6a5acd",
          "slategray": "#708090",
          "snow": "#fffafa",
          "springgreen": "#00ff7f",
          "steelblue": "#4682b4",
          "tan": "#d2b48c",
          "teal": "#008080",
          "thistle": "#d8bfd8",
          "tomato": "#ff6347",
          "turquoise": "#40e0d0",
          "violet": "#ee82ee",
          "wheat": "#f5deb3",
          "white": "#ffffff",
          "whitesmoke": "#f5f5f5",
          "yellow": "#ffff00",
          "yellowgreen": "#9acd32",
          "darkgrey": "#a9a9a9",
          "darkslategrey": "#2f4f4f",
          "dimgrey": "#696969",
          "grey": "#808080",
          "lightgray": "#d3d3d3",
          "lightslategrey": "#778899",
          "slategrey": "#708090"
        };
        return definedColorNames[colorName];
      }
    };

    /**
     * Make the target element movable by clicking and dragging on the handle.  This is not a general purprose function,
     * it makes several options specific to igv dialogs, the primary one being that the
     * target is absolutely positioned in pixel coordinates

     */
    let dragData$1; // Its assumed we are only dragging one element at a time.

    function makeDraggable$1(target, handle) {
      handle.addEventListener('mousedown', dragStart$1.bind(target));
    }

    function dragStart$1(event) {
      event.stopPropagation();
      event.preventDefault();
      offset$1(this);
      const dragFunction = drag$1.bind(this);
      const dragEndFunction = dragEnd$1.bind(this);
      const computedStyle = getComputedStyle(this);
      const top = parseInt(computedStyle.top.replace("px", ""));
      const left = parseInt(computedStyle.left.replace("px", ""));
      dragData$1 = {
        dragFunction: dragFunction,
        dragEndFunction: dragEndFunction,
        screenX: event.screenX,
        screenY: event.screenY,
        top: top,
        left: left
      };
      document.addEventListener('mousemove', dragFunction);
      document.addEventListener('mouseup', dragEndFunction);
      document.addEventListener('mouseleave', dragEndFunction);
      document.addEventListener('mouseexit', dragEndFunction);
    }

    function drag$1(event) {
      if (!dragData$1) {
        console.log("No drag data!");
        return;
      }

      event.stopPropagation();
      event.preventDefault();
      const dx = event.screenX - dragData$1.screenX;
      const dy = event.screenY - dragData$1.screenY;
      this.style.left = `${dragData$1.left + dx}px`;
      this.style.top = `${dragData$1.top + dy}px`;
    }

    function dragEnd$1(event) {
      if (!dragData$1) {
        console.log("No drag data!");
        return;
      }

      event.stopPropagation();
      event.preventDefault();
      const dragFunction = dragData$1.dragFunction;
      const dragEndFunction = dragData$1.dragEndFunction;
      document.removeEventListener('mousemove', dragFunction);
      document.removeEventListener('mouseup', dragEndFunction);
      document.removeEventListener('mouseleave', dragEndFunction);
      document.removeEventListener('mouseexit', dragEndFunction);
      dragData$1 = undefined;
    }

    const colorPalettes = {
      Set1: ["rgb(228,26,28)", "rgb(55,126,184)", "rgb(77,175,74)", "rgb(166,86,40)", "rgb(152,78,163)", "rgb(255,127,0)", "rgb(247,129,191)", "rgb(153,153,153)", "rgb(255,255,51)"],
      Dark2: ["rgb(27,158,119)", "rgb(217,95,2)", "rgb(117,112,179)", "rgb(231,41,138)", "rgb(102,166,30)", "rgb(230,171,2)", "rgb(166,118,29)", "rgb(102,102,102)"],
      Set2: ["rgb(102, 194,165)", "rgb(252,141,98)", "rgb(141,160,203)", "rgb(231,138,195)", "rgb(166,216,84)", "rgb(255,217,47)", "rgb(229,196,148)", "rgb(179,179,179)"],
      Set3: ["rgb(141,211,199)", "rgb(255,255,179)", "rgb(190,186,218)", "rgb(251,128,114)", "rgb(128,177,211)", "rgb(253,180,98)", "rgb(179,222,105)", "rgb(252,205,229)", "rgb(217,217,217)", "rgb(188,128,189)", "rgb(204,235,197)", "rgb(255,237,111)"],
      Pastel1: ["rgb(251,180,174)", "rgb(179,205,227)", "rgb(204,235,197)", "rgb(222,203,228)", "rgb(254,217,166)", "rgb(255,255,204)", "rgb(229,216,189)", "rgb(253,218,236)"],
      Pastel2: ["rgb(173,226,207)", "rgb(253,205,172)", "rgb(203,213,232)", "rgb(244,202,228)", "rgb(230,245,201)", "rgb(255,242,174)", "rgb(243,225,206)"],
      Accent: ["rgb(127,201,127)", "rgb(190,174,212)", "rgb(253,192,134)", "rgb(255,255,153)", "rgb(56,108,176)", "rgb(240,2,127)", "rgb(191,91,23)"]
    };

    function PaletteColorTable(palette) {
      this.colors = colorPalettes[palette];
      if (!Array.isArray(this.colors)) this.colors = [];
      this.colorTable = {};
      this.nextIdx = 0;
      this.colorGenerator = new RandomColorGenerator();
    }

    PaletteColorTable.prototype.getColor = function (key) {
      if (!this.colorTable.hasOwnProperty(key)) {
        if (this.nextIdx < this.colors.length) {
          this.colorTable[key] = this.colors[this.nextIdx];
        } else {
          this.colorTable[key] = this.colorGenerator.get();
        }

        this.nextIdx++;
      }

      return this.colorTable[key];
    }; // Random color generator from https://github.com/sterlingwes/RandomColor/blob/master/rcolor.js
    // Free to use & distribute under the MIT license
    // Wes Johnson (@SterlingWes)
    //
    // inspired by http://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/


    function RandomColorGenerator() {
      this.hue = Math.random();
      this.goldenRatio = 0.618033988749895;
      this.hexwidth = 2;
    }

    RandomColorGenerator.prototype.hsvToRgb = function (h, s, v) {
      var h_i = Math.floor(h * 6),
          f = h * 6 - h_i,
          p = v * (1 - s),
          q = v * (1 - f * s),
          t = v * (1 - (1 - f) * s),
          r = 255,
          g = 255,
          b = 255;

      switch (h_i) {
        case 0:
          r = v, g = t, b = p;
          break;

        case 1:
          r = q, g = v, b = p;
          break;

        case 2:
          r = p, g = v, b = t;
          break;

        case 3:
          r = p, g = q, b = v;
          break;

        case 4:
          r = t, g = p, b = v;
          break;

        case 5:
          r = v, g = p, b = q;
          break;
      }

      return [Math.floor(r * 256), Math.floor(g * 256), Math.floor(b * 256)];
    };

    RandomColorGenerator.prototype.padHex = function (str) {
      if (str.length > this.hexwidth) return str;
      return new Array(this.hexwidth - str.length + 1).join('0') + str;
    };

    RandomColorGenerator.prototype.get = function (saturation, value) {
      this.hue += this.goldenRatio;
      this.hue %= 1;
      if (typeof saturation !== "number") saturation = 0.5;
      if (typeof value !== "number") value = 0.95;
      var rgb = this.hsvToRgb(this.hue, saturation, value);
      return "#" + this.padHex(rgb[0].toString(16)) + this.padHex(rgb[1].toString(16)) + this.padHex(rgb[2].toString(16));
    }; // Returns a random number between min (inclusive) and max (exclusive)

    // Support for oauth token based authorization
    // This class supports explicit setting of an oauth token either globally or for specific hosts.
    //
    // The variable oauth.google.access_token, which becomes igv.oauth.google.access_token on ES5 conversion is
    // supported for backward compatibility
    const DEFAULT_HOST = "googleapis";
    const oauth = {
      oauthTokens: {},
      setToken: function (token, host) {
        host = host || DEFAULT_HOST;
        this.oauthTokens[host] = token;

        if (host === DEFAULT_HOST) {
          this.google.access_token = token; // legacy support
        }
      },
      getToken: function (host) {
        host = host || DEFAULT_HOST;
        let token;

        for (let key of Object.keys(this.oauthTokens)) {
          const regex = wildcardToRegExp(key);

          if (regex.test(host)) {
            token = this.oauthTokens[key];
            break;
          }
        }

        return token;
      },
      removeToken: function (host) {
        host = host || DEFAULT_HOST;

        for (let key of Object.keys(this.oauthTokens)) {
          const regex = wildcardToRegExp(key);

          if (regex.test(host)) {
            this.oauthTokens[key] = undefined;
          }
        }

        if (host === DEFAULT_HOST) {
          this.google.access_token = undefined; // legacy support
        }
      },
      // Special object for google -- legacy support
      google: {
        setToken: function (token) {
          oauth.setToken(token);
        }
      }
    };
    /**
     * Creates a RegExp from the given string, converting asterisks to .* expressions,
     * and escaping all other characters.
     *
     * credit https://gist.github.com/donmccurdy/6d073ce2c6f3951312dfa45da14a420f
     */

    function wildcardToRegExp(s) {
      return new RegExp('^' + s.split(/\*+/).map(regExpEscape).join('.*') + '$');
    }
    /**
     * RegExp-escapes all characters in the given string.
     *
     * credit https://gist.github.com/donmccurdy/6d073ce2c6f3951312dfa45da14a420f
     */


    function regExpEscape(s) {
      return s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
    }

    // The MIT License (MIT)
    /**
     * @constructor
     * @param {Object} options A set op options to pass to the throttle function
     *        @param {number} requestsPerSecond The amount of requests per second
     *                                          the library will limit to
     */

    class Throttle$1 {
      constructor(options) {
        this.requestsPerSecond = options.requestsPerSecond || 10;
        this.lastStartTime = 0;
        this.queued = [];
      }
      /**
       * Adds a promise
       * @param {Function} async function to be executed
       * @param {Object} options A set of options.
       * @return {Promise} A promise
       */


      add(asyncFunction, options) {
        var self = this;
        return new Promise(function (resolve, reject) {
          self.queued.push({
            resolve: resolve,
            reject: reject,
            asyncFunction: asyncFunction
          });
          self.dequeue();
        });
      }
      /**
       * Adds all the promises passed as parameters
       * @param {Function} promises An array of functions that return a promise
       * @param {Object} options A set of options.
       * @param {number} options.signal An AbortSignal object that can be used to abort the returned promise
       * @param {number} options.weight A "weight" of each operation resolving by array of promises
       * @return {Promise} A promise that succeeds when all the promises passed as options do
       */


      addAll(promises, options) {
        var addedPromises = promises.map(function (promise) {
          return this.add(promise, options);
        }.bind(this));
        return Promise.all(addedPromises);
      }

      /**
       * Dequeues a promise
       * @return {void}
       */
      dequeue() {
        if (this.queued.length > 0) {
          var now = new Date(),
              inc = 1000 / this.requestsPerSecond + 1,
              elapsed = now - this.lastStartTime;

          if (elapsed >= inc) {
            this._execute();
          } else {
            // we have reached the limit, schedule a dequeue operation
            setTimeout(function () {
              this.dequeue();
            }.bind(this), inc - elapsed);
          }
        }
      }
      /**
       * Executes the promise
       * @private
       * @return {void}
       */


      async _execute() {
        this.lastStartTime = new Date();
        var candidate = this.queued.shift();
        const f = candidate.asyncFunction;

        try {
          const r = await f();
          candidate.resolve(r);
        } catch (e) {
          candidate.reject(e);
        }
      }

    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var NONE = 0;
    var GZIP = 1;
    var BGZF = 2;
    var UNKNOWN = 3;
    let RANGE_WARNING_GIVEN = false;
    const googleThrottle = new Throttle$1({
      requestsPerSecond: 8
    });
    const igvxhr = {
      apiKey: undefined,
      setApiKey: function (key) {
        this.apiKey = key;
      },
      load: load,
      loadArrayBuffer: async function (url, options) {
        options = options || {};

        if (!options.responseType) {
          options.responseType = "arraybuffer";
        }

        if (url instanceof File) {
          return loadFileSlice(url, options);
        } else {
          return load(url, options);
        }
      },
      loadJson: async function (url, options) {
        options = options || {};
        const method = options.method || (options.sendData ? "POST" : "GET");

        if (method === "POST") {
          options.contentType = "application/json";
        }

        const result = await this.loadString(url, options);

        if (result) {
          return JSON.parse(result);
        } else {
          return result;
        }
      },
      loadString: async function (path, options) {
        options = options || {};

        if (path instanceof File) {
          return loadStringFromFile(path, options);
        } else {
          return loadStringFromUrl(path, options);
        }
      }
    };

    async function load(url, options) {
      options = options || {};
      const urlType = typeof url; // Resolve functions, promises, and functions that return promises

      url = await (typeof url === 'function' ? url() : url);

      if (url instanceof File) {
        return loadFileSlice(url, options);
      } else if (typeof url.startsWith === 'function') {
        // Test for string
        if (url.startsWith("data:")) {
          return decodeDataURI(url);
        } else {
          if (url.startsWith("https://drive.google.com")) {
            url = driveDownloadURL(url);
          }

          if (isGoogleDriveURL(url) || url.startsWith("https://www.dropbox.com")) {
            return googleThrottle.add(async function () {
              return loadURL(url, options);
            });
          } else {
            return loadURL(url, options);
          }
        }
      } else {
        throw Error(`url must be either a 'File', 'string', 'function', or 'Promise'.  Actual type: ${urlType}`);
      }
    }

    async function loadURL(url, options) {
      //console.log(`${Date.now()}   ${url}`)
      url = mapUrl$1(url);
      options = options || {};
      let oauthToken = options.oauthToken || getOauthToken(url);

      if (oauthToken) {
        oauthToken = await (typeof oauthToken === 'function' ? oauthToken() : oauthToken);
      }

      return new Promise(function (resolve, reject) {
        // Various Google tansformations
        if (isGoogleURL(url)) {
          if (url.startsWith("gs://")) {
            url = translateGoogleCloudURL(url);
          } else if (isGoogleStorageURL(url)) {
            if (!url.includes("altMedia=")) {
              url += url.includes("?") ? "&altMedia=true" : "?altMedia=true";
            }
          }

          url = addApiKey(url);

          if (isGoogleDriveURL(url)) {
            addTeamDrive(url);
          } // If we have an access token try it, but don't force a signIn or request for scopes yet


          if (!oauthToken) {
            oauthToken = getCurrentGoogleAccessToken();
          }
        }

        const headers = options.headers || {};

        if (oauthToken) {
          addOauthHeaders(headers, oauthToken);
        }

        const range = options.range;
        const isChrome = navigator.userAgent.indexOf('Chrome') > -1;
        navigator.vendor.indexOf("Apple") === 0 && /\sSafari\//.test(navigator.userAgent);

        if (range && isChrome && !isAmazonV4Signed(url)) {
          // Hack to prevent caching for byte-ranges. Attempt to fix net:err-cache errors in Chrome
          url += url.includes("?") ? "&" : "?";
          url += "someRandomSeed=" + Math.random().toString(36);
        }

        const xhr = new XMLHttpRequest();
        const sendData = options.sendData || options.body;
        const method = options.method || (sendData ? "POST" : "GET");
        const responseType = options.responseType;
        const contentType = options.contentType;
        const mimeType = options.mimeType;
        xhr.open(method, url);

        if (range) {
          var rangeEnd = range.size ? range.start + range.size - 1 : "";
          xhr.setRequestHeader("Range", "bytes=" + range.start + "-" + rangeEnd); //      xhr.setRequestHeader("Cache-Control", "no-cache");    <= This can cause CORS issues, disabled for now
        }

        if (contentType) {
          xhr.setRequestHeader("Content-Type", contentType);
        }

        if (mimeType) {
          xhr.overrideMimeType(mimeType);
        }

        if (responseType) {
          xhr.responseType = responseType;
        }

        if (headers) {
          for (let key of Object.keys(headers)) {
            const value = headers[key];
            xhr.setRequestHeader(key, value);
          }
        } // NOTE: using withCredentials with servers that return "*" for access-allowed-origin will fail


        if (options.withCredentials === true) {
          xhr.withCredentials = true;
        }

        xhr.onload = async function (event) {
          // when the url points to a local file, the status is 0 but that is not an error
          if (xhr.status === 0 || xhr.status >= 200 && xhr.status <= 300) {
            if (range && xhr.status !== 206 && range.start !== 0) {
              // For small files a range starting at 0 can return the whole file => 200
              // Provide just the slice we asked for, throw out the rest quietly
              // If file is large warn user
              if (xhr.response.length > 100000 && !RANGE_WARNING_GIVEN) {
                alert(`Warning: Range header ignored for URL: ${url}.  This can have performance impacts.`);
              }

              resolve(xhr.response.slice(range.start, range.start + range.size));
            } else {
              resolve(xhr.response);
            }
          } else if (typeof gapi !== "undefined" && (xhr.status === 404 || xhr.status === 401 || xhr.status === 403) && isGoogleURL(url) && !options.retries) {
            tryGoogleAuth();
          } else {
            if (xhr.status === 403) {
              handleError("Access forbidden: " + url);
            } else if (xhr.status === 416) {
              //  Tried to read off the end of the file.   This shouldn't happen, but if it does return an
              handleError("Unsatisfiable range");
            } else {
              handleError(xhr.status);
            }
          }
        };

        xhr.onerror = function (event) {
          if (isGoogleURL(url) && !options.retries) {
            tryGoogleAuth();
          }

          handleError("Error accessing resource: " + url + " Status: " + xhr.status);
        };

        xhr.ontimeout = function (event) {
          handleError("Timed out");
        };

        xhr.onabort = function (event) {
          console.log("Aborted");
          reject(event);
        };

        try {
          xhr.send(sendData);
        } catch (e) {
          reject(e);
        }

        function handleError(error) {
          if (reject) {
            reject(error);
          } else {
            throw error;
          }
        }

        async function tryGoogleAuth() {
          try {
            const accessToken = await fetchGoogleAccessToken(url);
            options.retries = 1;
            options.oauthToken = accessToken;
            const response = await load(url, options);
            resolve(response);
          } catch (e) {
            if (e.error) {
              const msg = e.error.startsWith("popup_blocked") ? "Google login popup blocked by browser." : e.error;
              alert(msg);
            } else {
              handleError(e);
            }
          }
        }
      });
    }

    async function loadFileSlice(localfile, options) {
      let blob = options && options.range ? localfile.slice(options.range.start, options.range.start + options.range.size) : localfile;

      if ("arraybuffer" === options.responseType) {
        return blobToArrayBuffer(blob);
      } else {
        // binary string format, shouldn't be used anymore
        return new Promise(function (resolve, reject) {
          const fileReader = new FileReader();

          fileReader.onload = function (e) {
            resolve(fileReader.result);
          };

          fileReader.onerror = function (e) {
            console.error("reject uploading local file " + localfile.name);
            reject(null, fileReader);
          };

          fileReader.readAsBinaryString(blob);
          console.warn("Deprecated method used: readAsBinaryString");
        });
      }
    }

    async function loadStringFromFile(localfile, options) {
      const blob = options.range ? localfile.slice(options.range.start, options.range.start + options.range.size) : localfile;
      let compression = NONE;

      if (options && options.bgz || localfile.name.endsWith(".bgz")) {
        compression = BGZF;
      } else if (localfile.name.endsWith(".gz")) {
        compression = GZIP;
      }

      if (compression === NONE) {
        return blobToText(blob);
      } else {
        const arrayBuffer = await blobToArrayBuffer(blob);
        return arrayBufferToString(arrayBuffer, compression);
      }
    }

    async function blobToArrayBuffer(blob) {
      if (typeof blob.arrayBuffer === 'function') {
        return blob.arrayBuffer();
      }

      return new Promise(function (resolve, reject) {
        const fileReader = new FileReader();

        fileReader.onload = function (e) {
          resolve(fileReader.result);
        };

        fileReader.onerror = function (e) {
          console.error("reject uploading local file " + localfile.name);
          reject(null, fileReader);
        };

        fileReader.readAsArrayBuffer(blob);
      });
    }

    async function blobToText(blob) {
      if (typeof blob.text === 'function') {
        return blob.text();
      }

      return new Promise(function (resolve, reject) {
        const fileReader = new FileReader();

        fileReader.onload = function (e) {
          resolve(fileReader.result);
        };

        fileReader.onerror = function (e) {
          console.error("reject uploading local file " + localfile.name);
          reject(null, fileReader);
        };

        fileReader.readAsText(blob);
      });
    }

    async function loadStringFromUrl(url, options) {
      options = options || {};
      const fn = options.filename || (await getFilename$1(url));
      let compression = UNKNOWN;

      if (options.bgz) {
        compression = BGZF;
      } else if (fn.endsWith(".gz")) {
        compression = GZIP;
      }

      options.responseType = "arraybuffer";
      const data = await igvxhr.load(url, options);
      return arrayBufferToString(data, compression);
    }

    function isAmazonV4Signed(url) {
      return url.indexOf("X-Amz-Signature") > -1;
    }

    function getOauthToken(url) {
      // Google is the default provider, don't try to parse host for google URLs
      const host = isGoogleURL(url) ? undefined : parseUri(url).host;
      let token = oauth.getToken(host);

      if (token) {
        return token;
      } else if (host === undefined) {
        const googleToken = getCurrentGoogleAccessToken();

        if (googleToken && googleToken.expires_at > Date.now()) {
          return googleToken.access_token;
        }
      }
    }
    /**
     * Return a Google oAuth token, triggering a sign in if required.   This method should not be called until we know
     * a token is required, that is until we've tried the url and received a 401, 403, or 404.
     *
     * @param url
     * @returns the oauth token
     */


    async function fetchGoogleAccessToken(url) {
      console.log("Fetch token for " + url);

      if (isInitialized()) {
        const scope = getScopeForURL(url);
        const googleToken = await getAccessToken(scope);
        return googleToken ? googleToken.access_token : undefined;
      } else {
        throw Error(`Authorization is required, but Google oAuth has not been initalized. Contact your site administrator for assistance.`);
      }
    }
    /**
     * Return the current google access token, if one exists.  Do not triger signOn or request additional scopes.
     * @returns {undefined|access_token}
     */


    function getCurrentGoogleAccessToken() {
      if (isInitialized()) {
        const googleToken = getCurrentAccessToken();
        return googleToken ? googleToken.access_token : undefined;
      } else {
        return undefined;
      }
    }

    function addOauthHeaders(headers, acToken) {
      if (acToken) {
        headers["Cache-Control"] = "no-cache";
        headers["Authorization"] = "Bearer " + acToken;
      }

      return headers;
    }

    function addApiKey(url) {
      let apiKey = igvxhr.apiKey;

      if (!apiKey && typeof gapi !== "undefined") {
        apiKey = gapi.apiKey;
      }

      if (apiKey !== undefined && !url.includes("key=")) {
        const paramSeparator = url.includes("?") ? "&" : "?";
        url = url + paramSeparator + "key=" + apiKey;
      }

      return url;
    }

    function addTeamDrive(url) {
      if (url.includes("supportsTeamDrive")) {
        return url;
      } else {
        const paramSeparator = url.includes("?") ? "&" : "?";
        url = url + paramSeparator + "supportsTeamDrive=true";
      }
    }
    /**
     * Perform some well-known url mappings.
     * @param url
     */


    function mapUrl$1(url) {
      if (url.includes("//www.dropbox.com")) {
        return url.replace("//www.dropbox.com", "//dl.dropboxusercontent.com");
      } else if (url.includes("//drive.google.com")) {
        return driveDownloadURL(url);
      } else if (url.includes("//www.broadinstitute.org/igvdata")) {
        return url.replace("//www.broadinstitute.org/igvdata", "//data.broadinstitute.org/igvdata");
      } else if (url.includes("//igvdata.broadinstitute.org")) {
        return url.replace("//igvdata.broadinstitute.org", "https://dn7ywbm9isq8j.cloudfront.net");
      } else if (url.startsWith("ftp://ftp.ncbi.nlm.nih.gov/geo")) {
        return url.replace("ftp://", "https://");
      } else {
        return url;
      }
    }

    function arrayBufferToString(arraybuffer, compression) {
      if (compression === UNKNOWN && arraybuffer.byteLength > 2) {
        const m = new Uint8Array(arraybuffer, 0, 2);

        if (m[0] === 31 && m[1] === 139) {
          compression = GZIP;
        }
      }

      let plain;

      if (compression === GZIP) {
        const inflate = new Zlib$2.Gunzip(new Uint8Array(arraybuffer));
        plain = inflate.decompress();
      } else if (compression === BGZF) {
        plain = unbgzf(arraybuffer);
      } else {
        plain = new Uint8Array(arraybuffer);
      }

      if ('TextDecoder' in getGlobalObject()) {
        return new TextDecoder().decode(plain);
      } else {
        return decodeUTF8(plain);
      }
    }
    /**
     * Use when TextDecoder is not available (primarily IE).
     *
     * From: https://gist.github.com/Yaffle/5458286
     *
     * @param octets
     * @returns {string}
     */


    function decodeUTF8(octets) {
      var string = "";
      var i = 0;

      while (i < octets.length) {
        var octet = octets[i];
        var bytesNeeded = 0;
        var codePoint = 0;

        if (octet <= 0x7F) {
          bytesNeeded = 0;
          codePoint = octet & 0xFF;
        } else if (octet <= 0xDF) {
          bytesNeeded = 1;
          codePoint = octet & 0x1F;
        } else if (octet <= 0xEF) {
          bytesNeeded = 2;
          codePoint = octet & 0x0F;
        } else if (octet <= 0xF4) {
          bytesNeeded = 3;
          codePoint = octet & 0x07;
        }

        if (octets.length - i - bytesNeeded > 0) {
          var k = 0;

          while (k < bytesNeeded) {
            octet = octets[i + k + 1];
            codePoint = codePoint << 6 | octet & 0x3F;
            k += 1;
          }
        } else {
          codePoint = 0xFFFD;
          bytesNeeded = octets.length - i;
        }

        string += String.fromCodePoint(codePoint);
        i += bytesNeeded + 1;
      }

      return string;
    }

    function getGlobalObject() {
      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof global !== 'undefined') {
        return global;
      } else {
        return window;
      }
    }

    async function getFilename$1(url) {
      if (isString$2(url) && url.startsWith("https://drive.google.com")) {
        // This will fail if Google API key is not defined
        if (getApiKey() === undefined) {
          throw Error("Google drive is referenced, but API key is not defined.  An API key is required for Google Drive access");
        }

        const json = await getDriveFileInfo(url);
        return json.originalFileName || json.name;
      } else {
        return getFilename$2(url);
      }
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /** An implementation of an interval tree, following the explanation.
     * from CLR.
     *
     * Public interface:
     *   Constructor  IntervalTree
     *   Insertion    insert
     *   Search       findOverlapping
     */
    var BLACK = 1;
    var RED = 2;
    var NIL = {};
    NIL.color = BLACK;
    NIL.parent = NIL;
    NIL.left = NIL;
    NIL.right = NIL;

    class IntervalTree {
      constructor() {
        this.root = NIL;
      }

      insert(start, end, value) {
        var interval = new Interval(start, end, value);
        var x = new Node$1(interval);
        this.treeInsert(x);
        x.color = RED;

        while (x !== this.root && x.parent.color === RED) {
          if (x.parent === x.parent.parent.left) {
            let y = x.parent.parent.right;

            if (y.color === RED) {
              x.parent.color = BLACK;
              y.color = BLACK;
              x.parent.parent.color = RED;
              x = x.parent.parent;
            } else {
              if (x === x.parent.right) {
                x = x.parent;
                leftRotate.call(this, x);
              }

              x.parent.color = BLACK;
              x.parent.parent.color = RED;
              rightRotate.call(this, x.parent.parent);
            }
          } else {
            let y = x.parent.parent.left;

            if (y.color === RED) {
              x.parent.color = BLACK;
              y.color = BLACK;
              x.parent.parent.color = RED;
              x = x.parent.parent;
            } else {
              if (x === x.parent.left) {
                x = x.parent;
                rightRotate.call(this, x);
              }

              x.parent.color = BLACK;
              x.parent.parent.color = RED;
              leftRotate.call(this, x.parent.parent);
            }
          }
        }

        this.root.color = BLACK;
      }
      /**
       *
       * @param start - query interval
       * @param end - query interval
       * @returns Array of all intervals overlapping the query region
       */


      findOverlapping(start, end) {
        var searchInterval = new Interval(start, end, 0);
        if (this.root === NIL) return [];
        var intervals = searchAll.call(this, searchInterval, this.root, []);

        if (intervals.length > 1) {
          intervals.sort(function (i1, i2) {
            return i1.low - i2.low;
          });
        }

        return intervals;
      }
      /**
       * Dump info on intervals to console.  For debugging.
       */


      logIntervals() {
        logNode(this.root, 0);

        function logNode(node, indent) {
          var space = "";

          for (var i = 0; i < indent; i++) space += " ";

          console.log(space + node.interval.low + " " + node.interval.high); // + " " + (node.interval.value ? node.interval.value : " null"));

          indent += 5;
          if (node.left !== NIL) logNode(node.left, indent);
          if (node.right !== NIL) logNode(node.right, indent);
        }
      }

      mapIntervals(func) {
        applyInterval(this.root);

        function applyInterval(node) {
          func(node.interval);
          if (node.left !== NIL) applyInterval(node.left);
          if (node.right !== NIL) applyInterval(node.right);
        }
      }
      /**
       * Note:  Does not maintain RB constraints,  this is done post insert
       *
       * @param x  a Node
       */


      treeInsert(x) {
        var node = this.root;
        var y = NIL;

        while (node !== NIL) {
          y = node;

          if (x.interval.low <= node.interval.low) {
            node = node.left;
          } else {
            node = node.right;
          }
        }

        x.parent = y;

        if (y === NIL) {
          this.root = x;
          x.left = x.right = NIL;
        } else {
          if (x.interval.low <= y.interval.low) {
            y.left = x;
          } else {
            y.right = x;
          }
        }

        applyUpdate.call(this, x);
      }

    }

    function searchAll(interval, node, results) {
      if (node.interval.overlaps(interval)) {
        results.push(node.interval);
      }

      if (node.left !== NIL && node.left.max >= interval.low) {
        searchAll.call(this, interval, node.left, results);
      }

      if (node.right !== NIL && node.right.min <= interval.high) {
        searchAll.call(this, interval, node.right, results);
      }

      return results;
    }

    function leftRotate(x) {
      var y = x.right;
      x.right = y.left;

      if (y.left !== NIL) {
        y.left.parent = x;
      }

      y.parent = x.parent;

      if (x.parent === NIL) {
        this.root = y;
      } else {
        if (x.parent.left === x) {
          x.parent.left = y;
        } else {
          x.parent.right = y;
        }
      }

      y.left = x;
      x.parent = y;
      applyUpdate.call(this, x); // no need to apply update on y, since it'll y is an ancestor
      // of x, and will be touched by applyUpdate().
    }

    function rightRotate(x) {
      var y = x.left;
      x.left = y.right;

      if (y.right !== NIL) {
        y.right.parent = x;
      }

      y.parent = x.parent;

      if (x.parent === NIL) {
        this.root = y;
      } else {
        if (x.parent.right === x) {
          x.parent.right = y;
        } else {
          x.parent.left = y;
        }
      }

      y.right = x;
      x.parent = y;
      applyUpdate.call(this, x); // no need to apply update on y, since it'll y is an ancestor
      // of x, and will be touched by applyUpdate().
    } // Applies the statistic update on the node and its ancestors.


    function applyUpdate(node) {
      while (node !== NIL) {
        var nodeMax = node.left.max > node.right.max ? node.left.max : node.right.max;
        var intervalHigh = node.interval.high;
        node.max = nodeMax > intervalHigh ? nodeMax : intervalHigh;
        var nodeMin = node.left.min < node.right.min ? node.left.min : node.right.min;
        var intervalLow = node.interval.low;
        node.min = nodeMin < intervalLow ? nodeMin : intervalLow;
        node = node.parent;
      }
    }

    class Interval {
      constructor(low, high, value) {
        this.low = low;
        this.high = high;
        this.value = value;
      }

      equals(other) {
        if (!other) {
          return false;
        }

        if (this === other) {
          return true;
        }

        return this.low === other.low && this.high === other.high;
      }

      compareTo(other) {
        if (this.low < other.low) return -1;
        if (this.low > other.low) return 1;
        if (this.high < other.high) return -1;
        if (this.high > other.high) return 1;
        return 0;
      }
      /**
       * Returns true if this interval overlaps the other.
       */


      overlaps(other) {
        return this.low <= other.high && other.low <= this.high;
      }

    }

    function Node$1(interval) {
      this.parent = NIL;
      this.left = NIL;
      this.right = NIL;
      this.interval = interval;
      this.color = RED;
    } //

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Object for caching lists of features.  Supports effecient queries for sub-range  (chr, start, end)
     *
     * @param featureList
     * @param The genomic range spanned by featureList (optional)
     * @constructor
     */

    class FeatureCache {
      constructor(featureList, genome, range) {
        this.treeMap = this.buildTreeMap(featureList, genome);
        this.range = range;
        this.count = featureList.length;
      }

      containsRange(genomicRange) {
        // No range means cache contains all features
        return this.range === undefined || this.range.contains(genomicRange.chr, genomicRange.start, genomicRange.end);
      }

      queryFeatures(chr, start, end) {
        const tree = this.treeMap[chr];
        if (!tree) return [];
        const intervals = tree.findOverlapping(start, end);

        if (intervals.length === 0) {
          return [];
        } else {
          // Trim the list of features in the intervals to those
          // overlapping the requested range.
          // Assumption: features are sorted by start position
          const featureList = [];
          const all = this.allFeatures[chr];

          if (all) {
            for (let interval of intervals) {
              const indexRange = interval.value;

              for (let i = indexRange.start; i < indexRange.end; i++) {
                let feature = all[i];
                if (feature.start > end) break;else if (feature.end >= start) {
                  featureList.push(feature);
                }
              }
            }

            featureList.sort(function (a, b) {
              return a.start - b.start;
            });
          }

          return featureList;
        }
      }

      /**
       * Returns all features, unsorted.
       *
       * @returns {Array}
       */
      getAllFeatures() {
        return this.allFeatures;
      }

      buildTreeMap(featureList, genome) {
        const treeMap = {};
        const chromosomes = [];
        this.allFeatures = {};

        if (featureList) {
          for (let feature of featureList) {
            let chr = feature.chr; // Translate to "official" name

            if (genome) {
              chr = genome.getChromosomeName(chr);
            }

            let geneList = this.allFeatures[chr];

            if (!geneList) {
              chromosomes.push(chr);
              geneList = [];
              this.allFeatures[chr] = geneList;
            }

            geneList.push(feature);
          } // Now build interval tree for each chromosome


          for (let chr of chromosomes) {
            const chrFeatures = this.allFeatures[chr];
            chrFeatures.sort(function (f1, f2) {
              return f1.start === f2.start ? 0 : f1.start > f2.start ? 1 : -1;
            });
            treeMap[chr] = buildIntervalTree$1(chrFeatures);
          }
        }

        return treeMap;
      }

    }
    /**
     * Build an interval tree from the feature list for fast interval based queries.   We lump features in groups
     * of 10, or total size / 100,   to reduce size of the tree.
     *
     * @param featureList
     */


    function buildIntervalTree$1(featureList) {
      const tree = new IntervalTree();
      const len = featureList.length;
      const chunkSize = Math.max(10, Math.round(len / 10));

      for (let i = 0; i < len; i += chunkSize) {
        const e = Math.min(len, i + chunkSize);
        const subArray = new IndexRange(i, e); //featureList.slice(i, e);

        const iStart = featureList[i].start; //

        let iEnd = iStart;

        for (let j = i; j < e; j++) {
          iEnd = Math.max(iEnd, featureList[j].end);
        }

        tree.insert(iStart, iEnd, subArray);
      }

      return tree;
    }

    class IndexRange {
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }

    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     * Author: Jim Robinson
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    const FeatureUtils = {
      packFeatures: function (features, maxRows, sorted) {
        var start;
        var end;
        if (!features) return;
        maxRows = maxRows || 10000;

        if (!sorted) {
          features.sort(function (a, b) {
            return a.start - b.start;
          });
        }

        if (features.length === 0) {
          return [];
        } else {
          var bucketList = [],
              allocatedCount = 0,
              lastAllocatedCount = 0,
              nextStart,
              row,
              index,
              bucket,
              feature,
              gap = 2,
              bucketStart;
          start = features[0].start;
          end = features[features.length - 1].start;
          bucketStart = Math.max(start, features[0].start);
          nextStart = bucketStart;
          features.forEach(function (alignment) {
            var buckListIndex = Math.max(0, alignment.start - bucketStart);

            if (bucketList[buckListIndex] === undefined) {
              bucketList[buckListIndex] = [];
            }

            bucketList[buckListIndex].push(alignment);
          });
          row = 0;

          while (allocatedCount < features.length && row <= maxRows) {
            while (nextStart <= end) {
              bucket = undefined;

              while (!bucket && nextStart <= end) {
                index = nextStart - bucketStart;

                if (bucketList[index] === undefined) {
                  ++nextStart; // No buckets at this index
                } else {
                  bucket = bucketList[index];
                }
              } // while (bucket)


              if (!bucket) {
                break;
              }

              feature = bucket.pop();

              if (0 === bucket.length) {
                bucketList[index] = undefined;
              }

              feature.row = row;
              nextStart = feature.end + gap;
              ++allocatedCount;
            } // while (nextStart)


            row++;
            nextStart = bucketStart;
            if (allocatedCount === lastAllocatedCount) break; // Protect from infinite loops

            lastAllocatedCount = allocatedCount;
          } // while (allocatedCount)

        }
      },

      /**
       * Find features overlapping the given interval.  It is assumed that all features share the same chromosome.
       *
       * TODO -- significant overlap with FeatureCache, refactor to combine
       *
       * @param featureList
       * @param start
       * @param end
       */
      findOverlapping: function (featureList, start, end) {
        if (!featureList || featureList.length === 0) {
          return [];
        } else {
          const tree = buildIntervalTree(featureList);
          const intervals = tree.findOverlapping(start, end);

          if (intervals.length === 0) {
            return [];
          } else {
            // Trim the list of features in the intervals to those
            // overlapping the requested range.
            // Assumption: features are sorted by start position
            featureList = [];
            intervals.forEach(function (interval) {
              const intervalFeatures = interval.value;
              const len = intervalFeatures.length;

              for (let i = 0; i < len; i++) {
                const feature = intervalFeatures[i];
                if (feature.start > end) break;else if (feature.end > start) {
                  featureList.push(feature);
                }
              }
            });
            featureList.sort(function (a, b) {
              return a.start - b.start;
            });
            return featureList;
          }
        }
      }
    };
    /**
     * Build an interval tree from the feature list for fast interval based queries.   We lump features in groups
     * of 10, or total size / 100,   to reduce size of the tree.
     *
     * @param featureList
     */

    function buildIntervalTree(featureList) {
      const tree = new IntervalTree();
      const len = featureList.length;
      const chunkSize = Math.max(10, Math.round(len / 100));
      featureList.sort(function (f1, f2) {
        return f1.start === f2.start ? 0 : f1.start > f2.start ? 1 : -1;
      });

      for (let i = 0; i < len; i += chunkSize) {
        const e = Math.min(len, i + chunkSize);
        const subArray = featureList.slice(i, e);
        const iStart = subArray[0].start;
        let iEnd = iStart;
        subArray.forEach(function (feature) {
          iEnd = Math.max(iEnd, feature.end);
        });
        tree.insert(iStart, iEnd, subArray);
      }

      return tree;
    }

    /*!
     * jQuery JavaScript Library v3.3.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/parseXML,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-event/ajax,-effects,-effects/Tween,-effects/animatedSelector
     * https://jquery.com/
     *
     * Includes Sizzle.js
     * https://sizzlejs.com/
     *
     * Copyright JS Foundation and other contributors
     * Released under the MIT license
     * https://jquery.org/license
     *
     * Date: 2018-01-20T17:24Z
     */

    var arr = [];
    var document$2 = window.document;
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString$2 = class2type.toString;
    var hasOwn$6 = class2type.hasOwnProperty;
    var fnToString = hasOwn$6.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};

    var isFunction = function isFunction(obj) {
      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
    };

    var isWindow = function isWindow(obj) {
      return obj != null && obj === obj.window;
    };

    var preservedScriptAttributes = {
      type: true,
      src: true,
      noModule: true
    };

    function DOMEval(code, doc, node) {
      doc = doc || document$2;
      var i,
          script = doc.createElement("script");
      script.text = code;

      if (node) {
        for (i in preservedScriptAttributes) {
          if (node[i]) {
            script[i] = node[i];
          }
        }
      }

      doc.head.appendChild(script).parentNode.removeChild(script);
    }

    function toType(obj) {
      if (obj == null) {
        return obj + "";
      } // Support: Android <=2.3 only (functionish RegExp)


      return typeof obj === "object" || typeof obj === "function" ? class2type[toString$2.call(obj)] || "object" : typeof obj;
    } // global Symbol
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module


    var version$2 = "3.3.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/parseXML,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-event/ajax,-effects,-effects/Tween,-effects/animatedSelector",
        // Define a local copy of jQuery
    jQuery = function (selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init(selector, context);
    },
        // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    jQuery.fn = jQuery.prototype = {
      // The current version of jQuery being used
      jquery: version$2,
      constructor: jQuery,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function () {
        return slice.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function (num) {
        // Return all the elements in a clean array
        if (num == null) {
          return slice.call(this);
        } // Return just the one element from the set


        return num < 0 ? this[num + this.length] : this[num];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function (elems) {
        // Build a new jQuery matched element set
        var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

        ret.prevObject = this; // Return the newly-formed element set

        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function (callback) {
        return jQuery.each(this, callback);
      },
      map: function (callback) {
        return this.pushStack(jQuery.map(this, function (elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function () {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function () {
        return this.eq(0);
      },
      last: function () {
        return this.eq(-1);
      },
      eq: function (i) {
        var len = this.length,
            j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function () {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push: push,
      sort: arr.sort,
      splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
      var options,
          name,
          src,
          copy,
          copyIsArray,
          clone,
          target = arguments[0] || {},
          i = 1,
          length = arguments.length,
          deep = false; // Handle a deep copy situation

      if (typeof target === "boolean") {
        deep = target; // Skip the boolean and the target

        target = arguments[i] || {};
        i++;
      } // Handle case when target is a string or something (possible in deep copy)


      if (typeof target !== "object" && !isFunction(target)) {
        target = {};
      } // Extend jQuery itself if only one argument is passed


      if (i === length) {
        target = this;
        i--;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
          // Extend the base object
          for (name in options) {
            src = target[name];
            copy = options[name]; // Prevent never-ending loop

            if (target === copy) {
              continue;
            } // Recurse if we're merging plain objects or arrays


            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && Array.isArray(src) ? src : [];
              } else {
                clone = src && jQuery.isPlainObject(src) ? src : {};
              } // Never move original objects, clone them


              target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      } // Return the modified object


      return target;
    };

    jQuery.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version$2 + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function (msg) {
        throw new Error(msg);
      },
      noop: function () {},
      isPlainObject: function (obj) {
        var proto, Ctor; // Detect obvious negatives
        // Use toString instead of jQuery.type to catch host objects

        if (!obj || toString$2.call(obj) !== "[object Object]") {
          return false;
        }

        proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

        if (!proto) {
          return true;
        } // Objects with prototype are plain iff they were constructed by a global Object function


        Ctor = hasOwn$6.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function (obj) {
        /* eslint-disable no-unused-vars */
        // See https://github.com/eslint/eslint/issues/6125
        var name;

        for (name in obj) {
          return false;
        }

        return true;
      },
      // Evaluates a script in a global context
      globalEval: function (code) {
        DOMEval(code);
      },
      each: function (obj, callback) {
        var length,
            i = 0;

        if (isArrayLike(obj)) {
          length = obj.length;

          for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }

        return obj;
      },
      // Support: Android <=4.0 only
      trim: function (text) {
        return text == null ? "" : (text + "").replace(rtrim, "");
      },
      // results is for internal usage only
      makeArray: function (arr, results) {
        var ret = results || [];

        if (arr != null) {
          if (isArrayLike(Object(arr))) {
            jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
          } else {
            push.call(ret, arr);
          }
        }

        return ret;
      },
      inArray: function (elem, arr, i) {
        return arr == null ? -1 : indexOf.call(arr, elem, i);
      },
      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function (first, second) {
        var len = +second.length,
            j = 0,
            i = first.length;

        for (; j < len; j++) {
          first[i++] = second[j];
        }

        first.length = i;
        return first;
      },
      grep: function (elems, callback, invert) {
        var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert; // Go through the array, only saving the items
        // that pass the validator function

        for (; i < length; i++) {
          callbackInverse = !callback(elems[i], i);

          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }

        return matches;
      },
      // arg is for internal usage only
      map: function (elems, callback, arg) {
        var length,
            value,
            i = 0,
            ret = []; // Go through the array, translating each of the items to their new values

        if (isArrayLike(elems)) {
          length = elems.length;

          for (; i < length; i++) {
            value = callback(elems[i], i, arg);

            if (value != null) {
              ret.push(value);
            }
          } // Go through every key on the object,

        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);

            if (value != null) {
              ret.push(value);
            }
          }
        } // Flatten any nested arrays


        return concat.apply([], ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support: support
    });

    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    } // Populate the class2type map


    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
      class2type["[object " + name + "]"] = name.toLowerCase();
    });

    function isArrayLike(obj) {
      // Support: real iOS 8.2 only (not reproducible in simulator)
      // `in` check used to prevent JIT error (gh-2145)
      // hasOwn isn't used here due to false negatives
      // regarding Nodelist length in IE
      var length = !!obj && "length" in obj && obj.length,
          type = toType(obj);

      if (isFunction(obj) || isWindow(obj)) {
        return false;
      }

      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }

    var Sizzle =
    /*!
    * Sizzle CSS Selector Engine v2.3.3
    * https://sizzlejs.com/
    *
    * Copyright jQuery Foundation and other contributors
    * Released under the MIT license
    * http://jquery.org/license
    *
    * Date: 2016-08-08
    */
    function (window) {
      var i,
          support,
          Expr,
          getText,
          isXML,
          tokenize,
          compile,
          select,
          outermostContext,
          sortInput,
          hasDuplicate,
          // Local document vars
      setDocument,
          document,
          docElem,
          documentIsHTML,
          rbuggyQSA,
          rbuggyMatches,
          matches,
          contains,
          // Instance-specific data
      expando = "sizzle" + 1 * new Date(),
          preferredDoc = window.document,
          dirruns = 0,
          done = 0,
          classCache = createCache(),
          tokenCache = createCache(),
          compilerCache = createCache(),
          sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
        }

        return 0;
      },
          // Instance methods
      hasOwn = {}.hasOwnProperty,
          arr = [],
          pop = arr.pop,
          push_native = arr.push,
          push = arr.push,
          slice = arr.slice,
          // Use a stripped-down indexOf as it's faster than native
      // https://jsperf.com/thor-indexof-vs-for/5
      indexOf = function (list, elem) {
        var i = 0,
            len = list.length;

        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }

        return -1;
      },
          booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
          // Regular expressions
      // http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = "[\\x20\\t\\r\\n\\f]",
          // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
      identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
          // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
      "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
      "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
          pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
      // 1. quoted (capture 3; capture 4 or capture 5)
      "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
      "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
      ".*" + ")\\)|)",
          // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rwhitespace = new RegExp(whitespace + "+", "g"),
          rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
          rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
          rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
          rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
          rpseudo = new RegExp(pseudos),
          ridentifier = new RegExp("^" + identifier + "$"),
          matchExpr = {
        "ID": new RegExp("^#(" + identifier + ")"),
        "CLASS": new RegExp("^\\.(" + identifier + ")"),
        "TAG": new RegExp("^(" + identifier + "|[*])"),
        "ATTR": new RegExp("^" + attributes),
        "PSEUDO": new RegExp("^" + pseudos),
        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      },
          rinputs = /^(?:input|select|textarea|button)$/i,
          rheader = /^h\d$/i,
          rnative = /^[^{]+\{\s*\[native \w/,
          // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
          rsibling = /[+~]/,
          // CSS escapes
      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
          funescape = function (_, escaped, escapedWhitespace) {
        var high = "0x" + escaped - 0x10000; // NaN means non-codepoint
        // Support: Firefox<24
        // Workaround erroneous numeric interpretation of +"0x"

        return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
        String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
      },
          // CSS string/identifier serialization
      // https://drafts.csswg.org/cssom/#common-serializing-idioms
      // eslint-disable-next-line no-control-regex
      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
          fcssescape = function (ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === "\0") {
            return "\uFFFD";
          } // Control characters and (dependent upon position) numbers get escaped as code points


          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        } // Other potentially-special ASCII characters get backslash-escaped


        return "\\" + ch;
      },
          // Used for iframes
      // See setDocument()
      // Removing the function wrapper causes a "Permission Denied"
      // error in IE
      unloadHandler = function () {
        setDocument();
      },
          disabledAncestor = addCombinator(function (elem) {
        return elem.disabled === true && ("form" in elem || "label" in elem);
      }, {
        dir: "parentNode",
        next: "legend"
      }); // Optimize for push.apply( _, NodeList )


      try {
        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
        // Detect silently failing push.apply

        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ? // Leverage slice if possible
          function (target, els) {
            push_native.apply(target, slice.call(els));
          } : // Support: IE<9
          // Otherwise append directly
          function (target, els) {
            var j = target.length,
                i = 0; // Can't trust NodeList.length

            while (target[j++] = els[i++]) {}

            target.length = j - 1;
          }
        };
      }

      function Sizzle(selector, context, results, seed) {
        var m,
            i,
            elem,
            nid,
            match,
            groups,
            newSelector,
            newContext = context && context.ownerDocument,
            // nodeType defaults to 9, since context defaults to document
        nodeType = context ? context.nodeType : 9;
        results = results || []; // Return early from calls with invalid selector or context

        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        } // Try to shortcut find operations (as opposed to filters) in HTML documents


        if (!seed) {
          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
            setDocument(context);
          }

          context = context || document;

          if (documentIsHTML) {
            // If the selector is sufficiently simple, try using a "get*By*" DOM method
            // (excepting DocumentFragment context, where the methods don't exist)
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
              // ID selector
              if (m = match[1]) {
                // Document context
                if (nodeType === 9) {
                  if (elem = context.getElementById(m)) {
                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  } // Element context

                } else {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } // Type selector

              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results; // Class selector
              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            } // Take advantage of querySelectorAll


            if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              if (nodeType !== 1) {
                newContext = context;
                newSelector = selector; // qSA looks outside Element context, which is not what we want
                // Thanks to Andrew Dupont for this workaround technique
                // Support: IE <=8
                // Exclude object elements
              } else if (context.nodeName.toLowerCase() !== "object") {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                } // Prefix every selector in the list


                groups = tokenize(selector);
                i = groups.length;

                while (i--) {
                  groups[i] = "#" + nid + " " + toSelector(groups[i]);
                }

                newSelector = groups.join(","); // Expand context for sibling selectors

                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              }

              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {} finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
        } // All others


        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }
      /**
       * Create key-value caches of limited size
       * @returns {function(string, object)} Returns the Object data after storing it on itself with
       *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *    deleting the oldest entry
       */


      function createCache() {
        var keys = [];

        function cache(key, value) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if (keys.push(key + " ") > Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }

          return cache[key + " "] = value;
        }

        return cache;
      }
      /**
       * Mark a function for special use by Sizzle
       * @param {Function} fn The function to mark
       */


      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      /**
       * Support testing using an element
       * @param {Function} fn Passed the created element and returns a boolean result
       */


      function assert(fn) {
        // When unit testing from Node document will be undefined.  We don't care about assertions in that case.
        if (!document) return true;
        var el = document.createElement("fieldset");

        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {
          // Remove from its parent by default
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          } // release memory in IE


          el = null;
        }
      }
      /**
       * Adds the same handler for all of the specified attrs
       * @param {String} attrs Pipe-separated list of attributes
       * @param {Function} handler The method that will be applied
       */


      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
            i = arr.length;

        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }
      /**
       * Checks document order of two siblings
       * @param {Element} a
       * @param {Element} b
       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
       */


      function siblingCheck(a, b) {
        var cur = b && a,
            diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

        if (diff) {
          return diff;
        } // Check if b follows a


        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b) {
              return -1;
            }
          }
        }

        return a ? 1 : -1;
      }
      /**
       * Returns a function to use in pseudos for input types
       * @param {String} type
       */


      function createInputPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }
      /**
       * Returns a function to use in pseudos for buttons
       * @param {String} type
       */


      function createButtonPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }
      /**
       * Returns a function to use in pseudos for :enabled/:disabled
       * @param {Boolean} disabled true for :disabled; false for :enabled
       */


      function createDisabledPseudo(disabled) {
        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function (elem) {
          // Only certain elements can match :enabled or :disabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
          if ("form" in elem) {
            // Check for inherited disabledness on relevant non-disabled elements:
            // * listed form-associated elements in a disabled fieldset
            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
            // * option elements in a disabled optgroup
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
            // All such elements have a "form" property.
            if (elem.parentNode && elem.disabled === false) {
              // Option elements defer to a parent optgroup if present
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              } // Support: IE 6 - 11
              // Use the isDisabled shortcut property to check for disabled fieldset ancestors


              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

              /* jshint -W018 */
              elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
            }

            return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
            // even exist on them, let alone have a boolean value.
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          } // Remaining elements are neither :enabled nor :disabled


          return false;
        };
      }
      /**
       * Returns a function to use in pseudos for positionals
       * @param {Function} fn
       */


      function createPositionalPseudo(fn) {
        return markFunction(function (argument) {
          argument = +argument;
          return markFunction(function (seed, matches) {
            var j,
                matchIndexes = fn([], seed.length, argument),
                i = matchIndexes.length; // Match elements found at the specified indexes

            while (i--) {
              if (seed[j = matchIndexes[i]]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }
      /**
       * Checks a node for validity as a Sizzle context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */


      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      } // Expose support vars for convenience


      support = Sizzle.support = {};
      /**
       * Detects XML nodes
       * @param {Element|Object} elem An element or a document
       * @returns {Boolean} True iff elem is a non-HTML XML node
       */

      isXML = Sizzle.isXML = function (elem) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };
      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [doc] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */


      setDocument = Sizzle.setDocument = function (node) {
        var hasCompare,
            subWindow,
            doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected

        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        } // Update global variables


        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML(document); // Support: IE 9-11, Edge
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)

        if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
          // Support: IE 11, Edge
          if (subWindow.addEventListener) {
            subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
          } else if (subWindow.attachEvent) {
            subWindow.attachEvent("onunload", unloadHandler);
          }
        }
        /* Attributes
        ---------------------------------------------------------------------- */
        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)


        support.attributes = assert(function (el) {
          el.className = "i";
          return !el.getAttribute("className");
        });
        /* getElement(s)By*
        ---------------------------------------------------------------------- */
        // Check if getElementsByTagName("*") returns only elements

        support.getElementsByTagName = assert(function (el) {
          el.appendChild(document.createComment(""));
          return !el.getElementsByTagName("*").length;
        }); // Support: IE<9

        support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programmatically-set names,
        // so use a roundabout getElementsByName test

        support.getById = assert(function (el) {
          docElem.appendChild(el).id = expando;
          return !document.getElementsByName || !document.getElementsByName(expando).length;
        }); // ID filter and find

        if (support.getById) {
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              return elem.getAttribute("id") === attrId;
            };
          };

          Expr.find["ID"] = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var elem = context.getElementById(id);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          }; // Support: IE 6 - 7 only
          // getElementById is not reliable as a find shortcut


          Expr.find["ID"] = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var node,
                  i,
                  elems,
                  elem = context.getElementById(id);

              if (elem) {
                // Verify the id attribute
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                } // Fall back on getElementsByName


                elems = context.getElementsByName(id);
                i = 0;

                while (elem = elems[i++]) {
                  node = elem.getAttributeNode("id");

                  if (node && node.value === id) {
                    return [elem];
                  }
                }
              }

              return [];
            }
          };
        } // Tag


        Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
          } else if (support.qsa) {
            return context.querySelectorAll(tag);
          }
        } : function (tag, context) {
          var elem,
              tmp = [],
              i = 0,
              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
          results = context.getElementsByTagName(tag); // Filter out possible comments

          if (tag === "*") {
            while (elem = results[i++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }

            return tmp;
          }

          return results;
        }; // Class

        Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        /* QSA/matchesSelector
        ---------------------------------------------------------------------- */
        // QSA and matchesSelector support
        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


        rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See https://bugs.jquery.com/ticket/13378

        rbuggyQSA = [];

        if (support.qsa = rnative.test(document.querySelectorAll)) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function (el) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // https://bugs.jquery.com/ticket/12359
            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

            if (el.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            } // Support: IE8
            // Boolean attributes and "value" are not treated correctly


            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            } // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests


            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            } // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibling-combinator selector` fails


            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });
          assert(function (el) {
            el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment

            var input = document.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D"); // Support: IE8
            // Enforce case-sensitivity of name attribute

            if (el.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests


            if (el.querySelectorAll(":enabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Support: IE9-11+
            // IE's :disabled selector does not pick up the children of disabled fieldsets


            docElem.appendChild(el).disabled = true;

            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Opera 10-11 does not throw on post-comma invalid pseudos


            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }

        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function (el) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
            // Gecko does not error, returns false instead

            matches.call(el, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        /* Contains
        ---------------------------------------------------------------------- */

        hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself

        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a,
              bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function (a, b) {
          if (b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
          }

          return false;
        };
        /* Sorting
        ---------------------------------------------------------------------- */
        // Document order sorting

        sortOrder = hasCompare ? function (a, b) {
          // Flag for duplicate removal
          if (a === b) {
            hasDuplicate = true;
            return 0;
          } // Sort on method existence if only one input has compareDocumentPosition


          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

          if (compare) {
            return compare;
          } // Calculate position if both inputs belong to the same document


          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
          1; // Disconnected nodes

          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            // Choose the first element that is related to our preferred document
            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
              return -1;
            }

            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
              return 1;
            } // Maintain original order


            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
          }

          return compare & 4 ? -1 : 1;
        } : function (a, b) {
          // Exit early if the nodes are identical
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }

          var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [a],
              bp = [b]; // Parentless nodes are either documents or disconnected

          if (!aup || !bup) {
            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
          } else if (aup === bup) {
            return siblingCheck(a, b);
          } // Otherwise we need full lists of their ancestors for comparison


          cur = a;

          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }

          cur = b;

          while (cur = cur.parentNode) {
            bp.unshift(cur);
          } // Walk down the tree looking for a discrepancy


          while (ap[i] === bp[i]) {
            i++;
          }

          return i ? // Do a sibling check if the nodes have a common ancestor
          siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
          ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
        };
        return document;
      };

      Sizzle.matches = function (expr, elements) {
        return Sizzle(expr, null, null, elements);
      };

      Sizzle.matchesSelector = function (elem, expr) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        } // Make sure that attribute selectors are quoted


        expr = expr.replace(rattributeQuotes, "='$1']");

        if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {}
        }

        return Sizzle(expr, document, null, [elem]).length > 0;
      };

      Sizzle.contains = function (context, elem) {
        // Set document vars if needed
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }

        return contains(context, elem);
      };

      Sizzle.attr = function (elem, name) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        var fn = Expr.attrHandle[name.toLowerCase()],
            // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      };

      Sizzle.escape = function (sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };

      Sizzle.error = function (msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */


      Sizzle.uniqueSort = function (results) {
        var elem,
            duplicates = [],
            j = 0,
            i = 0; // Unless we *know* we can detect duplicates, assume their presence

        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);

        if (hasDuplicate) {
          while (elem = results[i++]) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }

          while (j--) {
            results.splice(duplicates[j], 1);
          }
        } // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225


        sortInput = null;
        return results;
      };
      /**
       * Utility function for retrieving the text value of an array of DOM nodes
       * @param {Array|Element} elem
       */


      getText = Sizzle.getText = function (elem) {
        var node,
            ret = "",
            i = 0,
            nodeType = elem.nodeType;

        if (!nodeType) {
          // If no nodeType, this is expected to be an array
          while (node = elem[i++]) {
            // Do not traverse comment nodes
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            // Traverse its children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        } // Do not include comment or processing instruction nodes


        return ret;
      };

      Expr = Sizzle.selectors = {
        // Can be adjusted by the user
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: true
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: true
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          "ATTR": function (match) {
            match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }

            return match.slice(0, 4);
          },
          "CHILD": function (match) {
            /* matches from matchExpr["CHILD"]
            1 type (only|nth|...)
            2 what (child|of-type)
            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            4 xn-component of xn+y argument ([+-]?\d*n|)
            5 sign of xn-component
            6 x of xn-component
            7 sign of y-component
            8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if (match[1].slice(0, 3) === "nth") {
              // nth-* requires argument
              if (!match[3]) {
                Sizzle.error(match[0]);
              } // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1


              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }

            return match;
          },
          "PSEUDO": function (match) {
            var excess,
                unquoted = !match[6] && match[2];

            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            } // Accept quoted arguments as-is


            if (match[3]) {
              match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
            } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
            excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            } // Return only captures needed by the pseudo filter method (type and argument)


            return match.slice(0, 3);
          }
        },
        filter: {
          "TAG": function (nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function () {
              return true;
            } : function (elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
          },
          "CLASS": function (className) {
            var pattern = classCache[className + " "];
            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
            });
          },
          "ATTR": function (name, operator, check) {
            return function (elem) {
              var result = Sizzle.attr(elem, name);

              if (result == null) {
                return operator === "!=";
              }

              if (!operator) {
                return true;
              }

              result += "";
              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            };
          },
          "CHILD": function (type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
                forward = type.slice(-4) !== "last",
                ofType = what === "of-type";
            return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
            function (elem) {
              return !!elem.parentNode;
            } : function (elem, context, xml) {
              var cache,
                  uniqueCache,
                  outerCache,
                  node,
                  nodeIndex,
                  start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType,
                  diff = false;

              if (parent) {
                // :(first|last|only)-(child|of-type)
                if (simple) {
                  while (dir) {
                    node = elem;

                    while (node = node[dir]) {
                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                        return false;
                      }
                    } // Reverse direction for :only-* (if we haven't yet done so)


                    start = dir = type === "only" && !start && "nextSibling";
                  }

                  return true;
                }

                start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

                if (forward && useCache) {
                  // Seek `elem` from a previously-cached index
                  // ...in a gzip-friendly way
                  node = parent;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex && cache[2];
                  node = nodeIndex && parent.childNodes[nodeIndex];

                  while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                  diff = nodeIndex = 0) || start.pop()) {
                    // When found, cache indexes on `parent` and break
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      uniqueCache[type] = [dirruns, nodeIndex, diff];
                      break;
                    }
                  }
                } else {
                  // Use previously-cached element index if available
                  if (useCache) {
                    // ...in a gzip-friendly way
                    node = elem;
                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)

                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex;
                  } // xml :nth-child(...)
                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                  if (diff === false) {
                    // Use the same loop as above to seek `elem` from the start
                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                        // Cache the index of each encountered element
                        if (useCache) {
                          outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                          // Defend against cloned attroperties (jQuery gh-1709)

                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                          uniqueCache[type] = [dirruns, diff];
                        }

                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                } // Incorporate the offset, then check against cycle size


                diff -= last;
                return diff === first || diff % first === 0 && diff / first >= 0;
              }
            };
          },
          "PSEUDO": function (pseudo, argument) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does

            if (fn[expando]) {
              return fn(argument);
            } // But maintain support for old signatures


            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                var idx,
                    matched = fn(seed, argument),
                    i = matched.length;

                while (i--) {
                  idx = indexOf(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) : function (elem) {
                return fn(elem, 0, args);
              };
            }

            return fn;
          }
        },
        pseudos: {
          // Potentially complex pseudos
          "not": markFunction(function (selector) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile(selector.replace(rtrim, "$1"));
            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
              var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length; // Match elements unmatched by `matcher`

              while (i--) {
                if (elem = unmatched[i]) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) : function (elem, context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results); // Don't keep the element (issue #299)

              input[0] = null;
              return !results.pop();
            };
          }),
          "has": markFunction(function (selector) {
            return function (elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),
          "contains": markFunction(function (text) {
            text = text.replace(runescape, funescape);
            return function (elem) {
              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
            };
          }),
          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          "lang": markFunction(function (lang) {
            // lang value must be a valid identifier
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }

            lang = lang.replace(runescape, funescape).toLowerCase();
            return function (elem) {
              var elemLang;

              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);

              return false;
            };
          }),
          // Miscellaneous
          "target": function (elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          "root": function (elem) {
            return elem === docElem;
          },
          "focus": function (elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          // Boolean properties
          "enabled": createDisabledPseudo(false),
          "disabled": createDisabledPseudo(true),
          "checked": function (elem) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
          },
          "selected": function (elem) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },
          // Contents
          "empty": function (elem) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }

            return true;
          },
          "parent": function (elem) {
            return !Expr.pseudos["empty"](elem);
          },
          // Element/input types
          "header": function (elem) {
            return rheader.test(elem.nodeName);
          },
          "input": function (elem) {
            return rinputs.test(elem.nodeName);
          },
          "button": function (elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
          },
          "text": function (elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
            (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          // Position-in-collection
          "first": createPositionalPseudo(function () {
            return [0];
          }),
          "last": createPositionalPseudo(function (matchIndexes, length) {
            return [length - 1];
          }),
          "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),
          "even": createPositionalPseudo(function (matchIndexes, length) {
            var i = 0;

            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "odd": createPositionalPseudo(function (matchIndexes, length) {
            var i = 1;

            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;

            for (; --i >= 0;) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;

            for (; ++i < length;) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

      for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }

      for (i in {
        submit: true,
        reset: true
      }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      } // Easy API for creating new setFilters


      function setFilters() {}

      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();

      tokenize = Sizzle.tokenize = function (selector, parseOnly) {
        var matched,
            match,
            tokens,
            type,
            soFar,
            groups,
            preFilters,
            cached = tokenCache[selector + " "];

        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while (soFar) {
          // Comma and first run
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }

            groups.push(tokens = []);
          }

          matched = false; // Combinators

          if (match = rcombinators.exec(soFar)) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          } // Filters


          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }

          if (!matched) {
            break;
          }
        } // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens


        return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
        tokenCache(selector, groups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
            len = tokens.length,
            selector = "";

        for (; i < len; i++) {
          selector += tokens[i].value;
        }

        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
            skip = combinator.next,
            key = skip || dir,
            checkNonElements = base && key === "parentNode",
            doneName = done++;
        return combinator.first ? // Check against closest ancestor/preceding element
        function (elem, context, xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }

          return false;
        } : // Check against all ancestor/preceding elements
        function (elem, context, xml) {
          var oldCache,
              uniqueCache,
              outerCache,
              newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

          if (xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir] || elem;
                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  // Assign to newCache so results back-propagate to previous elements
                  return newCache[2] = oldCache[2];
                } else {
                  // Reuse newcache so results back-propagate to previous elements
                  uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                  if (newCache[2] = matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            }
          }

          return false;
        };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1 ? function (elem, context, xml) {
          var i = matchers.length;

          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }

          return true;
        } : matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
            len = contexts.length;

        for (; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }

        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
            newUnmatched = [],
            i = 0,
            len = unmatched.length,
            mapped = map != null;

        for (; i < len; i++) {
          if (elem = unmatched[i]) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);

              if (mapped) {
                map.push(i);
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }

        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }

        return markFunction(function (seed, results, context, xml) {
          var temp,
              i,
              elem,
              preMap = [],
              postMap = [],
              preexisting = results.length,
              // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
              // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
              matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
          [] : // ...otherwise use results directly
          results : matcherIn; // Find primary matches

          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          } // Apply postFilter


          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

            i = temp.length;

            while (i--) {
              if (elem = temp[i]) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }

          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;

                while (i--) {
                  if (elem = matcherOut[i]) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push(matcherIn[i] = elem);
                  }
                }

                postFinder(null, matcherOut = [], temp, xml);
              } // Move matched elements from seed to results to keep them synchronized


              i = matcherOut.length;

              while (i--) {
                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            } // Add elements to results, through postFinder if defined

          } else {
            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext,
            matcher,
            j,
            len = tokens.length,
            leadingRelative = Expr.relative[tokens[0].type],
            implicitRelative = leadingRelative || Expr.relative[" "],
            i = leadingRelative ? 1 : 0,
            // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true),
            matchAnyContext = addCombinator(function (elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true),
            matchers = [function (elem, context, xml) {
          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

          checkContext = null;
          return ret;
        }];

        for (; i < len; i++) {
          if (matcher = Expr.relative[tokens[i].type]) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

            if (matcher[expando]) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;

              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }

              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
              tokens.slice(0, i - 1).concat({
                value: tokens[i - 2].type === " " ? "*" : ""
              })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
            }

            matchers.push(matcher);
          }
        }

        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
            byElement = elementMatchers.length > 0,
            superMatcher = function (seed, context, xml, results, outermost) {
          var elem,
              j,
              matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
          elems = seed || byElement && Expr.find["TAG"]("*", outermost),
              // Use integer dirruns iff this is the outermost matcher
          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
              len = elems.length;

          if (outermost) {
            outermostContext = context === document || context || outermost;
          } // Add elements passing elementMatchers directly to results
          // Support: IE<9, Safari
          // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;

              if (!context && elem.ownerDocument !== document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }

              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }

              if (outermost) {
                dirruns = dirrunsUnique;
              }
            } // Track unmatched elements for set filters


            if (bySet) {
              // They will have gone through all possible matchers
              if (elem = !matcher && elem) {
                matchedCount--;
              } // Lengthen the array for every element, matched or not


              if (seed) {
                unmatched.push(elem);
              }
            }
          } // `i` is now the count of elements visited above, and adding it to `matchedCount`
          // makes the latter nonnegative.


          matchedCount += i; // Apply set filters to unmatched elements
          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
          // no element matchers and no seed.
          // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
          // case, which will result in a "00" `matchedCount` that differs from `i` but is also
          // numerically zero.

          if (bySet && i !== matchedCount) {
            j = 0;

            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }

            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              } // Discard index placeholder values to get only actual matches


              setMatched = condense(setMatched);
            } // Add matches to results


            push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          } // Override manipulation of globals by nested matchers


          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          return unmatched;
        };

        return bySet ? markFunction(superMatcher) : superMatcher;
      }

      compile = Sizzle.compile = function (selector, match
      /* Internal Use Only */
      ) {
        var i,
            setMatchers = [],
            elementMatchers = [],
            cached = compilerCache[selector + " "];

        if (!cached) {
          // Generate a function of recursive functions that can be used to check each element
          if (!match) {
            match = tokenize(selector);
          }

          i = match.length;

          while (i--) {
            cached = matcherFromTokens(match[i]);

            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          } // Cache the compiled function


          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

          cached.selector = selector;
        }

        return cached;
      };
      /**
       * A low-level selection function that works with Sizzle's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with Sizzle.compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */


      select = Sizzle.select = function (selector, context, results, seed) {
        var i,
            tokens,
            token,
            type,
            find,
            compiled = typeof selector === "function" && selector,
            match = !seed && tokenize(selector = compiled.selector || selector);
        results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)

        if (match.length === 1) {
          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice(0);

          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

            if (!context) {
              return results; // Precompiled matchers will still verify ancestry, so step up a level
            } else if (compiled) {
              context = context.parentNode;
            }

            selector = selector.slice(tokens.shift().value.length);
          } // Fetch a seed set for right-to-left matching


          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

          while (i--) {
            token = tokens[i]; // Abort if we hit a combinator

            if (Expr.relative[type = token.type]) {
              break;
            }

            if (find = Expr.find[type]) {
              // Search, expanding context for leading sibling combinators
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);

                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        } // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above


        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
        return results;
      }; // One-time assignments
      // Sort stability


      support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function

      support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

      setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*

      support.sortDetached = assert(function (el) {
        // Should return 1, but returns 4 (following)
        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
      }); // Support: IE<8
      // Prevent attribute/property "interpolation"
      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

      if (!assert(function (el) {
        el.innerHTML = "<a href='#'></a>";
        return el.firstChild.getAttribute("href") === "#";
      })) {
        addHandle("type|href|height|width", function (elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      } // Support: IE<9
      // Use defaultValue in place of getAttribute("value")


      if (!support.attributes || !assert(function (el) {
        el.innerHTML = "<input/>";
        el.firstChild.setAttribute("value", "");
        return el.firstChild.getAttribute("value") === "";
      })) {
        addHandle("value", function (elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      } // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies


      if (!assert(function (el) {
        return el.getAttribute("disabled") == null;
      })) {
        addHandle(booleans, function (elem, name, isXML) {
          var val;

          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          }
        });
      }

      return Sizzle;
    }(window);

    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors; // Deprecated

    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;

    var dir = function (elem, dir, until) {
      var matched = [],
          truncate = until !== undefined;

      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }

          matched.push(elem);
        }
      }

      return matched;
    };

    var siblings = function (n, elem) {
      var matched = [];

      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }

      return matched;
    };

    var rneedsContext = jQuery.expr.match.needsContext;

    function nodeName(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }

    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

    function winnow(elements, qualifier, not) {
      if (isFunction(qualifier)) {
        return jQuery.grep(elements, function (elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      } // Single element


      if (qualifier.nodeType) {
        return jQuery.grep(elements, function (elem) {
          return elem === qualifier !== not;
        });
      } // Arraylike of elements (jQuery, arguments, Array)


      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function (elem) {
          return indexOf.call(qualifier, elem) > -1 !== not;
        });
      } // Filtered directly for both simple and complex selectors


      return jQuery.filter(qualifier, elements, not);
    }

    jQuery.filter = function (expr, elems, not) {
      var elem = elems[0];

      if (not) {
        expr = ":not(" + expr + ")";
      }

      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
      }

      return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    };

    jQuery.fn.extend({
      find: function (selector) {
        var i,
            ret,
            len = this.length,
            self = this;

        if (typeof selector !== "string") {
          return this.pushStack(jQuery(selector).filter(function () {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self[i], this)) {
                return true;
              }
            }
          }));
        }

        ret = this.pushStack([]);

        for (i = 0; i < len; i++) {
          jQuery.find(selector, self[i], ret);
        }

        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function (selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function (selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function (selector) {
        return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
      }
    }); // Initialize a jQuery object
    // A central reference to the root jQuery(document)

    var rootjQuery,
        // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
        init$1 = jQuery.fn.init = function (selector, context, root) {
      var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

      if (!selector) {
        return this;
      } // Method init() accepts an alternate rootjQuery
      // so migrate can support jQuery.sub (gh-2101)


      root = root || rootjQuery; // Handle HTML strings

      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        } // Match html or make sure no context is specified for #id


        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present

            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document$2, true)); // HANDLE: $(html, props)

            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                // Properties of context are called as methods if possible
                if (isFunction(this[match])) {
                  this[match](context[match]); // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }

            return this; // HANDLE: $(#id)
          } else {
            elem = document$2.getElementById(match[2]);

            if (elem) {
              // Inject the element directly into the jQuery object
              this[0] = elem;
              this.length = 1;
            }

            return this;
          } // HANDLE: $(expr, $(...))

        } else if (!context || context.jquery) {
          return (context || root).find(selector); // HANDLE: $(expr, context)
          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        } // HANDLE: $(DOMElement)

      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this; // HANDLE: $(function)
        // Shortcut for document ready
      } else if (isFunction(selector)) {
        return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
        selector(jQuery);
      }

      return jQuery.makeArray(selector, this);
    }; // Give the init function the jQuery prototype for later instantiation


    init$1.prototype = jQuery.fn; // Initialize central reference

    rootjQuery = jQuery(document$2);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery.fn.extend({
      has: function (target) {
        var targets = jQuery(target, this),
            l = targets.length;
        return this.filter(function () {
          var i = 0;

          for (; i < l; i++) {
            if (jQuery.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function (selectors, context) {
        var cur,
            i = 0,
            l = this.length,
            matched = [],
            targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              // Always skip document fragments
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
              cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
              }
            }
          }
        }

        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },
      // Determine the position of an element within the set
      index: function (elem) {
        // No argument, return index in parent
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        } // Index in selector


        if (typeof elem === "string") {
          return indexOf.call(jQuery(elem), this[0]);
        } // Locate the position of the desired element


        return indexOf.call(this, // If it receives a jQuery object, the first element is used
        elem.jquery ? elem[0] : elem);
      },
      add: function (selector, context) {
        return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
      },
      addBack: function (selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      }
    });

    function sibling(cur, dir) {
      while ((cur = cur[dir]) && cur.nodeType !== 1) {}

      return cur;
    }

    jQuery.each({
      parent: function (elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function (elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function (elem, i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function (elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function (elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function (elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function (elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function (elem, i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function (elem, i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function (elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function (elem) {
        return siblings(elem.firstChild);
      },
      contents: function (elem) {
        if (nodeName(elem, "iframe")) {
          return elem.contentDocument;
        } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.


        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }

        return jQuery.merge([], elem.childNodes);
      }
    }, function (name, fn) {
      jQuery.fn[name] = function (until, selector) {
        var matched = jQuery.map(this, fn, until);

        if (name.slice(-5) !== "Until") {
          selector = until;
        }

        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }

        if (this.length > 1) {
          // Remove duplicates
          if (!guaranteedUnique[name]) {
            jQuery.uniqueSort(matched);
          } // Reverse order for parents* and prev-derivatives


          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }

        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

    function createOptions(options) {
      var object = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
        object[flag] = true;
      });
      return object;
    }
    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */


    jQuery.Callbacks = function (options) {
      // Convert options from String-formatted to Object-formatted if needed
      // (we check in cache first)
      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

      var // Flag to know if list is currently firing
      firing,
          // Last fire value for non-forgettable lists
      memory,
          // Flag to know if list was already fired
      fired,
          // Flag to prevent firing
      locked,
          // Actual callback list
      list = [],
          // Queue of execution data for repeatable lists
      queue = [],
          // Index of currently firing callback (modified by add/remove as needed)
      firingIndex = -1,
          // Fire callbacks
      fire = function () {
        // Enforce single-firing
        locked = locked || options.once; // Execute callbacks for all pending executions,
        // respecting firingIndex overrides and runtime changes

        fired = firing = true;

        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();

          while (++firingIndex < list.length) {
            // Run callback and check for early termination
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              // Jump to end and forget the data so .add doesn't re-fire
              firingIndex = list.length;
              memory = false;
            }
          }
        } // Forget the data if we're done with it


        if (!options.memory) {
          memory = false;
        }

        firing = false; // Clean up if we're done firing for good

        if (locked) {
          // Keep an empty list if we have data for future add calls
          if (memory) {
            list = []; // Otherwise, this object is spent
          } else {
            list = "";
          }
        }
      },
          // Actual Callbacks object
      self = {
        // Add a callback or a collection of callbacks to the list
        add: function () {
          if (list) {
            // If we have memory from a past run, we should fire after adding
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }

            (function add(args) {
              jQuery.each(args, function (_, arg) {
                if (isFunction(arg)) {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  // Inspect recursively
                  add(arg);
                }
              });
            })(arguments);

            if (memory && !firing) {
              fire();
            }
          }

          return this;
        },
        // Remove a callback from the list
        remove: function () {
          jQuery.each(arguments, function (_, arg) {
            var index;

            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1); // Handle firing indexes

              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        // Remove all callbacks from the list
        empty: function () {
          if (list) {
            list = [];
          }

          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function () {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function () {
          return !list;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function () {
          locked = queue = [];

          if (!memory && !firing) {
            list = memory = "";
          }

          return this;
        },
        locked: function () {
          return !!locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function (context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);

            if (!firing) {
              fire();
            }
          }

          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function () {
          return !!fired;
        }
      };

      return self;
    };

    function Identity(v) {
      return v;
    }

    function Thrower(ex) {
      throw ex;
    }

    function adoptValue(value, resolve, reject, noValue) {
      var method;

      try {
        // Check for promise aspect first to privilege synchronous behavior
        if (value && isFunction(method = value.promise)) {
          method.call(value).done(resolve).fail(reject); // Other thenables
        } else if (value && isFunction(method = value.then)) {
          method.call(value, resolve, reject); // Other non-thenables
        } else {
          // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
          // * false: [ value ].slice( 0 ) => resolve( value )
          // * true: [ value ].slice( 1 ) => resolve()
          resolve.apply(undefined, [value].slice(noValue));
        } // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.

      } catch (value) {
        // Support: Android 4.0 only
        // Strict mode functions invoked without .call/.apply get global-object context
        reject.apply(undefined, [value]);
      }
    }

    jQuery.extend({
      Deferred: function (func) {
        var tuples = [// action, add listener, callbacks,
        // ... .then handlers, argument index, [final state]
        ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
            state = "pending",
            promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function (fn) {
            return promise.then(null, fn);
          },
          // Keep pipe for back-compat
          pipe: function
            /* fnDone, fnFail, fnProgress */
          () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                // deferred.fail(function() { bind to newDefer or newDefer.reject })

                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);

                  if (returned && isFunction(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function (onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;

            function resolve(depth, deferred, handler, special) {
              return function () {
                var that = this,
                    args = arguments,
                    mightThrow = function () {
                  var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                  // https://promisesaplus.com/#point-59
                  // Ignore double-resolution attempts

                  if (depth < maxDepth) {
                    return;
                  }

                  returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                  // https://promisesaplus.com/#point-48

                  if (returned === deferred.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  } // Support: Promises/A+ sections 2.3.3.1, 3.5
                  // https://promisesaplus.com/#point-54
                  // https://promisesaplus.com/#point-75
                  // Retrieve `then` only once


                  then = returned && ( // Support: Promises/A+ section 2.3.4
                  // https://promisesaplus.com/#point-64
                  // Only check objects and functions for thenability
                  typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                  if (isFunction(then)) {
                    // Special processors (notify) just wait for resolution
                    if (special) {
                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                    } else {
                      // ...and disregard older resolution values
                      maxDepth++;
                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                    } // Handle all other returned values

                  } else {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Identity) {
                      that = undefined;
                      args = [returned];
                    } // Process the value(s)
                    // Default process is resolve


                    (special || deferred.resolveWith)(that, args);
                  }
                },
                    // Only normal processors (resolve) catch and reject exceptions
                process = special ? mightThrow : function () {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery.Deferred.exceptionHook) {
                      jQuery.Deferred.exceptionHook(e, process.stackTrace);
                    } // Support: Promises/A+ section 2.3.3.3.4.1
                    // https://promisesaplus.com/#point-61
                    // Ignore post-resolution exceptions


                    if (depth + 1 >= maxDepth) {
                      // Only substitute handlers pass on context
                      // and multiple values (non-spec behavior)
                      if (handler !== Thrower) {
                        that = undefined;
                        args = [e];
                      }

                      deferred.rejectWith(that, args);
                    }
                  }
                }; // Support: Promises/A+ section 2.3.3.3.1
                // https://promisesaplus.com/#point-57
                // Re-resolve promises immediately to dodge false rejection from
                // subsequent errors


                if (depth) {
                  process();
                } else {
                  // Call an optional hook to record the stack, in case of exception
                  // since it's otherwise lost when execution goes async
                  if (jQuery.Deferred.getStackHook) {
                    process.stackTrace = jQuery.Deferred.getStackHook();
                  }

                  window.setTimeout(process);
                }
              };
            }

            return jQuery.Deferred(function (newDefer) {
              // progress_handlers.add( ... )
              tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

              tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

              tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        },
            deferred = {}; // Add list-specific methods

        jQuery.each(tuples, function (i, tuple) {
          var list = tuple[2],
              stateString = tuple[5]; // promise.progress = list.add
          // promise.done = list.add
          // promise.fail = list.add

          promise[tuple[1]] = list.add; // Handle state

          if (stateString) {
            list.add(function () {
              // state = "resolved" (i.e., fulfilled)
              // state = "rejected"
              state = stateString;
            }, // rejected_callbacks.disable
            // fulfilled_callbacks.disable
            tuples[3 - i][2].disable, // rejected_handlers.disable
            // fulfilled_handlers.disable
            tuples[3 - i][3].disable, // progress_callbacks.lock
            tuples[0][2].lock, // progress_handlers.lock
            tuples[0][3].lock);
          } // progress_handlers.fire
          // fulfilled_handlers.fire
          // rejected_handlers.fire


          list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
          // deferred.resolve = function() { deferred.resolveWith(...) }
          // deferred.reject = function() { deferred.rejectWith(...) }

          deferred[tuple[0]] = function () {
            deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
            return this;
          }; // deferred.notifyWith = list.fireWith
          // deferred.resolveWith = list.fireWith
          // deferred.rejectWith = list.fireWith


          deferred[tuple[0] + "With"] = list.fireWith;
        }); // Make the deferred a promise

        promise.promise(deferred); // Call given func if any

        if (func) {
          func.call(deferred, deferred);
        } // All done!


        return deferred;
      },
      // Deferred helper
      when: function (singleValue) {
        var // count of uncompleted subordinates
        remaining = arguments.length,
            // count of unprocessed arguments
        i = remaining,
            // subordinate fulfillment data
        resolveContexts = Array(i),
            resolveValues = slice.call(arguments),
            // the master Deferred
        master = jQuery.Deferred(),
            // subordinate callback factory
        updateFunc = function (i) {
          return function (value) {
            resolveContexts[i] = this;
            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;

            if (! --remaining) {
              master.resolveWith(resolveContexts, resolveValues);
            }
          };
        }; // Single- and empty arguments are adopted like Promise.resolve


        if (remaining <= 1) {
          adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

          if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
            return master.then();
          }
        } // Multiple arguments are aggregated like Promise.all array elements


        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), master.reject);
        }

        return master.promise();
      }
    }); // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.

    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    jQuery.Deferred.exceptionHook = function (error, stack) {
      // Support: IE 8 - 9 only
      // Console exists when dev tools are open, which can happen at any time
      if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
        window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
      }
    };

    jQuery.readyException = function (error) {
      window.setTimeout(function () {
        throw error;
      });
    }; // The deferred used on DOM ready


    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function (fn) {
      readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
      // happens at the time of error handling instead of callback
      // registration.
      .catch(function (error) {
        jQuery.readyException(error);
      });
      return this;
    };

    jQuery.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
      // A counter to track how many items to wait for before
      // the ready event fires. See #6781
      readyWait: 1,
      // Handle when the DOM is ready
      ready: function (wait) {
        // Abort if there are pending holds or we're already ready
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        } // Remember that the DOM is ready


        jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        } // If there are functions bound, to execute


        readyList.resolveWith(document$2, [jQuery]);
      }
    });
    jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

    function completed() {
      document$2.removeEventListener("DOMContentLoaded", completed);
      window.removeEventListener("load", completed);
      jQuery.ready();
    } // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon


    if (document$2.readyState === "complete" || document$2.readyState !== "loading" && !document$2.documentElement.doScroll) {
      // Handle it asynchronously to allow scripts the opportunity to delay ready
      window.setTimeout(jQuery.ready);
    } else {
      // Use the handy event callback
      document$2.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

      window.addEventListener("load", completed);
    } // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function


    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0,
          len = elems.length,
          bulk = key == null; // Sets many values

      if (toType(key) === "object") {
        chainable = true;

        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        } // Sets one value

      } else if (value !== undefined) {
        chainable = true;

        if (!isFunction(value)) {
          raw = true;
        }

        if (bulk) {
          // Bulk operations run against the entire set
          if (raw) {
            fn.call(elems, value);
            fn = null; // ...except when executing function values
          } else {
            bulk = fn;

            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }

        if (fn) {
          for (; i < len; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }

      if (chainable) {
        return elems;
      } // Gets


      if (bulk) {
        return fn.call(elems);
      }

      return len ? fn(elems[0], key) : emptyGet;
    }; // Matches dashed string for camelizing


    var rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

    function fcamelCase(all, letter) {
      return letter.toUpperCase();
    } // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)


    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }

    var acceptData = function (owner) {
      // Accepts only:
      //  - Node
      //    - Node.ELEMENT_NODE
      //    - Node.DOCUMENT_NODE
      //  - Object
      //    - Any
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };

    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;
    Data.prototype = {
      cache: function (owner) {
        // Check if the owner object already has a cache
        var value = owner[this.expando]; // If not, create one

        if (!value) {
          value = {}; // We can accept data for non-element nodes in modern browsers,
          // but we should not, see #8335.
          // Always return an empty object.

          if (acceptData(owner)) {
            // If it is a node unlikely to be stringify-ed or looped over
            // use plain assignment
            if (owner.nodeType) {
              owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
              // configurable must be true to allow the property to be
              // deleted when data is removed
            } else {
              Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: true
              });
            }
          }
        }

        return value;
      },
      set: function (owner, data, value) {
        var prop,
            cache = this.cache(owner); // Handle: [ owner, key, value ] args
        // Always use camelCase key (gh-2257)

        if (typeof data === "string") {
          cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
        } else {
          // Copy the properties one-by-one to the cache object
          for (prop in data) {
            cache[camelCase(prop)] = data[prop];
          }
        }

        return cache;
      },
      get: function (owner, key) {
        return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
        owner[this.expando] && owner[this.expando][camelCase(key)];
      },
      access: function (owner, key, value) {
        // In cases where either:
        //
        //   1. No key was specified
        //   2. A string key was specified, but no value provided
        //
        // Take the "read" path and allow the get method to determine
        // which value to return, respectively either:
        //
        //   1. The entire cache object
        //   2. The data stored at the key
        //
        if (key === undefined || key && typeof key === "string" && value === undefined) {
          return this.get(owner, key);
        } // When the key is not a string, or both a key and value
        // are specified, set or extend (existing objects) with either:
        //
        //   1. An object of properties
        //   2. A key and value
        //


        this.set(owner, key, value); // Since the "set" path can have two possible entry points
        // return the expected data based on which path was taken[*]

        return value !== undefined ? value : key;
      },
      remove: function (owner, key) {
        var i,
            cache = owner[this.expando];

        if (cache === undefined) {
          return;
        }

        if (key !== undefined) {
          // Support array or space separated string of keys
          if (Array.isArray(key)) {
            // If key is an array of keys...
            // We always set camelCase keys, so remove that.
            key = key.map(camelCase);
          } else {
            key = camelCase(key); // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace

            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
          }

          i = key.length;

          while (i--) {
            delete cache[key[i]];
          }
        } // Remove the expando if there's no more data


        if (key === undefined || jQuery.isEmptyObject(cache)) {
          // Support: Chrome <=35 - 45
          // Webkit & Blink performance suffers when deleting properties
          // from DOM nodes, so set to undefined instead
          // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
          if (owner.nodeType) {
            owner[this.expando] = undefined;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function (owner) {
        var cache = owner[this.expando];
        return cache !== undefined && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data(); //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function getData(data) {
      if (data === "true") {
        return true;
      }

      if (data === "false") {
        return false;
      }

      if (data === "null") {
        return null;
      } // Only convert to a number if it doesn't change the string


      if (data === +data + "") {
        return +data;
      }

      if (rbrace.test(data)) {
        return JSON.parse(data);
      }

      return data;
    }

    function dataAttr(elem, key, data) {
      var name; // If nothing was found internally, try to fetch any
      // data from the HTML5 data-* attribute

      if (data === undefined && elem.nodeType === 1) {
        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name);

        if (typeof data === "string") {
          try {
            data = getData(data);
          } catch (e) {} // Make sure we set the data so it isn't changed later


          dataUser.set(elem, key, data);
        } else {
          data = undefined;
        }
      }

      return data;
    }

    jQuery.extend({
      hasData: function (elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function (elem, name, data) {
        return dataUser.access(elem, name, data);
      },
      removeData: function (elem, name) {
        dataUser.remove(elem, name);
      },
      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function (elem, name, data) {
        return dataPriv.access(elem, name, data);
      },
      _removeData: function (elem, name) {
        dataPriv.remove(elem, name);
      }
    });
    jQuery.fn.extend({
      data: function (key, value) {
        var i,
            name,
            data,
            elem = this[0],
            attrs = elem && elem.attributes; // Gets all values

        if (key === undefined) {
          if (this.length) {
            data = dataUser.get(elem);

            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;

              while (i--) {
                // Support: IE 11 only
                // The attrs elements can be null (#14894)
                if (attrs[i]) {
                  name = attrs[i].name;

                  if (name.indexOf("data-") === 0) {
                    name = camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }

              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }

          return data;
        } // Sets multiple values


        if (typeof key === "object") {
          return this.each(function () {
            dataUser.set(this, key);
          });
        }

        return access(this, function (value) {
          var data; // The calling jQuery object (element matches) is not empty
          // (and therefore has an element appears at this[ 0 ]) and the
          // `value` parameter was not undefined. An empty jQuery object
          // will result in `undefined` for elem = this[ 0 ] which will
          // throw an exception if an attempt to read a data cache is made.

          if (elem && value === undefined) {
            // Attempt to get data from the cache
            // The key will always be camelCased in Data
            data = dataUser.get(elem, key);

            if (data !== undefined) {
              return data;
            } // Attempt to "discover" the data in
            // HTML5 custom data-* attrs


            data = dataAttr(elem, key);

            if (data !== undefined) {
              return data;
            } // We tried really hard, but the data doesn't exist.


            return;
          } // Set the data...


          this.each(function () {
            // We always store the camelCased key
            dataUser.set(this, key, value);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function (key) {
        return this.each(function () {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery.extend({
      queue: function (elem, type, data) {
        var queue;

        if (elem) {
          type = (type || "fx") + "queue";
          queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

          if (data) {
            if (!queue || Array.isArray(data)) {
              queue = dataPriv.access(elem, type, jQuery.makeArray(data));
            } else {
              queue.push(data);
            }
          }

          return queue || [];
        }
      },
      dequeue: function (elem, type) {
        type = type || "fx";

        var queue = jQuery.queue(elem, type),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks(elem, type),
            next = function () {
          jQuery.dequeue(elem, type);
        }; // If the fx queue is dequeued, always remove the progress sentinel


        if (fn === "inprogress") {
          fn = queue.shift();
          startLength--;
        }

        if (fn) {
          // Add a progress sentinel to prevent the fx queue from being
          // automatically dequeued
          if (type === "fx") {
            queue.unshift("inprogress");
          } // Clear up the last queue stop function


          delete hooks.stop;
          fn.call(elem, next, hooks);
        }

        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function (elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function () {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });
    jQuery.fn.extend({
      queue: function (type, data) {
        var setter = 2;

        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }

        if (arguments.length < setter) {
          return jQuery.queue(this[0], type);
        }

        return data === undefined ? this : this.each(function () {
          var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

          jQuery._queueHooks(this, type);

          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
      },
      dequeue: function (type) {
        return this.each(function () {
          jQuery.dequeue(this, type);
        });
      },
      clearQueue: function (type) {
        return this.queue(type || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function (type, obj) {
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function () {
          if (! --count) {
            defer.resolveWith(elements, [elements]);
          }
        };

        if (typeof type !== "string") {
          obj = type;
          type = undefined;
        }

        type = type || "fx";

        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");

          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }

        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var isHiddenWithinTree = function (elem, el) {
      // isHiddenWithinTree might be called from jQuery#filter function;
      // in that case, element will be second argument
      elem = el || elem; // Inline style trumps all

      return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
    };

    var swap = function (elem, options, callback, args) {
      var ret,
          name,
          old = {}; // Remember the old values, and insert the new ones

      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }

      ret = callback.apply(elem, args || []); // Revert the old values

      for (name in options) {
        elem.style[name] = old[name];
      }

      return ret;
    };

    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted,
          scale,
          maxIterations = 20,
          currentValue = tween ? function () {
        return tween.cur();
      } : function () {
        return jQuery.css(elem, prop, "");
      },
          initial = currentValue(),
          unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
          // Starting value computation is required for potential unit mismatches
      initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

      if (initialInUnit && initialInUnit[3] !== unit) {
        // Support: Firefox <=54
        // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
        initial = initial / 2; // Trust units reported by jQuery.css

        unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

        initialInUnit = +initial || 1;

        while (maxIterations--) {
          // Evaluate and update our best guess (doubling guesses that zero out).
          // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
          jQuery.style(elem, prop, initialInUnit + unit);

          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
            maxIterations = 0;
          }

          initialInUnit = initialInUnit / scale;
        }

        initialInUnit = initialInUnit * 2;
        jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

        valueParts = valueParts || [];
      }

      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }

      return adjusted;
    }

    var defaultDisplayMap = {};

    function getDefaultDisplay(elem) {
      var temp,
          doc = elem.ownerDocument,
          nodeName = elem.nodeName,
          display = defaultDisplayMap[nodeName];

      if (display) {
        return display;
      }

      temp = doc.body.appendChild(doc.createElement(nodeName));
      display = jQuery.css(temp, "display");
      temp.parentNode.removeChild(temp);

      if (display === "none") {
        display = "block";
      }

      defaultDisplayMap[nodeName] = display;
      return display;
    }

    function showHide(elements, show) {
      var display,
          elem,
          values = [],
          index = 0,
          length = elements.length; // Determine new display value for elements that need to change

      for (; index < length; index++) {
        elem = elements[index];

        if (!elem.style) {
          continue;
        }

        display = elem.style.display;

        if (show) {
          // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
          // check is required in this first loop unless we have a nonempty display value (either
          // inline or about-to-be-restored)
          if (display === "none") {
            values[index] = dataPriv.get(elem, "display") || null;

            if (!values[index]) {
              elem.style.display = "";
            }
          }

          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index] = "none"; // Remember what we're overwriting

            dataPriv.set(elem, "display", display);
          }
        }
      } // Set the display of the elements in a second loop to avoid constant reflow


      for (index = 0; index < length; index++) {
        if (values[index] != null) {
          elements[index].style.display = values[index];
        }
      }

      return elements;
    }

    jQuery.fn.extend({
      show: function () {
        return showHide(this, true);
      },
      hide: function () {
        return showHide(this);
      },
      toggle: function (state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }

        return this.each(function () {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i; // We have to close these tags to support XHTML (#13200)

    var wrapMap = {
      // Support: IE <=9 only
      option: [1, "<select multiple='multiple'>", "</select>"],
      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    }; // Support: IE <=9 only

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    function getAll(context, tag) {
      // Support: IE <=9 - 11 only
      // Use typeof to avoid zero-argument method invocation on host objects (#15151)
      var ret;

      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }

      if (tag === undefined || tag && nodeName(context, tag)) {
        return jQuery.merge([context], ret);
      }

      return ret;
    } // Mark scripts as having already been evaluated


    function setGlobalEval(elems, refElements) {
      var i = 0,
          l = elems.length;

      for (; i < l; i++) {
        dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
      }
    }

    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem,
          tmp,
          tag,
          wrap,
          contains,
          j,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i = 0,
          l = elems.length;

      for (; i < l; i++) {
        elem = elems[i];

        if (elem || elem === 0) {
          // Add nodes directly
          if (toType(elem) === "object") {
            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

            j = wrap[0];

            while (j--) {
              tmp = tmp.lastChild;
            } // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit


            jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

            tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

            tmp.textContent = "";
          }
        }
      } // Remove wrapper from fragment


      fragment.textContent = "";
      i = 0;

      while (elem = nodes[i++]) {
        // Skip elements already in the context collection (trac-4087)
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }

          continue;
        }

        contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment

        tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

        if (contains) {
          setGlobalEval(tmp);
        } // Capture executables


        if (scripts) {
          j = 0;

          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }

      return fragment;
    }

    (function () {
      var fragment = document$2.createDocumentFragment(),
          div = fragment.appendChild(document$2.createElement("div")),
          input = document$2.createElement("input"); // Support: Android 4.0 - 4.3 only
      // Check state lost if the name is set (#11217)
      // Support: Windows Web Apps (WWA)
      // `name` and `type` must use .setAttribute for WWA (#14901)

      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input); // Support: Android <=4.1 only
      // Older WebKit doesn't clone checked state correctly in fragments

      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
      // Make sure textarea (and checkbox) defaultValue is properly cloned

      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();

    var documentElement = document$2.documentElement;
    var rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
      return true;
    }

    function returnFalse() {
      return false;
    } // Support: IE <=9 only
    // See #13393 for more info


    function safeActiveElement() {
      try {
        return document$2.activeElement;
      } catch (err) {}
    }

    function on(elem, types, selector, data, fn, one) {
      var origFn, type; // Types can be a map of types/handlers

      if (typeof types === "object") {
        // ( types-Object, selector, data )
        if (typeof selector !== "string") {
          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }

        for (type in types) {
          on(elem, type, selector, data, types[type], one);
        }

        return elem;
      }

      if (data == null && fn == null) {
        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {
          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }

      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }

      if (one === 1) {
        origFn = fn;

        fn = function (event) {
          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        }; // Use same guid so caller can remove using origFn


        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }

      return elem.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    }
    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */


    jQuery.event = {
      global: {},
      add: function (elem, types, handler, data, selector) {
        var handleObjIn,
            eventHandle,
            tmp,
            events,
            t,
            handleObj,
            special,
            handlers,
            type,
            namespaces,
            origType,
            elemData = dataPriv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)

        if (!elemData) {
          return;
        } // Caller can pass in an object of custom data in lieu of the handler


        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        } // Ensure that invalid selectors throw exceptions at attach time
        // Evaluate against documentElement in case elem is a non-element node (e.g., document)


        if (selector) {
          jQuery.find.matchesSelector(documentElement, selector);
        } // Make sure that the handler has a unique ID, used to find/remove it later


        if (!handler.guid) {
          handler.guid = jQuery.guid++;
        } // Init the element's event structure and main handler, if this is the first


        if (!(events = elemData.events)) {
          events = elemData.events = {};
        }

        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function (e) {
            // Discard the second event of a jQuery.event.trigger() and
            // when an event is called after a page has unloaded
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
          };
        } // Handle multiple events separated by a space


        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;

        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

          if (!type) {
            continue;
          } // If event changes its type, use the special event handlers for the changed type


          special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

          type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

          special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

          handleObj = jQuery.extend({
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn); // Init the event handler queue if we're the first

          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }

          if (special.add) {
            special.add.call(elem, handleObj);

            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          } // Add to the element's handler list, delegates in front


          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          } // Keep track of which events have ever been used, for event optimization


          jQuery.event.global[type] = true;
        }
      },
      // Detach an event or set of events from an element
      remove: function (elem, types, handler, selector, mappedTypes) {
        var j,
            origCount,
            tmp,
            events,
            t,
            handleObj,
            special,
            handlers,
            type,
            namespaces,
            origType,
            elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

        if (!elemData || !(events = elemData.events)) {
          return;
        } // Once for each type.namespace in types; type may be omitted


        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;

        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

          if (!type) {
            for (type in events) {
              jQuery.event.remove(elem, type + types[t], handler, selector, true);
            }

            continue;
          }

          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

          origCount = j = handlers.length;

          while (j--) {
            handleObj = handlers[j];

            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);

              if (handleObj.selector) {
                handlers.delegateCount--;
              }

              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          } // Remove generic event handler if we removed something and no more handlers exist
          // (avoids potential for endless recursion during removal of special event handlers)


          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery.removeEvent(elem, type, elemData.handle);
            }

            delete events[type];
          }
        } // Remove data and the expando if it's no longer used


        if (jQuery.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function (nativeEvent) {
        // Make a writable jQuery.Event from the native event object
        var event = jQuery.event.fix(nativeEvent);
        var i,
            j,
            ret,
            matched,
            handleObj,
            handlerQueue,
            args = new Array(arguments.length),
            handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
            special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

        args[0] = event;

        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }

        event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        } // Determine handlers


        handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

        i = 0;

        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;

          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            // Triggered event must either 1) have no namespace, or 2) have namespace(s)
            // a subset or equal to those in the bound event (both can have no namespace).
            if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

              if (ret !== undefined) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        } // Call the postDispatch hook for the mapped type


        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }

        return event.result;
      },
      handlers: function (event, handlers) {
        var i,
            handleObj,
            sel,
            matchedHandlers,
            matchedSelectors,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target; // Find delegate handlers

        if (delegateCount && // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType && // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            // Don't check non-elements (#13208)
            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};

              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

                sel = handleObj.selector + " ";

                if (matchedSelectors[sel] === undefined) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                }

                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }

              if (matchedHandlers.length) {
                handlerQueue.push({
                  elem: cur,
                  handlers: matchedHandlers
                });
              }
            }
          }
        } // Add the remaining (directly-bound) handlers


        cur = this;

        if (delegateCount < handlers.length) {
          handlerQueue.push({
            elem: cur,
            handlers: handlers.slice(delegateCount)
          });
        }

        return handlerQueue;
      },
      addProp: function (name, hook) {
        Object.defineProperty(jQuery.Event.prototype, name, {
          enumerable: true,
          configurable: true,
          get: isFunction(hook) ? function () {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function () {
            if (this.originalEvent) {
              return this.originalEvent[name];
            }
          },
          set: function (value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value: value
            });
          }
        });
      },
      fix: function (originalEvent) {
        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        focus: {
          // Fire native event if possible so blur/focus sequence is correct
          trigger: function () {
            if (this !== safeActiveElement() && this.focus) {
              this.focus();
              return false;
            }
          },
          delegateType: "focusin"
        },
        blur: {
          trigger: function () {
            if (this === safeActiveElement() && this.blur) {
              this.blur();
              return false;
            }
          },
          delegateType: "focusout"
        },
        click: {
          // For checkbox, fire native event so checked state will be right
          trigger: function () {
            if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
              this.click();
              return false;
            }
          },
          // For cross-browser consistency, don't fire native .click() on links
          _default: function (event) {
            return nodeName(event.target, "a");
          }
        },
        beforeunload: {
          postDispatch: function (event) {
            // Support: Firefox 20+
            // Firefox doesn't alert if the returnValue field is not set.
            if (event.result !== undefined && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };

    jQuery.removeEvent = function (elem, type, handle) {
      // This "if" is needed for plain objects
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };

    jQuery.Event = function (src, props) {
      // Allow instantiation without the 'new' keyword
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src, props);
      } // Event object


      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type; // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.

        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
        src.returnValue === false ? returnTrue : returnFalse; // Create target properties
        // Support: Safari <=6 - 7 only
        // Target should not be a text node (#504, #13143)

        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget; // Event type
      } else {
        this.type = src;
      } // Put explicitly provided properties onto the event object


      if (props) {
        jQuery.extend(this, props);
      } // Create a timestamp if incoming event doesn't have one


      this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

      this[jQuery.expando] = true;
    }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function () {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;

        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function () {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;

        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function () {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;

        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }

        this.stopPropagation();
      }
    }; // Includes all common event props including KeyEvent and MouseEvent specific props

    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: function (event) {
        var button = event.button; // Add which for key events

        if (event.which == null && rkeyEvent.test(event.type)) {
          return event.charCode != null ? event.charCode : event.keyCode;
        } // Add which for click: 1 === left; 2 === middle; 3 === right


        if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
          if (button & 1) {
            return 1;
          }

          if (button & 2) {
            return 3;
          }

          if (button & 4) {
            return 2;
          }

          return 0;
        }

        return event.which;
      }
    }, jQuery.event.addProp); // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).

    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function (orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function (event) {
          var ret,
              target = this,
              related = event.relatedTarget,
              handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
          // NB: No relatedTarget if the mouse left/entered the browser window

          if (!related || related !== target && !jQuery.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }

          return ret;
        }
      };
    });
    jQuery.fn.extend({
      on: function (types, selector, data, fn) {
        return on(this, types, selector, data, fn);
      },
      one: function (types, selector, data, fn) {
        return on(this, types, selector, data, fn, 1);
      },
      off: function (types, selector, fn) {
        var handleObj, type;

        if (types && types.preventDefault && types.handleObj) {
          // ( event )  dispatched jQuery.Event
          handleObj = types.handleObj;
          jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
          return this;
        }

        if (typeof types === "object") {
          // ( types-object [, selector] )
          for (type in types) {
            this.off(type, selector, types[type]);
          }

          return this;
        }

        if (selector === false || typeof selector === "function") {
          // ( types [, fn] )
          fn = selector;
          selector = undefined;
        }

        if (fn === false) {
          fn = returnFalse;
        }

        return this.each(function () {
          jQuery.event.remove(this, types, fn, selector);
        });
      }
    });
    var
    /* eslint-disable max-len */
    // See https://github.com/eslint/eslint/issues/3229
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

    /* eslint-enable */
    // Support: IE <=10 - 11, Edge 12 - 13 only
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i,
        // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery(elem).children("tbody")[0] || elem;
      }

      return elem;
    } // Replace/restore the type attribute of script elements for safe DOM manipulation


    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }

    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }

      return elem;
    }

    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

      if (dest.nodeType !== 1) {
        return;
      } // 1. Copy private data: events, handlers, etc.


      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.access(src);
        pdataCur = dataPriv.set(dest, pdataOld);
        events = pdataOld.events;

        if (events) {
          delete pdataCur.handle;
          pdataCur.events = {};

          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery.event.add(dest, type, events[type][i]);
            }
          }
        }
      } // 2. Copy user data


      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    } // Fix IE bugs, see support tests


    function fixInput(src, dest) {
      var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

      if (nodeName === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
      } else if (nodeName === "input" || nodeName === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }

    function domManip(collection, args, callback, ignored) {
      // Flatten any nested arrays
      args = concat.apply([], args);
      var fragment,
          first,
          scripts,
          hasScripts,
          node,
          doc,
          i = 0,
          l = collection.length,
          iNoClone = l - 1,
          value = args[0],
          valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function (index) {
          var self = collection.eq(index);

          if (valueIsFunction) {
            args[0] = value.call(this, index, self.html());
          }

          domManip(self, args, callback, ignored);
        });
      }

      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;

        if (fragment.childNodes.length === 1) {
          fragment = first;
        } // Require either new content or an interest in ignored elements to invoke the callback


        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length; // Use the original fragment for the last item
          // instead of the first because it can end up
          // being emptied incorrectly in certain situations (#8070).

          for (; i < l; i++) {
            node = fragment;

            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

              if (hasScripts) {
                // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }

            callback.call(collection[i], node, i);
          }

          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

            jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];

              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src && (node.type || "").toLowerCase() !== "module") {
                  // Optional AJAX dependency, but won't run scripts if not present
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
                }
              }
            }
          }
        }
      }

      return collection;
    }

    function remove(elem, selector, keepData) {
      var node,
          nodes = selector ? jQuery.filter(selector, elem) : elem,
          i = 0;

      for (; (node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery.cleanData(getAll(node));
        }

        if (node.parentNode) {
          if (keepData && jQuery.contains(node.ownerDocument, node)) {
            setGlobalEval(getAll(node, "script"));
          }

          node.parentNode.removeChild(node);
        }
      }

      return elem;
    }

    jQuery.extend({
      htmlPrefilter: function (html) {
        return html.replace(rxhtmlTag, "<$1></$2>");
      },
      clone: function (elem, dataAndEvents, deepDataAndEvents) {
        var i,
            l,
            srcElements,
            destElements,
            clone = elem.cloneNode(true),
            inPage = jQuery.contains(elem.ownerDocument, elem); // Fix IE cloning issues

        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
          // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
          destElements = getAll(clone);
          srcElements = getAll(elem);

          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        } // Copy the events from the original to the clone


        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone);

            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone);
          }
        } // Preserve script evaluation history


        destElements = getAll(clone, "script");

        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        } // Return the cloned set


        return clone;
      },
      cleanData: function (elems) {
        var data,
            elem,
            type,
            special = jQuery.event.special,
            i = 0;

        for (; (elem = elems[i]) !== undefined; i++) {
          if (acceptData(elem)) {
            if (data = elem[dataPriv.expando]) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                  } else {
                    jQuery.removeEvent(elem, type, data.handle);
                  }
                }
              } // Support: Chrome <=35 - 45+
              // Assign undefined instead of using delete, see Data#remove


              elem[dataPriv.expando] = undefined;
            }

            if (elem[dataUser.expando]) {
              // Support: Chrome <=35 - 45+
              // Assign undefined instead of using delete, see Data#remove
              elem[dataUser.expando] = undefined;
            }
          }
        }
      }
    });
    jQuery.fn.extend({
      detach: function (selector) {
        return remove(this, selector, true);
      },
      remove: function (selector) {
        return remove(this, selector);
      },
      text: function (value) {
        return access(this, function (value) {
          return value === undefined ? jQuery.text(this) : this.empty().each(function () {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value;
            }
          });
        }, null, value, arguments.length);
      },
      append: function () {
        return domManip(this, arguments, function (elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function () {
        return domManip(this, arguments, function (elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function () {
        return domManip(this, arguments, function (elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function () {
        return domManip(this, arguments, function (elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function () {
        var elem,
            i = 0;

        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            // Prevent memory leaks
            jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

            elem.textContent = "";
          }
        }

        return this;
      },
      clone: function (dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function () {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function (value) {
        return access(this, function (value) {
          var elem = this[0] || {},
              i = 0,
              l = this.length;

          if (value === undefined && elem.nodeType === 1) {
            return elem.innerHTML;
          } // See if we can take a shortcut and just use innerHTML


          if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
            value = jQuery.htmlPrefilter(value);

            try {
              for (; i < l; i++) {
                elem = this[i] || {}; // Remove element nodes and prevent memory leaks

                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value;
                }
              }

              elem = 0; // If using innerHTML throws an exception, use the fallback method
            } catch (e) {}
          }

          if (elem) {
            this.empty().append(value);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function () {
        var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

        return domManip(this, arguments, function (elem) {
          var parent = this.parentNode;

          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));

            if (parent) {
              parent.replaceChild(elem, this);
            }
          } // Force callback invocation

        }, ignored);
      }
    });
    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function (name, original) {
      jQuery.fn[name] = function (selector) {
        var elems,
            ret = [],
            insert = jQuery(selector),
            last = insert.length - 1,
            i = 0;

        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
          // .get() because push.apply(_, arraylike) throws on ancient WebKit

          push.apply(ret, elems.get());
        }

        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function (elem) {
      // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
      // IE throws on elements created in popups
      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
      var view = elem.ownerDocument.defaultView;

      if (!view || !view.opener) {
        view = window;
      }

      return view.getComputedStyle(elem);
    };

    var rboxStyle = new RegExp(cssExpand.join("|"), "i");

    (function () {
      // Executing both pixelPosition & boxSizingReliable tests require only one layout
      // so they're executed at the same time to save the second computation.
      function computeStyleTests() {
        // This is a singleton, we need to execute it only once
        if (!div) {
          return;
        }

        container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
        // Some styles come back with percentage values, even though they shouldn't

        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
        // Detect misreporting of content dimensions for box-sizing:border-box elements

        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
        // Detect overflow:scroll screwiness (gh-3699)

        div.style.position = "absolute";
        scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
        documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
        // it will also be a sign that checks already performed

        div = null;
      }

      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }

      var pixelPositionVal,
          boxSizingReliableVal,
          scrollboxSizeVal,
          pixelBoxStylesVal,
          reliableMarginLeftVal,
          container = document$2.createElement("div"),
          div = document$2.createElement("div"); // Finish early in limited (non-browser) environments

      if (!div.style) {
        return;
      } // Support: IE <=9 - 11 only
      // Style of cloned element affects source element cloned (#8908)


      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery.extend(support, {
        boxSizingReliable: function () {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function () {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function () {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function () {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function () {
          computeStyleTests();
          return scrollboxSizeVal;
        }
      });
    })();

    function curCSS(elem, name, computed) {
      var width,
          minWidth,
          maxWidth,
          ret,
          // Support: Firefox 51+
      // Retrieving style before computed somehow
      // fixes an issue with getting wrong values
      // on detached elements
      style = elem.style;
      computed = computed || getStyles(elem); // getPropertyValue is needed for:
      //   .css('filter') (IE 9 only, #12537)
      //   .css('--customProperty) (#3144)

      if (computed) {
        ret = computed.getPropertyValue(name) || computed[name];

        if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
          ret = jQuery.style(elem, name);
        } // A tribute to the "awesome hack by Dean Edwards"
        // Android Browser returns percentage for some values,
        // but width seems to be reliably pixels.
        // This is against the CSSOM draft spec:
        // https://drafts.csswg.org/cssom/#resolved-values


        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
          // Remember the original values
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth; // Put in the new values to get a computed value out

          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width; // Revert the changed values

          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }

      return ret !== undefined ? // Support: IE <=9 - 11 only
      // IE returns zIndex value as an integer.
      ret + "" : ret;
    }

    function addGetHookIf(conditionFn, hookFn) {
      // Define the hook, we'll check on the first run if it's really needed.
      return {
        get: function () {
          if (conditionFn()) {
            // Hook not needed (or it's not possible to use it due
            // to missing dependency), remove it.
            delete this.get;
            return;
          } // Hook needed; redefine it so that the support test is not executed again.


          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }

    var // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
        cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    },
        cssPrefixes = ["Webkit", "Moz", "ms"],
        emptyStyle = document$2.createElement("div").style; // Return a css property mapped to a potentially vendor prefixed property

    function vendorPropName(name) {
      // Shortcut for names that are not vendor prefixed
      if (name in emptyStyle) {
        return name;
      } // Check for vendor prefixed names


      var capName = name[0].toUpperCase() + name.slice(1),
          i = cssPrefixes.length;

      while (i--) {
        name = cssPrefixes[i] + capName;

        if (name in emptyStyle) {
          return name;
        }
      }
    } // Return a property mapped along what jQuery.cssProps suggests or to
    // a vendor prefixed property.


    function finalPropName(name) {
      var ret = jQuery.cssProps[name];

      if (!ret) {
        ret = jQuery.cssProps[name] = vendorPropName(name) || name;
      }

      return ret;
    }

    function setPositiveNumber(elem, value, subtract) {
      // Any relative (+/-) values have already been
      // normalized at this point
      var matches = rcssNum.exec(value);
      return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
      Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }

    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i = dimension === "width" ? 1 : 0,
          extra = 0,
          delta = 0; // Adjustment may not be necessary

      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }

      for (; i < 4; i += 2) {
        // Both box models exclude margin
        if (box === "margin") {
          delta += jQuery.css(elem, box + cssExpand[i], true, styles);
        } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


        if (!isBorderBox) {
          // Add padding
          delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

          if (box !== "padding") {
            delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
          } else {
            extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          } // If we get here with a border-box (content + padding + border), we're seeking "content" or
          // "padding" or "margin"

        } else {
          // For "content", subtract padding
          if (box === "content") {
            delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          } // For "content" or "padding", subtract border


          if (box !== "margin") {
            delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      } // Account for positive content-box scroll gutter when requested by providing computedVal


      if (!isBorderBox && computedVal >= 0) {
        // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
        // Assuming integer scroll gutter, subtract the rest and round down
        delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
      }

      return delta;
    }

    function getWidthOrHeight(elem, dimension, extra) {
      // Start with computed style
      var styles = getStyles(elem),
          val = curCSS(elem, dimension, styles),
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
          valueIsBorderBox = isBorderBox; // Support: Firefox <=54
      // Return a confounding non-pixel value or feign ignorance, as appropriate.

      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }

        val = "auto";
      } // Check for style in case a browser which returns unreliable values
      // for getComputedStyle silently falls back to the reliable elem.style


      valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]); // Fall back to offsetWidth/offsetHeight when value is "auto"
      // This happens for inline elements with no explicit setting (gh-3571)
      // Support: Android <=4.1 - 4.3 only
      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)

      if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
        val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)]; // offsetWidth/offsetHeight provide border-box values

        valueIsBorderBox = true;
      } // Normalize "" and auto


      val = parseFloat(val) || 0; // Adjust for the element's box model

      return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
      val) + "px";
    }

    jQuery.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function (elem, computed) {
            if (computed) {
              // We should always get a number back from opacity
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {},
      // Get and set the style property on a DOM Node
      style: function (elem, name, value, extra) {
        // Don't set styles on text and comment nodes
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        } // Make sure that we're working with the right name


        var ret,
            type,
            hooks,
            origName = camelCase(name),
            isCustomProp = rcustomProp.test(name),
            style = elem.style; // Make sure that we're working with the right name. We don't
        // want to query the value if it is a CSS custom property
        // since they are user-defined.

        if (!isCustomProp) {
          name = finalPropName(origName);
        } // Gets hook for the prefixed version, then unprefixed version


        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

        if (value !== undefined) {
          type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret); // Fixes bug #9237

            type = "number";
          } // Make sure that null and NaN values aren't set (#7116)


          if (value == null || value !== value) {
            return;
          } // If a number was passed in, add the unit (except for certain CSS properties)


          if (type === "number") {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          } // background-* props affect original clone's values


          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          } // If a hook was provided, use that value, otherwise just set the specified value


          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
            if (isCustomProp) {
              style.setProperty(name, value);
            } else {
              style[name] = value;
            }
          }
        } else {
          // If a hook was provided get the non-computed value from there
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
            return ret;
          } // Otherwise just get the value from the style object


          return style[name];
        }
      },
      css: function (elem, name, extra, styles) {
        var val,
            num,
            hooks,
            origName = camelCase(name),
            isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
        // want to modify the value if it is a CSS custom property
        // since they are user-defined.

        if (!isCustomProp) {
          name = finalPropName(origName);
        } // Try prefixed name followed by the unprefixed name


        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        } // Otherwise, if a way to get the computed value exists, use that


        if (val === undefined) {
          val = curCSS(elem, name, styles);
        } // Convert "normal" to computed value


        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        } // Make numeric if forced or a qualifier was provided and val looks numeric


        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }

        return val;
      }
    });
    jQuery.each(["height", "width"], function (i, dimension) {
      jQuery.cssHooks[dimension] = {
        get: function (elem, computed, extra) {
          if (computed) {
            // Certain elements can have dimension info if we invisibly show them
            // but it must have a current display style that would benefit
            return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function (elem, value, extra) {
          var matches,
              styles = getStyles(elem),
              isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
              subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles); // Account for unreliable border-box dimensions by comparing offset* to computed and
          // faking a content-box to get border and padding (gh-3699)

          if (isBorderBox && support.scrollboxSize() === styles.position) {
            subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
          } // Convert to pixels if value adjustment is needed


          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery.css(elem, dimension);
          }

          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
      if (computed) {
        return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
          marginLeft: 0
        }, function () {
          return elem.getBoundingClientRect().left;
        })) + "px";
      }
    }); // These hooks are used by animate to expand properties

    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function (prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function (value) {
          var i = 0,
              expanded = {},
              // Assumes a single number if not a string
          parts = typeof value === "string" ? value.split(" ") : [value];

          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }

          return expanded;
        }
      };

      if (prefix !== "margin") {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery.fn.extend({
      css: function (name, value) {
        return access(this, function (elem, name, value) {
          var styles,
              len,
              map = {},
              i = 0;

          if (Array.isArray(name)) {
            styles = getStyles(elem);
            len = name.length;

            for (; i < len; i++) {
              map[name[i]] = jQuery.css(elem, name[i], false, styles);
            }

            return map;
          }

          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
        }, name, value, arguments.length > 1);
      }
    }); // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

    jQuery.fn.delay = function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function (next, hooks) {
        var timeout = window.setTimeout(next, time);

        hooks.stop = function () {
          window.clearTimeout(timeout);
        };
      });
    };

    (function () {
      var input = document$2.createElement("input"),
          select = document$2.createElement("select"),
          opt = select.appendChild(document$2.createElement("option"));
      input.type = "checkbox"; // Support: Android <=4.3 only
      // Default value for a checkbox should be "on"

      support.checkOn = input.value !== ""; // Support: IE <=11 only
      // Must access selectedIndex to make default options select

      support.optSelected = opt.selected; // Support: IE <=11 only
      // An input loses its value after becoming a radio

      input = document$2.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();

    var boolHook,
        attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
      attr: function (name, value) {
        return access(this, jQuery.attr, name, value, arguments.length > 1);
      },
      removeAttr: function (name) {
        return this.each(function () {
          jQuery.removeAttr(this, name);
        });
      }
    });
    jQuery.extend({
      attr: function (elem, name, value) {
        var ret,
            hooks,
            nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        } // Fallback to prop when attributes are not supported


        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name, value);
        } // Attribute hooks are determined by the lowercase version
        // Grab necessary hook if one is defined


        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
        }

        if (value !== undefined) {
          if (value === null) {
            jQuery.removeAttr(elem, name);
            return;
          }

          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }

          elem.setAttribute(name, value + "");
          return value;
        }

        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }

        ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

        return ret == null ? undefined : ret;
      },
      attrHooks: {
        type: {
          set: function (elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);

              if (val) {
                elem.value = val;
              }

              return value;
            }
          }
        }
      },
      removeAttr: function (elem, value) {
        var name,
            i = 0,
            // Attribute names can contain non-HTML whitespace characters
        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
        attrNames = value && value.match(rnothtmlwhite);

        if (attrNames && elem.nodeType === 1) {
          while (name = attrNames[i++]) {
            elem.removeAttribute(name);
          }
        }
      }
    }); // Hooks for boolean attributes

    boolHook = {
      set: function (elem, value, name) {
        if (value === false) {
          // Remove boolean attributes when set to false
          jQuery.removeAttr(elem, name);
        } else {
          elem.setAttribute(name, name);
        }

        return name;
      }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
      var getter = attrHandle[name] || jQuery.find.attr;

      attrHandle[name] = function (elem, name, isXML) {
        var ret,
            handle,
            lowercaseName = name.toLowerCase();

        if (!isXML) {
          // Avoid an infinite loop by temporarily removing this function from the getter
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }

        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
      prop: function (name, value) {
        return access(this, jQuery.prop, name, value, arguments.length > 1);
      },
      removeProp: function (name) {
        return this.each(function () {
          delete this[jQuery.propFix[name] || name];
        });
      }
    });
    jQuery.extend({
      prop: function (elem, name, value) {
        var ret,
            hooks,
            nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }

        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          // Fix name and attach hooks
          name = jQuery.propFix[name] || name;
          hooks = jQuery.propHooks[name];
        }

        if (value !== undefined) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }

          return elem[name] = value;
        }

        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }

        return elem[name];
      },
      propHooks: {
        tabIndex: {
          get: function (elem) {
            // Support: IE <=9 - 11 only
            // elem.tabIndex doesn't always return the
            // correct value when it hasn't been explicitly set
            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
            // Use proper attribute retrieval(#12072)
            var tabindex = jQuery.find.attr(elem, "tabindex");

            if (tabindex) {
              return parseInt(tabindex, 10);
            }

            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }

            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    }); // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop

    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function (elem) {
          /* eslint no-unused-expressions: "off" */
          var parent = elem.parentNode;

          if (parent && parent.parentNode) {
            parent.parentNode.selectedIndex;
          }

          return null;
        },
        set: function (elem) {
          /* eslint no-unused-expressions: "off" */
          var parent = elem.parentNode;

          if (parent) {
            parent.selectedIndex;

            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }

    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
      jQuery.propFix[this.toLowerCase()] = this;
    }); // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }

    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }

    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }

      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }

      return [];
    }

    jQuery.fn.extend({
      addClass: function (value) {
        var classes,
            elem,
            cur,
            curValue,
            clazz,
            j,
            finalValue,
            i = 0;

        if (isFunction(value)) {
          return this.each(function (j) {
            jQuery(this).addClass(value.call(this, j, getClass(this)));
          });
        }

        classes = classesToArray(value);

        if (classes.length) {
          while (elem = this[i++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

            if (cur) {
              j = 0;

              while (clazz = classes[j++]) {
                if (cur.indexOf(" " + clazz + " ") < 0) {
                  cur += clazz + " ";
                }
              } // Only assign if different to avoid unneeded rendering.


              finalValue = stripAndCollapse(cur);

              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }

        return this;
      },
      removeClass: function (value) {
        var classes,
            elem,
            cur,
            curValue,
            clazz,
            j,
            finalValue,
            i = 0;

        if (isFunction(value)) {
          return this.each(function (j) {
            jQuery(this).removeClass(value.call(this, j, getClass(this)));
          });
        }

        if (!arguments.length) {
          return this.attr("class", "");
        }

        classes = classesToArray(value);

        if (classes.length) {
          while (elem = this[i++]) {
            curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

            if (cur) {
              j = 0;

              while (clazz = classes[j++]) {
                // Remove *all* instances
                while (cur.indexOf(" " + clazz + " ") > -1) {
                  cur = cur.replace(" " + clazz + " ", " ");
                }
              } // Only assign if different to avoid unneeded rendering.


              finalValue = stripAndCollapse(cur);

              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }

        return this;
      },
      toggleClass: function (value, stateVal) {
        var type = typeof value,
            isValidValue = type === "string" || Array.isArray(value);

        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }

        if (isFunction(value)) {
          return this.each(function (i) {
            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
          });
        }

        return this.each(function () {
          var className, i, self, classNames;

          if (isValidValue) {
            // Toggle individual class names
            i = 0;
            self = jQuery(this);
            classNames = classesToArray(value);

            while (className = classNames[i++]) {
              // Check each className given, space separated list
              if (self.hasClass(className)) {
                self.removeClass(className);
              } else {
                self.addClass(className);
              }
            } // Toggle whole class name

          } else if (value === undefined || type === "boolean") {
            className = getClass(this);

            if (className) {
              // Store className if set
              dataPriv.set(this, "__className__", className);
            } // If the element has a class name or if we're passed `false`,
            // then remove the whole classname (if there was one, the above saved it).
            // Otherwise bring back whatever was previously saved (if anything),
            // falling back to the empty string if nothing was stored.


            if (this.setAttribute) {
              this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
            }
          }
        });
      },
      hasClass: function (selector) {
        var className,
            elem,
            i = 0;
        className = " " + selector + " ";

        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }

        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
      val: function (value) {
        var hooks,
            ret,
            valueIsFunction,
            elem = this[0];

        if (!arguments.length) {
          if (elem) {
            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
              return ret;
            }

            ret = elem.value; // Handle most common string cases

            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            } // Handle cases where value is null/undef or number


            return ret == null ? "" : ret;
          }

          return;
        }

        valueIsFunction = isFunction(value);
        return this.each(function (i) {
          var val;

          if (this.nodeType !== 1) {
            return;
          }

          if (valueIsFunction) {
            val = value.call(this, i, jQuery(this).val());
          } else {
            val = value;
          } // Treat null/undefined as ""; convert numbers to string


          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery.map(val, function (value) {
              return value == null ? "" : value + "";
            });
          }

          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
            this.value = val;
          }
        });
      }
    });
    jQuery.extend({
      valHooks: {
        option: {
          get: function (elem) {
            var val = jQuery.find.attr(elem, "value");
            return val != null ? val : // Support: IE <=10 - 11 only
            // option.text throws exceptions (#14686, #14858)
            // Strip and collapse whitespace
            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
            stripAndCollapse(jQuery.text(elem));
          }
        },
        select: {
          get: function (elem) {
            var value,
                option,
                i,
                options = elem.options,
                index = elem.selectedIndex,
                one = elem.type === "select-one",
                values = one ? null : [],
                max = one ? index + 1 : options.length;

            if (index < 0) {
              i = max;
            } else {
              i = one ? index : 0;
            } // Loop through all the selected options


            for (; i < max; i++) {
              option = options[i]; // Support: IE <=9 only
              // IE8-9 doesn't update selected after form reset (#2551)

              if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
              !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                // Get the specific value for the option
                value = jQuery(option).val(); // We don't need an array for one selects

                if (one) {
                  return value;
                } // Multi-Selects return an array


                values.push(value);
              }
            }

            return values;
          },
          set: function (elem, value) {
            var optionSet,
                option,
                options = elem.options,
                values = jQuery.makeArray(value),
                i = options.length;

            while (i--) {
              option = options[i];
              /* eslint-disable no-cond-assign */

              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                optionSet = true;
              }
              /* eslint-enable no-cond-assign */

            } // Force browsers to behave consistently when non-matching value is set


            if (!optionSet) {
              elem.selectedIndex = -1;
            }

            return values;
          }
        }
      }
    }); // Radios and checkboxes getter/setter

    jQuery.each(["radio", "checkbox"], function () {
      jQuery.valHooks[this] = {
        set: function (elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
          }
        }
      };

      if (!support.checkOn) {
        jQuery.valHooks[this].get = function (elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    }); // Return jQuery for attributes-only inclusion

    support.focusin = "onfocusin" in window;

    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function (e) {
      e.stopPropagation();
    };

    jQuery.extend(jQuery.event, {
      trigger: function (event, data, elem, onlyHandlers) {
        var i,
            cur,
            tmp,
            bubbleType,
            ontype,
            handle,
            special,
            lastElement,
            eventPath = [elem || document$2],
            type = hasOwn$6.call(event, "type") ? event.type : event,
            namespaces = hasOwn$6.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document$2; // Don't do events on text and comment nodes

        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        } // focus/blur morphs to focusin/out; ensure we're not firing them right now


        if (rfocusMorph.test(type + jQuery.event.triggered)) {
          return;
        }

        if (type.indexOf(".") > -1) {
          // Namespaced trigger; create a regexp to match event type in handle()
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }

        ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

        event.result = undefined;

        if (!event.target) {
          event.target = elem;
        } // Clone any incoming data and prepend the event, creating the handler arg list


        data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

        special = jQuery.event.special[type] || {};

        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        } // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
          bubbleType = special.delegateType || type;

          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }

          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          } // Only add window if we got to document (e.g., not plain obj or detached DOM)


          if (tmp === (elem.ownerDocument || document$2)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
          }
        } // Fire handlers on the event path


        i = 0;

        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

          handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");

          if (handle) {
            handle.apply(cur, data);
          } // Native handler


          handle = ontype && cur[ontype];

          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);

            if (event.result === false) {
              event.preventDefault();
            }
          }
        }

        event.type = type; // If nobody prevented the default action, do it now

        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            // Call a native DOM method on the target with the same name as the event.
            // Don't do default actions on window, that's where global variables be (#6170)
            if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
              // Don't re-trigger an onFOO event when we call its FOO() method
              tmp = elem[ontype];

              if (tmp) {
                elem[ontype] = null;
              } // Prevent re-triggering of the same event, since we already bubbled it above


              jQuery.event.triggered = type;

              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }

              elem[type]();

              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }

              jQuery.event.triggered = undefined;

              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }

        return event.result;
      },
      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function (type, elem, event) {
        var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true
        });
        jQuery.event.trigger(e, null, elem);
      }
    });
    jQuery.fn.extend({
      trigger: function (type, data) {
        return this.each(function () {
          jQuery.event.trigger(type, data, this);
        });
      },
      triggerHandler: function (type, data) {
        var elem = this[0];

        if (elem) {
          return jQuery.event.trigger(type, data, elem, true);
        }
      }
    }); // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

    if (!support.focusin) {
      jQuery.each({
        focus: "focusin",
        blur: "focusout"
      }, function (orig, fix) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };

        jQuery.event.special[fix] = {
          setup: function () {
            var doc = this.ownerDocument || this,
                attaches = dataPriv.access(doc, fix);

            if (!attaches) {
              doc.addEventListener(orig, handler, true);
            }

            dataPriv.access(doc, fix, (attaches || 0) + 1);
          },
          teardown: function () {
            var doc = this.ownerDocument || this,
                attaches = dataPriv.access(doc, fix) - 1;

            if (!attaches) {
              doc.removeEventListener(orig, handler, true);
              dataPriv.remove(doc, fix);
            } else {
              dataPriv.access(doc, fix, attaches);
            }
          }
        };
      });
    }

    var rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
      var name;

      if (Array.isArray(obj)) {
        // Serialize array item.
        jQuery.each(obj, function (i, v) {
          if (traditional || rbracket.test(prefix)) {
            // Treat each array item as a scalar.
            add(prefix, v);
          } else {
            // Item is non-scalar (array or object), encode its numeric index.
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
          }
        });
      } else if (!traditional && toType(obj) === "object") {
        // Serialize object item.
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        }
      } else {
        // Serialize scalar item.
        add(prefix, obj);
      }
    } // Serialize an array of form elements or a set of
    // key/values into a query string


    jQuery.param = function (a, traditional) {
      var prefix,
          s = [],
          add = function (key, valueOrFunction) {
        // If value is a function, invoke it and use its return value
        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      }; // If an array was passed in, assume that it is an array of form elements.


      if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
        // Serialize the form elements
        jQuery.each(a, function () {
          add(this.name, this.value);
        });
      } else {
        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add);
        }
      } // Return the resulting serialization


      return s.join("&");
    };

    jQuery.fn.extend({
      serialize: function () {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function () {
        return this.map(function () {
          // Can add propHook for "elements" to filter or add form elements
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function () {
          var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function (i, elem) {
          var val = jQuery(this).val();

          if (val == null) {
            return null;
          }

          if (Array.isArray(val)) {
            return jQuery.map(val, function (val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              };
            });
          }

          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }).get();
      }
    });
    jQuery.fn.extend({
      wrapAll: function (html) {
        var wrap;

        if (this[0]) {
          if (isFunction(html)) {
            html = html.call(this[0]);
          } // The elements to wrap the target around


          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }

          wrap.map(function () {
            var elem = this;

            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }

            return elem;
          }).append(this);
        }

        return this;
      },
      wrapInner: function (html) {
        if (isFunction(html)) {
          return this.each(function (i) {
            jQuery(this).wrapInner(html.call(this, i));
          });
        }

        return this.each(function () {
          var self = jQuery(this),
              contents = self.contents();

          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self.append(html);
          }
        });
      },
      wrap: function (html) {
        var htmlIsFunction = isFunction(html);
        return this.each(function (i) {
          jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function (selector) {
        this.parent(selector).not("body").each(function () {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });

    jQuery.expr.pseudos.hidden = function (elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };

    jQuery.expr.pseudos.visible = function (elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    }; // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337


    support.createHTMLDocument = function () {
      var body = document$2.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }(); // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string


    jQuery.parseHTML = function (data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }

      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }

      var base, parsed, scripts;

      if (!context) {
        // Stop scripts or inline event handlers from being executed immediately
        // by using document.implementation
        if (support.createHTMLDocument) {
          context = document$2.implementation.createHTMLDocument(""); // Set the base href for the created document
          // so any parsed elements with URLs
          // are based on the document's URL (gh-2965)

          base = context.createElement("base");
          base.href = document$2.location.href;
          context.head.appendChild(base);
        } else {
          context = document$2;
        }
      }

      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && []; // Single tag

      if (parsed) {
        return [context.createElement(parsed[1])];
      }

      parsed = buildFragment([data], context, scripts);

      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }

      return jQuery.merge([], parsed.childNodes);
    };

    jQuery.offset = {
      setOffset: function (elem, options, i) {
        var curPosition,
            curLeft,
            curCSSTop,
            curTop,
            curOffset,
            curCSSLeft,
            calculatePosition,
            position = jQuery.css(elem, "position"),
            curElem = jQuery(elem),
            props = {}; // Set position first, in-case top/left are set even on static elem

        if (position === "static") {
          elem.style.position = "relative";
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
        // top or left is auto and position is either absolute or fixed

        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }

        if (isFunction(options)) {
          // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
          options = options.call(elem, i, jQuery.extend({}, curOffset));
        }

        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }

        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }

        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery.fn.extend({
      // offset() relates an element's border box to the document origin
      offset: function (options) {
        // Preserve chaining for setter
        if (arguments.length) {
          return options === undefined ? this : this.each(function (i) {
            jQuery.offset.setOffset(this, options, i);
          });
        }

        var rect,
            win,
            elem = this[0];

        if (!elem) {
          return;
        } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
        // Support: IE <=11 only
        // Running getBoundingClientRect on a
        // disconnected node in IE throws an error


        if (!elem.getClientRects().length) {
          return {
            top: 0,
            left: 0
          };
        } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      // position() relates an element's margin box to its offset parent's padding box
      // This corresponds to the behavior of CSS absolute positioning
      position: function () {
        if (!this[0]) {
          return;
        }

        var offsetParent,
            offset,
            doc,
            elem = this[0],
            parentOffset = {
          top: 0,
          left: 0
        }; // position:fixed elements are offset from the viewport, which itself always has zero offset

        if (jQuery.css(elem, "position") === "fixed") {
          // Assume position:fixed implies availability of getBoundingClientRect
          offset = elem.getBoundingClientRect();
        } else {
          offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
          // when a statically positioned element is identified

          doc = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc.documentElement;

          while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }

          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            // Incorporate borders into its offset, since they are outside its content origin
            parentOffset = jQuery(offsetParent).offset();
            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
          }
        } // Subtract parent offsets and element margins


        return {
          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },
      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function () {
        return this.map(function () {
          var offsetParent = this.offsetParent;

          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }

          return offsetParent || documentElement;
        });
      }
    }); // Create scrollLeft and scrollTop methods

    jQuery.each({
      scrollLeft: "pageXOffset",
      scrollTop: "pageYOffset"
    }, function (method, prop) {
      var top = "pageYOffset" === prop;

      jQuery.fn[method] = function (val) {
        return access(this, function (elem, method, val) {
          // Coalesce documents and windows
          var win;

          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }

          if (val === undefined) {
            return win ? win[prop] : elem[method];
          }

          if (win) {
            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
          } else {
            elem[method] = val;
          }
        }, method, val, arguments.length);
      };
    }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here

    jQuery.each(["top", "left"], function (i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

          return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
        }
      });
    }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

    jQuery.each({
      Height: "height",
      Width: "width"
    }, function (name, type) {
      jQuery.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function (defaultExtra, funcName) {
        // Margin is only for outerHeight, outerWidth
        jQuery.fn[funcName] = function (margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
              extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function (elem, type, value) {
            var doc;

            if (isWindow(elem)) {
              // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
            } // Get document width or height


            if (elem.nodeType === 9) {
              doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
              // whichever is greatest

              return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
            }

            return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
            jQuery.css(elem, type, extra) : // Set width or height on the element
            jQuery.style(elem, type, value, extra);
          }, type, chainable ? margin : undefined, chainable);
        };
      });
    });
    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
      // Handle event binding
      jQuery.fn[name] = function (data, fn) {
        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
      };
    });
    jQuery.fn.extend({
      hover: function (fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery.fn.extend({
      bind: function (types, data, fn) {
        return this.on(types, null, data, fn);
      },
      unbind: function (types, fn) {
        return this.off(types, null, fn);
      },
      delegate: function (selector, types, data, fn) {
        return this.on(types, selector, data, fn);
      },
      undelegate: function (selector, types, fn) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
      }
    }); // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon

    jQuery.proxy = function (fn, context) {
      var tmp, args, proxy;

      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      } // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.


      if (!isFunction(fn)) {
        return undefined;
      } // Simulated bind


      args = slice.call(arguments, 2);

      proxy = function () {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      }; // Set the guid of unique handler to the same of original handler, so it can be removed


      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    };

    jQuery.holdReady = function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    };

    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;

    jQuery.isNumeric = function (obj) {
      // As of jQuery 3.0, isNumeric is limited to
      // strings and numbers (primitives or objects)
      // that can be coerced to finite numbers (gh-2662)
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      !isNaN(obj - parseFloat(obj));
    };

    const $ = jQuery;

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Test if the given value is a string or number.  Not using typeof as it fails on boxed primitives.
     *
     * @param value
     * @returns boolean
     */


    function isSimpleType(value) {
      const simpleTypes = new Set(["boolean", "number", "string", "symbol"]);
      const valueType = typeof value;
      return value !== undefined && (simpleTypes.has(valueType) || value.substring || value.toFixed);
    }

    function buildOptions$1(config, options) {
      var defaultOptions = {
        oauthToken: config.oauthToken,
        headers: config.headers,
        withCredentials: config.withCredentials,
        filename: config.filename
      };
      return Object.assign(defaultOptions, options);
    }
    /**
     * isMobile test from http://detectmobilebrowsers.com
     * TODO -- improve UI design so this isn't neccessary
     * @returns {boolean}
     */
    // igv.isMobile = function () {
    //
    //     const a = (navigator.userAgent || navigator.vendor || window.opera);
    //     return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) ||
    //         /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
    //
    // }


    const doAutoscale = function (features) {
      var min, max;

      if (features.length > 0) {
        min = Number.MAX_VALUE;
        max = -Number.MAX_VALUE;
        features.forEach(function (f) {
          if (!Number.isNaN(f.value)) {
            min = Math.min(min, f.value);
            max = Math.max(max, f.value);
          }
        }); // Insure we have a zero baseline

        if (max > 0) min = Math.min(0, min);
        if (max < 0) max = 0;
      } else {
        // No features -- default
        min = 0;
        max = 100;
      }

      return {
        min: min,
        max: max
      };
    };
    /*!
     * is-number <https://github.com/jonschlinkert/is-number>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Released under the MIT License.
     */


    const isNumber = function (num) {
      if (typeof num === 'number') {
        return num - num === 0;
      }

      if (typeof num === 'string' && num.trim() !== '') {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }

      return false;
    };

    function inferTrackType(config) {
      translateDeprecatedTypes(config);

      if (config.type) {
        return config.type;
      }

      let format;

      if ("file" === config.sourceType || undefined === config.sourceType && config.url) {
        if (undefined === config.format) {
          const path = isFilePath(config.url) ? config.url.name : config.url;
          format = inferFileFormat(path);
        } else {
          format = config.format.toLowerCase();
        }
      }

      if (format) {
        switch (format) {
          case "bw":
          case "bigwig":
          case "wig":
          case "bedgraph":
          case "tdf":
            return "wig";

          case "vcf":
            return "variant";

          case "seg":
            return "seg";

          case "bam":
          case "cram":
            return "alignment";

          case "bedpe":
          case "bedpe-loop":
            return "interaction";

          case "bp":
            return "arc";

          case "gwas":
            return "gwas";

          case "bed":
          case "bigbed":
          case "bb":
            return "bedtype";

          default:
            return "annotation";
        }
      }
    }

    function translateDeprecatedTypes(config) {
      if (config.featureType) {
        // Translate deprecated "feature" type
        config.type = config.type || config.featureType;
        config.featureType = undefined;
      }

      if ("junctions" === config.type) {
        config.type = "spliceJunctions";
      } else if ("bed" === config.type) {
        config.type = "annotation";
        config.format = config.format || "bed";
      } else if ("annotations" === config.type) {
        config.type = "annotation";
      } else if ("alignments" === config.type) {
        config.type = "alignment";
      } else if ("bam" === config.type) {
        config.type = "alignment";
        config.format = "bam";
      } else if ("vcf" === config.type) {
        config.type = "variant";
        config.format = "vcf";
      } else if ("t2d" === config.type) {
        config.type = "gwas";
      } else if ("FusionJuncSpan" === config.type && !config.format) {
        config.format = "fusionjuncspan";
      } else if ("aed" === config.type) {
        config.type = "annotation";
        config.format = config.format || "aed";
      }
    }

    /**
     * Decoder for bedpe records.
     *
     * Bedpe format was created by Aaron Quinlan et al as part of the bedtools project.
     * The spec is here:  https://bedtools.readthedocs.io/en/latest/content/general-usage.html,  however there
     * are off spec variants, an important one being a 7 column format with score in place of the standard
     * name column.
     *
     * Another common variant is a "hiccups" output file, which is standard bedpe with the exception of a header line
     * of the form
     * chr1    x1    x2    chr2    y1    y2    name    score    strand1    strand2    color    observed    expectedBL    expectedDonut    expectedH    expectedV    fdrBL    fdrDonut    fdrH    fdrV
     *
     * @param tokens
     * @param ignore
     * @returns {{start1: number, end2: number, end1: number, chr1: *, chr2: *, start2: number}|undefined}
     */

    function decodeBedpe(tokens, header) {
      if (tokens.length < 6) {
        console.log("Skipping line: " + tokens.join(' '));
        return undefined;
      }

      var feature = {
        chr1: tokens[0],
        start1: Number.parseInt(tokens[1]),
        end1: Number.parseInt(tokens[2]),
        chr2: tokens[3],
        start2: Number.parseInt(tokens[4]),
        end2: Number.parseInt(tokens[5])
      };

      if (isNaN(feature.start1) || isNaN(feature.end1) || isNaN(feature.start2) || isNaN(feature.end2)) {
        //throw Error(`Error parsing line: ${tokens.join('\t')}`);
        return undefined;
      }

      if (tokens.length > 6 && tokens[6] !== ".") {
        feature.name = tokens[6];
      }

      if (tokens.length > 7 && tokens[7] !== ".") {
        feature.score = parseFloat(tokens[7]);
      }

      if (tokens.length > 8 && tokens[8] !== ".") {
        feature.strand1 = tokens[8];
      }

      if (tokens.length > 9 && tokens[9] !== ".") {
        feature.strand2 = tokens[9];
      } // Optional extra columns


      if (header) {
        const colorColumn = header.colorColumn;

        if (colorColumn && colorColumn < tokens.length) {
          feature.color = IGVColor.createColorString(tokens[colorColumn]);
        }

        const thicknessColumn = header.thicknessColumn;

        if (thicknessColumn && thicknessColumn < tokens.length) {
          feature.thickness = tokens[thicknessColumn];
        }

        if (tokens.length > 10 && header.columnNames && header.columnNames.length === tokens.length) {
          feature.extras = tokens.slice(10);
        }
      } // Set total extent of feature


      if (feature.chr1 === feature.chr2) {
        feature.chr = feature.chr1;
        feature.start = Math.min(feature.start1, feature.start2);
        feature.end = Math.max(feature.end1, feature.end2);
      }

      return feature;
    }
    /**
     * Hack for non-standard bedPE formats, where numeric score can be in column 7 (name field from spec)
     * @param features
     */


    function fixBedPE(features) {
      if (features.length == 0) return; // Assume all features have same properties

      const firstFeature = features[0];

      if (firstFeature.score === undefined && firstFeature.name !== undefined) {
        // Name field (col 7) is sometimes used for score.
        for (let f of features) {
          if (!(isNumber(f.name) || f.name === '.')) return;
        }

        for (let f of features) {
          f.score = parseFloat(f.name);
          delete f.name;
        }
      } // Make copies of inter-chr features, one for each chromosome


      const interChrFeatures = features.filter(f => f.chr1 !== f.chr2);

      for (let f1 of interChrFeatures) {
        const f2 = Object.assign({}, f1);
        f2.dup = true;
        features.push(f2);
        f1.chr = f1.chr1;
        f1.start = f1.start1;
        f1.end = f1.end1;
        f2.chr = f2.chr2;
        f2.start = f2.start2;
        f2.end = f2.end2;
      }
    }
    /**
     * Special decoder for Hic Domain files.   In these files feature1 == feature2, they are really bed records.
     * @param tokens
     * @param ignore
     * @returns {*}
     */


    function decodeBedpeDomain(tokens, header) {
      if (tokens.length < 8) return undefined;
      return {
        chr: tokens[0],
        start: Number.parseInt(tokens[1]),
        end: Number.parseInt(tokens[2]),
        color: IGVColor.createColorString(tokens[6]),
        value: Number.parseFloat(tokens[7])
      };
    }

    /**
     * Decode UCSC "interact" files.  See https://genome.ucsc.edu/goldenpath/help/interact.html
     *
     0  string chrom;        "Chromosome (or contig, scaffold, etc.). For interchromosomal, use 2 records"
     1  uint chromStart;     "Start position of lower region. For interchromosomal, set to chromStart of this region"
     2  uint chromEnd;       "End position of upper region. For interchromosomal, set to chromEnd of this region"
     3  string name;         "Name of item, for display.  Usually 'sourceName/targetName/exp' or empty"
     4  uint score;          "Score (0-1000)"
     5  double value;        "Strength of interaction or other data value. Typically basis for score"
     6  string exp;          "Experiment name (metadata for filtering). Use . if not applicable"
     7  string color;        "Item color.  Specified as r,g,b or hexadecimal #RRGGBB or html color name, as in //www.w3.org/TR/css3-color/#html4. Use 0 and spectrum setting to shade by score"
     8  string sourceChrom;  "Chromosome of source region (directional) or lower region. For non-directional interchromosomal, chrom of this region."
     9  uint sourceStart;    "Start position in chromosome of source/lower/this region"
     10 uint sourceEnd;      "End position in chromosome of source/lower/this region"
     11 string sourceName;   "Identifier of source/lower/this region"
     12 string sourceStrand; "Orientation of source/lower/this region: + or -.  Use . if not applicable"
     13 string targetChrom;  "Chromosome of target region (directional) or upper region. For non-directional interchromosomal, chrom of other region"
     14 uint targetStart;    "Start position in chromosome of target/upper/this region"
     15 uint targetEnd;      "End position in chromosome of target/upper/this region"
     16 string targetName;   "Identifier of target/upper/this region"
     17 string targetStrand; "Orientation of target/upper/this region: + or -.  Use . if not applicable"
     *
     * @param tokens
     * @param ignore
     * @returns {*}
     */

    function decodeInteract(tokens, header) {
      if (tokens.length < 6) {
        console.log("Skipping line: " + tokens.join(' '));
        return undefined;
      }

      var feature = {
        chr: tokens[0],
        start: tokens[1],
        end: tokens[2],
        chr1: tokens[8],
        start1: Number.parseInt(tokens[9]),
        end1: Number.parseInt(tokens[10]),
        chr2: tokens[13],
        start2: Number.parseInt(tokens[14]),
        end2: Number.parseInt(tokens[15]),
        name: tokens[3],
        score: Number.parseFloat(tokens[4]),
        value: Number.parseFloat(tokens[5]),
        color: tokens[7] === '.' ? undefined : tokens[7] === "0" ? "rgb(0,0,0)" : tokens[7]
      };
      return feature;
    }

    const gffNameFields = ["Name", "gene_name", "gene", "gene_id", "alias", "locus", "name"];
    /**
     * Decode a single gff record (1 line in file).  Aggregations such as gene models are constructed at a higher level.
     *      ctg123 . mRNA            1050  9000  .  +  .  ID=mRNA00001;Parent=gene00001
     * @param tokens
     * @param ignore
     * @returns {*}
     */

    function decodeGFF(tokens, header) {
      var tokenCount,
          chr,
          start,
          end,
          strand,
          type,
          score,
          attributeString,
          color,
          name,
          i,
          format = header.format;
      tokenCount = tokens.length;

      if (tokenCount < 9) {
        return null; // Not a valid gff record
      }

      chr = tokens[0];
      type = tokens[2];
      start = parseInt(tokens[3]) - 1;
      end = parseInt(tokens[4]);
      score = "." === tokens[5] ? 0 : parseFloat(tokens[5]);
      strand = tokens[6];
      "." === tokens[7] ? 0 : parseInt(tokens[7]);
      attributeString = tokens[8]; // Find ID and Parent, or transcript_id

      var delim = 'gff3' === format ? '=' : /\s+/;
      var attributes = parseAttributeString(attributeString, delim);

      for (let [key, value] of Object.entries(attributes)) {
        const keyLower = key.toLowerCase();

        if ("color" === keyLower || "colour" === keyLower) {
          color = IGVColor.createColorString(value);
        } else if ('gff3' === format) try {
          attributes[key] = unescape(value);
        } catch (e) {
          attributes[key] = value; // Invalid

          console.error(`Malformed gff3 attibute value: ${value}`);
        }
      } // Find name (label) property


      if (header.nameField) {
        name = attributes[header.nameField];
      } else {
        for (i = 0; i < gffNameFields.length; i++) {
          if (attributes.hasOwnProperty(gffNameFields[i])) {
            header.nameField = gffNameFields[i];
            name = attributes[header.nameField];
            break;
          }
        }
      }

      const id = attributes["ID"] || attributes["transcript_id"];
      const parent = attributes["Parent"];
      return {
        id: id,
        parent: parent,
        name: name,
        type: type,
        chr: chr,
        start: start,
        end: end,
        score: score,
        strand: strand,
        color: color,
        attributeString: attributeString,
        delim: delim,
        popupData: popupData
      };
    }

    function parseAttributeString(attributeString, keyValueDelim) {
      // parse 'attributes' string (see column 9 docs in https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md)
      var attributes = {};

      for (let kv of attributeString.split(';')) {
        const t = kv.trim().split(keyValueDelim, 2);

        if (t.length === 2) {
          const key = t[0].trim();
          let value = t[1].trim(); //Strip off quotes, if any

          if (value.startsWith('"') && value.endsWith('"')) {
            value = value.substr(1, value.length - 2);
          }

          attributes[key] = value;
        }
      }

      return attributes;
    }

    function popupData(genomicLocation) {
      const kvs = this.attributeString.split(';');
      const pd = [];

      if (this.name) {
        pd.push({
          name: 'name:',
          value: this.name
        });
      }

      pd.push({
        name: 'type:',
        value: this.type
      });

      for (let kv of kvs) {
        const t = kv.trim().split(this.delim, 2);

        if (t.length === 2 && t[1] !== undefined) {
          const key = t[0].trim();
          if ('name' === key.toLowerCase()) continue;
          let value = t[1].trim(); //Strip off quotes, if any

          if (value.startsWith('"') && value.endsWith('"')) {
            value = value.substr(1, value.length - 2);
          }

          pd.push({
            name: key + ":",
            value: value
          });
        }
      }

      pd.push({
        name: 'position:',
        value: `${this.chr}:${numberFormatter(this.start + 1)}-${numberFormatter(this.end)}`
      });
      return pd;
    }

    /**
     * Decode the UCSC bed format.  Only the first 3 columns (chr, start, end) are required.   The remaining columns
     * must follow standard bed order, but we will tolerate deviations after column 3.
     *
     * @param tokens
     * @param ignore
     * @returns decoded feature, or null if this is not a valid record
     */

    function decodeBed(tokens, header) {
      if (tokens.length < 3) return undefined;
      header && header.gffTags;
      const chr = tokens[0];
      const start = parseInt(tokens[1]);
      const end = tokens.length > 2 ? parseInt(tokens[2]) : start + 1;

      if (isNaN(start) || isNaN(end)) {
        throw Error(`Unparsable bed record: ${tokens.join('\t')}`);
      }

      const feature = {
        chr: chr,
        start: start,
        end: end,
        score: 1000
      };

      try {
        if (tokens.length > 3) {
          // Note: these are very special rules for the gencode gene files.
          // tmp = tokens[3].replace(/"/g, '');
          // idName = tmp.split(';');
          // for (var i = 0; i < idName.length; i++) {
          //     var kv = idName[i].split('=');
          //     if (kv[0] == "gene_id") {
          //         id = kv[1];
          //     }
          //     if (kv[0] == "gene_name") {
          //         name = kv[1];
          //     }
          // }
          // feature.id = id ? id : tmp;
          // feature.name = name ? name : tmp;
          //parse gffTags in the name field
          if (tokens[3].indexOf(';') > 0 && tokens[3].indexOf('=') > 0) {
            const attributes = parseAttributeString(tokens[3], '=');

            for (let nmField of gffNameFields) {
              if (attributes.hasOwnProperty(nmField)) {
                feature.name = attributes[nmField];
                delete attributes[nmField];
                break;
              }
            }

            feature.attributes = attributes;
          }

          if (!feature.name) {
            feature.name = tokens[3] === '.' ? '' : tokens[3];
          }
        }

        if (tokens.length > 4) {
          feature.score = tokens[4] === '.' ? 0 : parseFloat(tokens[4]);

          if (isNaN(feature.score)) {
            return feature;
          }
        }

        if (tokens.length > 5) {
          feature.strand = tokens[5];

          if (!(feature.strand === '.' || feature.strand === '+' || feature.strand === '-')) {
            return feature;
          }
        }

        if (tokens.length > 6) {
          feature.cdStart = parseInt(tokens[6]);

          if (isNaN(feature.cdStart)) {
            return feature;
          }
        }

        if (tokens.length > 7) {
          feature.cdEnd = parseInt(tokens[7]);

          if (isNaN(feature.cdEnd)) {
            return feature;
          }
        }

        if (tokens.length > 8) {
          if (tokens[8] !== "." && tokens[8] !== "0") feature.color = IGVColor.createColorString(tokens[8]);
        }

        if (tokens.length > 11) {
          const exonCount = parseInt(tokens[9]); // Some basic validation

          if (exonCount > 1000) {
            // unlikely
            return feature;
          }

          const exonSizes = tokens[10].replace(/,$/, '').split(',');
          const exonStarts = tokens[11].replace(/,$/, '').split(',');

          if (!(exonSizes.length === exonStarts.length && exonCount === exonSizes.length)) {
            return feature;
          }

          const exons = [];

          for (let i = 0; i < exonCount; i++) {
            const eStart = start + parseInt(exonStarts[i]);
            const eEnd = eStart + parseInt(exonSizes[i]);
            exons.push({
              start: eStart,
              end: eEnd
            });
          }

          findUTRs(exons, feature.cdStart, feature.cdEnd);
          feature.exons = exons;
        } // Optional extra columns


        if (header) {
          let thicknessColumn = header.thicknessColumn;
          let colorColumn = header.colorColumn;

          if (colorColumn && colorColumn < tokens.length) {
            feature.color = IGVColor.createColorString(tokens[colorColumn]);
          }

          if (thicknessColumn && thicknessColumn < tokens.length) {
            feature.thickness = tokens[thicknessColumn];
          }
        }
      } catch (e) {}

      return feature;
    }
    /**
     * Decode a UCSC repeat masker record.
     *
     * Columns, from UCSC documentation
     *
     * 0  bin    585    smallint(5) unsigned    Indexing field to speed chromosome range queries.
     * 1  swScore    1504    int(10) unsigned    Smith Waterman alignment score
     * 2  milliDiv    13    int(10) unsigned    Base mismatches in parts per thousand
     * 3  milliDel    4    int(10) unsigned    Bases deleted in parts per thousand
     * 4  milliIns    13    int(10) unsigned    Bases inserted in parts per thousand
     * 5  genoName    chr1    varchar(255)    Genomic sequence name
     * 6  genoStart    10000    int(10) unsigned    Start in genomic sequence
     * 7  genoEnd    10468    int(10) unsigned    End in genomic sequence
     * 8  genoLeft    -249240153    int(11)    -#bases after match in genomic sequence
     * 9  strand    +    char(1)    Relative orientation + or -
     * 10 repName    (CCCTAA)n    varchar(255)    Name of repeat
     * 11 repClass    Simple_repeat    varchar(255)    Class of repeat
     * 12 repFamily    Simple_repeat    varchar(255)    Family of repeat
     * 13 repStart    1    int(11)    Start (if strand is +) or -#bases after match (if strand is -) in repeat sequence
     * 14 repEnd    463    int(11)    End in repeat sequence
     * 15 repLeft    0    int(11)    -#bases after match (if strand is +) or start (if strand is -) in repeat sequence
     * 16 id    1    char(1)    First digit of id field in RepeatMasker .out file. Best ignored.
     */


    function decodeRepeatMasker(tokens, header) {
      if (tokens.length <= 15) return undefined;
      const feature = {
        swScore: Number.parseInt(tokens[1]),
        milliDiv: Number.parseInt(tokens[2]),
        milliDel: Number.parseInt(tokens[3]),
        milliIns: Number.parseInt(tokens[4]),
        chr: tokens[5],
        start: Number.parseInt(tokens[6]),
        end: Number.parseInt(tokens[7]),
        //genoLeft: tokens[8],
        strand: tokens[9],
        repName: tokens[10],
        repClass: tokens[11],
        repFamily: tokens[12],
        repStart: Number.parseInt(tokens[13]),
        repEnd: Number.parseInt(tokens[14]),
        repLeft: Number.parseInt(tokens[15])
      };
      return feature;
    }
    /**
     * Decode a UCSC "genePred" record.
     *
     * @param tokens
     * @param ignore
     * @returns {*}
     */


    function decodeGenePred(tokens, header) {
      var shift = header.shift === undefined ? 0 : 1;
      if (tokens.length <= 9 + shift) return undefined;
      const cdStart = parseInt(tokens[5 + shift]);
      const cdEnd = parseInt(tokens[6 + shift]);
      var feature = {
        name: tokens[0 + shift],
        chr: tokens[1 + shift],
        strand: tokens[2 + shift],
        start: parseInt(tokens[3 + shift]),
        end: parseInt(tokens[4 + shift]),
        cdStart: cdStart,
        cdEnd: cdEnd,
        id: tokens[0 + shift]
      },
          exonCount = parseInt(tokens[7 + shift]),
          exonStarts = tokens[8 + shift].split(','),
          exonEnds = tokens[9 + shift].split(','),
          exons = [];

      for (let i = 0; i < exonCount; i++) {
        const start = parseInt(exonStarts[i]);
        const end = parseInt(exonEnds[i]);
        exons.push({
          start: start,
          end: end
        });
      }

      findUTRs(exons, cdStart, cdEnd);
      feature.exons = exons;
      return feature;
    }
    /**
     * Decode a UCSC "genePredExt" record.  refGene files are in this format.
     *
     * @param tokens
     * @param ignore
     * @returns {*}
     */


    function decodeGenePredExt(tokens, header) {
      var shift = header.shift === undefined ? 0 : 1;
      if (tokens.length <= 11 + shift) return undefined;
      const cdStart = parseInt(tokens[5 + shift]);
      const cdEnd = parseInt(tokens[6 + shift]);
      const feature = {
        name: tokens[11 + shift],
        chr: tokens[1 + shift],
        strand: tokens[2 + shift],
        start: parseInt(tokens[3 + shift]),
        end: parseInt(tokens[4 + shift]),
        cdStart: cdStart,
        cdEnd: cdEnd,
        id: tokens[0 + shift]
      },
            exonCount = parseInt(tokens[7 + shift]),
            exonStarts = tokens[8 + shift].split(','),
            exonEnds = tokens[9 + shift].split(','),
            exons = [];

      for (let i = 0; i < exonCount; i++) {
        const start = parseInt(exonStarts[i]);
        const end = parseInt(exonEnds[i]);
        exons.push({
          start: start,
          end: end
        });
      }

      findUTRs(exons, cdStart, cdEnd);
      feature.exons = exons;
      return feature;
    }
    /**
     * Decode a UCSC "refFlat" record
     * @param tokens
     * @param ignore
     * @returns {*}
     */


    function decodeReflat(tokens, header) {
      var shift = header.shift === undefined ? 0 : 1;
      if (tokens.length <= 10 + shift) return undefined;
      const cdStart = parseInt(tokens[6 + shift]);
      const cdEnd = parseInt(tokens[7 + shift]);
      var feature = {
        name: tokens[0 + shift],
        id: tokens[1 + shift],
        chr: tokens[2 + shift],
        strand: tokens[3 + shift],
        start: parseInt(tokens[4 + shift]),
        end: parseInt(tokens[5 + shift]),
        cdStart: cdStart,
        cdEnd: cdEnd
      },
          exonCount = parseInt(tokens[8 + shift]),
          exonStarts = tokens[9 + shift].split(','),
          exonEnds = tokens[10 + shift].split(','),
          exons = [];

      for (let i = 0; i < exonCount; i++) {
        const start = parseInt(exonStarts[i]);
        const end = parseInt(exonEnds[i]);
        exons.push({
          start: start,
          end: end
        });
      }

      findUTRs(exons, cdStart, cdEnd);
      feature.exons = exons;
      return feature;
    }

    function findUTRs(exons, cdStart, cdEnd) {
      for (let exon of exons) {
        const end = exon.end;
        const start = exon.start;

        if (end < cdStart || start > cdEnd) {
          exon.utr = true;
        } else {
          if (cdStart >= start && cdStart <= end) {
            exon.cdStart = cdStart;
          }

          if (cdEnd >= start && cdEnd <= end) {
            exon.cdEnd = cdEnd;
          }
        }
      }
    }

    function decodePeak(tokens, header) {
      var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;
      tokenCount = tokens.length;

      if (tokenCount < 9) {
        return undefined;
      }

      chr = tokens[0];
      start = parseInt(tokens[1]);
      end = parseInt(tokens[2]);
      name = tokens[3];
      score = parseFloat(tokens[4]);
      strand = tokens[5].trim();
      signal = parseFloat(tokens[6]);
      pValue = parseFloat(tokens[7]);
      qValue = parseFloat(tokens[8]);
      if (score === 0) score = signal;
      return {
        chr: chr,
        start: start,
        end: end,
        name: name,
        score: score,
        strand: strand,
        signal: signal,
        pValue: pValue,
        qValue: qValue
      };
    }

    function decodeBedGraph(tokens, header) {
      var chr, start, end, value;
      if (tokens.length <= 3) return undefined;
      chr = tokens[0];
      start = parseInt(tokens[1]);
      end = parseInt(tokens[2]);
      value = parseFloat(tokens[3]);
      const feature = {
        chr: chr,
        start: start,
        end: end,
        value: value
      }; // Optional extra columns

      if (header) {
        let colorColumn = header.colorColumn;

        if (colorColumn && colorColumn < tokens.length) {
          feature.color = IGVColor.createColorString(tokens[colorColumn]);
        }
      }

      return feature;
    }

    function decodeWig(tokens, header) {
      const wig = header.wig;

      if (wig && wig.format === "fixedStep") {
        const ss = wig.index * wig.step + wig.start;
        const ee = ss + wig.span;
        const value = parseFloat(tokens[0]);
        ++wig.index;
        return isNaN(value) ? null : {
          chr: wig.chrom,
          start: ss,
          end: ee,
          value: value
        };
      } else if (wig && wig.format === "variableStep") {
        if (tokens.length < 2) return null;
        const ss = parseInt(tokens[0], 10) - 1;
        const ee = ss + wig.span;
        const value = parseFloat(tokens[1]);
        return isNaN(value) ? null : {
          chr: wig.chrom,
          start: ss,
          end: ee,
          value: value
        };
      } else {
        return decodeBedGraph(tokens);
      }
    }

    function decodeSNP(tokens, header) {
      if (tokens.length < 6) return undefined;
      const autoSql = ['bin', 'chr', 'start', 'end', 'name', 'score', 'strand', 'refNCBI', 'refUCSC', 'observed', 'molType', 'class', 'valid', 'avHet', 'avHetSE', 'func', 'locType', 'weight', 'exceptions', 'submitterCount', 'submitters', 'alleleFreqCount', 'alleles', 'alleleNs', 'alleleFreqs', 'bitfields'];
      const feature = {
        chr: tokens[1],
        start: Number.parseInt(tokens[2]),
        end: Number.parseInt(tokens[3]),
        name: tokens[4],
        score: Number.parseInt(tokens[5])
      };
      const n = Math.min(tokens.length, autoSql.length);

      for (let i = 6; i < n; i++) {
        feature[autoSql[i]] = tokens[i];
      }

      return feature;
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     *  Parser for column style (tab delimited, etc) text file formats (bed, gff, vcf, etc).
     *
     *
     */

    /**
     * Return a parser for the given file format.
     */

    class FeatureParser {
      constructor(config) {
        this.config = config;
        this.header = {};

        if (config.nameField) {
          this.header.nameField = config.nameField;
        }

        this.skipRows = 0; // The number of fixed header rows to skip.  Override for specific types as needed

        if (config.decode) {
          this.decode = config.decode;
          this.delimiter = config.delimiter || "\t";
        } else if (config.format) {
          this.header.format = config.format.toLowerCase();
          this.setDecoder(this.header.format);
        }

        if (!this.delimiter) {
          this.delimiter = "\t";
        }
      }
      /**
       * Parse metadata from the file.   A variety of conventions are in use to supply metadata about file contents
       * through header lines (e.g. 'track') and # directives. This method unifies metadata as properties of a
       * 'header' object.
       *
       * @param data
       * @returns {{}}
       */


      async parseHeader(dataWrapper) {
        let header = this.header;
        let columnNames;
        let line;

        while ((line = await dataWrapper.nextLine()) !== undefined) {
          if (line.startsWith("track") || line.startsWith("#track")) {
            let h = parseTrackLine(line);
            Object.assign(header, h);
          } else if (line.startsWith("browser")) ; else if (line.startsWith("#columns")) {
            let h = parseColumnsDirective(line);
            Object.assign(header, h);
          } else if (line.startsWith("##gff-version 3")) {
            header.format = "gff3";
          } else if (line.startsWith("#gffTags")) {
            header.gffTags = true;
          } else if (line.startsWith("fixedStep") || line.startsWith("variableStep")) {
            // Wig directives -- we are in the data section
            break;
          } else if (line.startsWith("#")) {
            const tokens = line.split(this.delimiter || "\t");

            if (tokens.length > 1) {
              columnNames = tokens; // Possible column names
            }
          } else {
            // All directives that could change the format, and thus decoder, should have been read by now.
            this.setDecoder(header.format); // If the line can be parsed as a feature assume we are beyond the header, if any

            try {
              const tokens = line.split(this.delimiter || "\t");
              const tmpHeader = Object.assign({
                columnNames
              }, header);

              if (this.decode(tokens, tmpHeader)) {
                break;
              } else {
                if (tokens.length > 1) {
                  columnNames = tokens; // possible column names
                }
              }
            } catch (e) {// Not a feature
            }
          }
        }

        if (columnNames) {
          header.columnNames = columnNames;

          for (let n = 0; n < columnNames.length; n++) {
            if (columnNames[n] === "color" || columnNames[n] === "colour") {
              header.colorColumn = n;
            } else if (columnNames[n] === "thickness") {
              header.thicknessColumn = n;
            }
          }
        }

        this.header = header; // Directives might be needed for parsing lines

        return header;
      }

      async parseFeatures(dataWrapper) {
        const allFeatures = [];
        const decode = this.decode;
        const format = this.header.format;
        const delimiter = this.delimiter || "\t";
        let i = 0;
        let line;

        while ((line = await dataWrapper.nextLine()) !== undefined) {
          i++;
          if (i <= this.skipRows) continue;

          if (!line || line.startsWith("track") || line.startsWith("#") || line.startsWith("browser")) {
            continue;
          } else if (format === "wig" && line.startsWith("fixedStep")) {
            this.header.wig = parseFixedStep(line);
            continue;
          } else if (format === "wig" && line.startsWith("variableStep")) {
            this.header.wig = parseVariableStep(line);
            continue;
          }

          const tokens = line.split(delimiter);

          if (tokens.length < 1) {
            continue;
          }

          const feature = decode(tokens, this.header);

          if (feature) {
            allFeatures.push(feature);
          }
        } // Special hack for bedPE


        if (decode === decodeBedpe) {
          fixBedPE(allFeatures);
        }

        return allFeatures;
      }

      setDecoder(format) {
        switch (format) {
          case "narrowpeak":
          case "broadpeak":
          case "regionpeak":
          case "peaks":
            this.decode = decodePeak;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "bedgraph":
            this.decode = decodeBedGraph;
            this.delimiter = /\s+/;
            break;

          case "wig":
            this.decode = decodeWig;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "gff3":
          case "gff":
          case "gtf":
            this.decode = decodeGFF;
            this.delimiter = "\t";
            break;

          case "fusionjuncspan":
            // bhaas, needed for FusionInspector view
            this.decode = decodeFusionJuncSpan;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "gtexgwas":
            this.skipRows = 1;
            this.decode = decodeGtexGWAS;
            this.delimiter = "\t";
            break;

          case "refflat":
            this.decode = decodeReflat;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "genepred":
            this.decode = decodeGenePred;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "genepredext":
            this.decode = decodeGenePredExt;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "ensgene":
            this.decode = decodeGenePred;
            this.header.shift = 1;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "refgene":
            this.decode = decodeGenePredExt;
            this.delimiter = this.config.delimiter || /\s+/;
            this.header.shift = 1;
            break;

          case "bed":
            this.decode = decodeBed;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "bedpe":
            this.decode = decodeBedpe;
            this.delimiter = this.config.delimiter || "\t";
            break;

          case "bedpe-domain":
            this.decode = decodeBedpeDomain;
            this.headerLine = true;
            this.delimiter = this.config.delimiter || "\t";
            break;

          case "bedpe-loop":
            this.decode = decodeBedpe;
            this.delimiter = this.config.delimiter || "\t";
            this.header = {
              colorColumn: 7
            };
            break;

          case "interact":
            this.decode = decodeInteract;
            this.delimiter = this.config.delimiter || /\s+/;
            break;

          case "snp":
            this.decode = decodeSNP;
            this.delimiter = "\t";
            break;

          case "rmsk":
            this.decode = decodeRepeatMasker;
            this.delimiter = "\t";
            break;

          case "gcnv":
            this.decode = decodeGcnv;
            this.delimiter = "\t";
            break;

          default:
            const customFormat = getFormat(format);

            if (customFormat !== undefined) {
              this.decode = decodeCustom;
              this.header.customFormat = customFormat;
              this.delimiter = customFormat.delimiter || "\t";
            } else {
              this.decode = decodeBed;
              this.delimiter = this.config.delimiter || /\s+/;
            }

        }
      }

    }

    function parseTrackLine(line) {
      const properties = {};
      const tokens = line.split(/(?:")([^"]+)(?:")|([^\s"]+)(?=\s+|$)/g); // Clean up tokens array

      let curr;
      const tmp = [];

      for (let tk of tokens) {
        if (!tk || tk.trim().length === 0) continue;

        if (tk.endsWith("=")) {
          curr = tk;
        } else if (curr) {
          tmp.push(curr + tk);
          curr = undefined;
        } else {
          tmp.push(tk);
        }
      }

      for (let str of tmp) {
        if (!str) return;
        var kv = str.split('=', 2);

        if (kv.length === 2) {
          const key = kv[0].trim();
          const value = kv[1].trim();

          if (properties.hasOwnProperty(key)) {
            let currentValue = properties[key];

            if (Array.isArray(currentValue)) {
              currentValue.push(value);
            } else {
              properties[key] = [currentValue, value];
            }
          } else {
            properties[key] = value;
          }
        }
      }

      if ("interact" == properties["type"]) {
        properties["format"] = "interact";
      } else if ("gcnv" === properties["type"]) {
        properties["format"] = "gcnv";
      }

      return properties;
    }

    function parseColumnsDirective(line) {
      let properties = {};
      let t1 = line.split(/\s+/);

      if (t1.length === 2) {
        let t2 = t1[1].split(";");
        t2.forEach(function (keyValue) {
          let t = keyValue.split("=");

          if (t[0] === "color") {
            properties.colorColumn = Number.parseInt(t[1]) - 1;
          } else if (t[0] === "thickness") {
            properties.thicknessColumn = Number.parseInt(t[1]) - 1;
          }
        });
      }

      return properties;
    }

    function parseFixedStep(line) {
      const tokens = line.split(/\s+/);
      const chrom = tokens[1].split("=")[1];
      const start = parseInt(tokens[2].split("=")[1], 10) - 1;
      const step = parseInt(tokens[3].split("=")[1], 10);
      const span = tokens.length > 4 ? parseInt(tokens[4].split("=")[1], 10) : 1;
      return {
        format: "fixedStep",
        chrom,
        start,
        step,
        span,
        index: 0
      };
    }

    function parseVariableStep(line) {
      const tokens = line.split(/\s+/);
      const chrom = tokens[1].split("=")[1];
      const span = tokens.length > 2 ? parseInt(tokens[2].split("=")[1], 10) : 1;
      return {
        format: "variableStep",
        chrom,
        span
      };
    }

    function div(options) {
      return create("div", options);
    }

    function create(tag, options) {
      const elem = document.createElement(tag);

      if (options) {
        if (options.class) {
          elem.classList.add(options.class);
        }

        if (options.id) {
          elem.id = options.id;
        }

        if (options.style) {
          applyStyle(elem, options.style);
        }
      }

      return elem;
    }

    function hide(elem) {
      const cssStyle = getComputedStyle(elem);

      if (cssStyle.display !== "none") {
        elem._initialDisplay = cssStyle.display;
      }

      elem.style.display = "none";
    }

    function show(elem) {
      const currentDisplay = getComputedStyle(elem).display;

      if (currentDisplay === "none") {
        const d = elem._initialDisplay || "block";
        elem.style.display = d;
      }
    }

    function offset(elem) {
      // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error
      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      const rect = elem.getBoundingClientRect();
      const win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    }

    function pageCoordinates(e) {
      if (e.type.startsWith("touch")) {
        const touch = e.touches[0];
        return {
          x: touch.pageX,
          y: touch.pageY
        };
      } else {
        return {
          x: e.pageX,
          y: e.pageY
        };
      }
    }

    function applyStyle(elem, style) {
      for (let key of Object.keys(style)) {
        elem.style[key] = style[key];
      }
    }

    function createIcon$1(name, color) {
      return iconMarkup$1(name, color);
    }

    function iconMarkup$1(name, color) {
      color = color || "currentColor";
      let icon = icons$1[name];

      if (!icon) {
        console.error(`No icon named: ${name}`);
        icon = icons$1["question"];
      }

      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttributeNS(null, 'viewBox', '0 0 ' + icon[0] + ' ' + icon[1]);
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttributeNS(null, 'fill', color);
      path.setAttributeNS(null, 'd', icon[4]);
      svg.appendChild(path);
      return svg;
    }

    const icons$1 = {
      "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
      "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
      "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
      "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
      "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
      "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
      "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
      "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
      "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
      "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
      "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
      "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
      "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
      "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
      "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
      "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
      "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
      "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
      "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
      "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
      "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"]
    };

    function attachDialogCloseHandlerWithParent(parent, closeHandler) {
      var container = document.createElement("div");
      parent.appendChild(container);
      container.appendChild(createIcon$1("times"));
      container.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        closeHandler();
      });
    }
    /**
     * @fileoverview Zlib namespace. Zlib の仕様に準拠した圧縮は Zlib.Deflate で実装
     * されている. これは Inflate との共存を考慮している為.
     */


    const ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE$1 = 65000;
    var Zlib$1 = {
      Huffman: {},
      Util: {},
      CRC32: {}
    };
    /**
     * Compression Method
     * @enum {number}
     */

    Zlib$1.CompressionMethod = {
      DEFLATE: 8,
      RESERVED: 15
    };
    /**
     * @param {Object=} opt_params options.
     * @constructor
     */

    Zlib$1.Zip = function (opt_params) {
      opt_params = opt_params || {};
      /** @type {Array.<{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }>} */

      this.files = [];
      /** @type {(Array.<number>|Uint8Array)} */

      this.comment = opt_params['comment'];
      /** @type {(Array.<number>|Uint8Array)} */

      this.password;
    };
    /**
     * @enum {number}
     */


    Zlib$1.Zip.CompressionMethod = {
      STORE: 0,
      DEFLATE: 8
    };
    /**
     * @enum {number}
     */

    Zlib$1.Zip.OperatingSystem = {
      MSDOS: 0,
      UNIX: 3,
      MACINTOSH: 7
    };
    /**
     * @enum {number}
     */

    Zlib$1.Zip.Flags = {
      ENCRYPT: 0x0001,
      DESCRIPTOR: 0x0008,
      UTF8: 0x0800
    };
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$1.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$1.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$1.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];
    /**
     * @param {Array.<number>|Uint8Array} input
     * @param {Object=} opt_params options.
     */

    Zlib$1.Zip.prototype.addFile = function (input, opt_params) {
      opt_params = opt_params || {};
      /** @type {string} */

      opt_params['filename'];
      /** @type {boolean} */

      var compressed;
      /** @type {number} */

      var size = input.length;
      /** @type {number} */

      var crc32 = 0;

      if (input instanceof Array) {
        input = new Uint8Array(input);
      } // default


      if (typeof opt_params['compressionMethod'] !== 'number') {
        opt_params['compressionMethod'] = Zlib$1.Zip.CompressionMethod.DEFLATE;
      } // その場で圧縮する場合


      if (opt_params['compress']) {
        switch (opt_params['compressionMethod']) {
          case Zlib$1.Zip.CompressionMethod.STORE:
            break;

          case Zlib$1.Zip.CompressionMethod.DEFLATE:
            crc32 = Zlib$1.CRC32.calc(input);
            input = this.deflateWithOption(input, opt_params);
            compressed = true;
            break;

          default:
            throw new Error('unknown compression method:' + opt_params['compressionMethod']);
        }
      }

      this.files.push({
        buffer: input,
        option: opt_params,
        compressed: compressed,
        encrypted: false,
        size: size,
        crc32: crc32
      });
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     */


    Zlib$1.Zip.prototype.setPassword = function (password) {
      this.password = password;
    };

    Zlib$1.Zip.prototype.compress = function () {
      /** @type {Array.<{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }>} */
      var files = this.files;
      /** @type {{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }} */

      var file;
      /** @type {!(Array.<number>|Uint8Array)} */

      var output;
      /** @type {number} */

      var op1;
      /** @type {number} */

      var op2;
      /** @type {number} */

      var op3;
      /** @type {number} */

      var localFileSize = 0;
      /** @type {number} */

      var centralDirectorySize = 0;
      /** @type {number} */

      var endOfCentralDirectorySize;
      /** @type {number} */

      var offset;
      /** @type {number} */

      var needVersion;
      /** @type {number} */

      var flags;
      /** @type {Zlib.Zip.CompressionMethod} */

      var compressionMethod;
      /** @type {Date} */

      var date;
      /** @type {number} */

      var crc32;
      /** @type {number} */

      var size;
      /** @type {number} */

      var plainSize;
      /** @type {number} */

      var filenameLength;
      /** @type {number} */

      var extraFieldLength;
      /** @type {number} */

      var commentLength;
      /** @type {(Array.<number>|Uint8Array)} */

      var filename;
      /** @type {(Array.<number>|Uint8Array)} */

      var extraField;
      /** @type {(Array.<number>|Uint8Array)} */

      var comment;
      /** @type {(Array.<number>|Uint8Array)} */

      var buffer;
      /** @type {*} */

      var tmp;
      /** @type {Array.<number>|Uint32Array|Object} */

      var key;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {number} */

      var j;
      /** @type {number} */

      var jl; // ファイルの圧縮

      for (i = 0, il = files.length; i < il; ++i) {
        file = files[i];
        filenameLength = file.option['filename'] ? file.option['filename'].length : 0;
        extraFieldLength = file.option['extraField'] ? file.option['extraField'].length : 0;
        commentLength = file.option['comment'] ? file.option['comment'].length : 0; // 圧縮されていなかったら圧縮

        if (!file.compressed) {
          // 圧縮前に CRC32 の計算をしておく
          file.crc32 = Zlib$1.CRC32.calc(file.buffer);

          switch (file.option['compressionMethod']) {
            case Zlib$1.Zip.CompressionMethod.STORE:
              break;

            case Zlib$1.Zip.CompressionMethod.DEFLATE:
              file.buffer = this.deflateWithOption(file.buffer, file.option);
              file.compressed = true;
              break;

            default:
              throw new Error('unknown compression method:' + file.option['compressionMethod']);
          }
        } // encryption


        if (file.option['password'] !== void 0 || this.password !== void 0) {
          // init encryption
          key = this.createEncryptionKey(file.option['password'] || this.password); // add header

          buffer = file.buffer;
          {
            tmp = new Uint8Array(buffer.length + 12);
            tmp.set(buffer, 12);
            buffer = tmp;
          }

          for (j = 0; j < 12; ++j) {
            buffer[j] = this.encode(key, i === 11 ? file.crc32 & 0xff : Math.random() * 256 | 0);
          } // data encryption


          for (jl = buffer.length; j < jl; ++j) {
            buffer[j] = this.encode(key, buffer[j]);
          }

          file.buffer = buffer;
        } // 必要バッファサイズの計算


        localFileSize += // local file header
        30 + filenameLength + // file data
        file.buffer.length;
        centralDirectorySize += // file header
        46 + filenameLength + commentLength;
      } // end of central directory


      endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);
      output = new Uint8Array(localFileSize + centralDirectorySize + endOfCentralDirectorySize);
      op1 = 0;
      op2 = localFileSize;
      op3 = op2 + centralDirectorySize; // ファイルの圧縮

      for (i = 0, il = files.length; i < il; ++i) {
        file = files[i];
        filenameLength = file.option['filename'] ? file.option['filename'].length : 0;
        extraFieldLength = 0; // TODO

        commentLength = file.option['comment'] ? file.option['comment'].length : 0; //-------------------------------------------------------------------------
        // local file header & file header
        //-------------------------------------------------------------------------

        offset = op1; // signature
        // local file header

        output[op1++] = Zlib$1.Zip.LocalFileHeaderSignature[0];
        output[op1++] = Zlib$1.Zip.LocalFileHeaderSignature[1];
        output[op1++] = Zlib$1.Zip.LocalFileHeaderSignature[2];
        output[op1++] = Zlib$1.Zip.LocalFileHeaderSignature[3]; // file header

        output[op2++] = Zlib$1.Zip.FileHeaderSignature[0];
        output[op2++] = Zlib$1.Zip.FileHeaderSignature[1];
        output[op2++] = Zlib$1.Zip.FileHeaderSignature[2];
        output[op2++] = Zlib$1.Zip.FileHeaderSignature[3]; // compressor info

        needVersion = 20;
        output[op2++] = needVersion & 0xff;
        output[op2++] =
        /** @type {Zlib.Zip.OperatingSystem} */
        file.option['os'] || Zlib$1.Zip.OperatingSystem.MSDOS; // need version

        output[op1++] = output[op2++] = needVersion & 0xff;
        output[op1++] = output[op2++] = needVersion >> 8 & 0xff; // general purpose bit flag

        flags = 0;

        if (file.option['password'] || this.password) {
          flags |= Zlib$1.Zip.Flags.ENCRYPT;
        }

        output[op1++] = output[op2++] = flags & 0xff;
        output[op1++] = output[op2++] = flags >> 8 & 0xff; // compression method

        compressionMethod =
        /** @type {Zlib.Zip.CompressionMethod} */
        file.option['compressionMethod'];
        output[op1++] = output[op2++] = compressionMethod & 0xff;
        output[op1++] = output[op2++] = compressionMethod >> 8 & 0xff; // date

        date =
        /** @type {(Date|undefined)} */
        file.option['date'] || new Date();
        output[op1++] = output[op2++] = (date.getMinutes() & 0x7) << 5 | (date.getSeconds() / 2 | 0);
        output[op1++] = output[op2++] = date.getHours() << 3 | date.getMinutes() >> 3; //

        output[op1++] = output[op2++] = (date.getMonth() + 1 & 0x7) << 5 | date.getDate();
        output[op1++] = output[op2++] = (date.getFullYear() - 1980 & 0x7f) << 1 | date.getMonth() + 1 >> 3; // CRC-32

        crc32 = file.crc32;
        output[op1++] = output[op2++] = crc32 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 8 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 16 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 24 & 0xff; // compressed size

        size = file.buffer.length;
        output[op1++] = output[op2++] = size & 0xff;
        output[op1++] = output[op2++] = size >> 8 & 0xff;
        output[op1++] = output[op2++] = size >> 16 & 0xff;
        output[op1++] = output[op2++] = size >> 24 & 0xff; // uncompressed size

        plainSize = file.size;
        output[op1++] = output[op2++] = plainSize & 0xff;
        output[op1++] = output[op2++] = plainSize >> 8 & 0xff;
        output[op1++] = output[op2++] = plainSize >> 16 & 0xff;
        output[op1++] = output[op2++] = plainSize >> 24 & 0xff; // filename length

        output[op1++] = output[op2++] = filenameLength & 0xff;
        output[op1++] = output[op2++] = filenameLength >> 8 & 0xff; // extra field length

        output[op1++] = output[op2++] = extraFieldLength & 0xff;
        output[op1++] = output[op2++] = extraFieldLength >> 8 & 0xff; // file comment length

        output[op2++] = commentLength & 0xff;
        output[op2++] = commentLength >> 8 & 0xff; // disk number start

        output[op2++] = 0;
        output[op2++] = 0; // internal file attributes

        output[op2++] = 0;
        output[op2++] = 0; // external file attributes

        output[op2++] = 0;
        output[op2++] = 0;
        output[op2++] = 0;
        output[op2++] = 0; // relative offset of local header

        output[op2++] = offset & 0xff;
        output[op2++] = offset >> 8 & 0xff;
        output[op2++] = offset >> 16 & 0xff;
        output[op2++] = offset >> 24 & 0xff; // filename

        filename = file.option['filename'];

        if (filename) {
          {
            output.set(filename, op1);
            output.set(filename, op2);
            op1 += filenameLength;
            op2 += filenameLength;
          }
        } // extra field


        extraField = file.option['extraField'];

        if (extraField) {
          {
            output.set(extraField, op1);
            output.set(extraField, op2);
            op1 += extraFieldLength;
            op2 += extraFieldLength;
          }
        } // comment


        comment = file.option['comment'];

        if (comment) {
          {
            output.set(comment, op2);
            op2 += commentLength;
          }
        } //-------------------------------------------------------------------------
        // file data
        //-------------------------------------------------------------------------


        {
          output.set(file.buffer, op1);
          op1 += file.buffer.length;
        }
      } //-------------------------------------------------------------------------
      // end of central directory
      //-------------------------------------------------------------------------
      // signature


      output[op3++] = Zlib$1.Zip.CentralDirectorySignature[0];
      output[op3++] = Zlib$1.Zip.CentralDirectorySignature[1];
      output[op3++] = Zlib$1.Zip.CentralDirectorySignature[2];
      output[op3++] = Zlib$1.Zip.CentralDirectorySignature[3]; // number of this disk

      output[op3++] = 0;
      output[op3++] = 0; // number of the disk with the start of the central directory

      output[op3++] = 0;
      output[op3++] = 0; // total number of entries in the central directory on this disk

      output[op3++] = il & 0xff;
      output[op3++] = il >> 8 & 0xff; // total number of entries in the central directory

      output[op3++] = il & 0xff;
      output[op3++] = il >> 8 & 0xff; // size of the central directory

      output[op3++] = centralDirectorySize & 0xff;
      output[op3++] = centralDirectorySize >> 8 & 0xff;
      output[op3++] = centralDirectorySize >> 16 & 0xff;
      output[op3++] = centralDirectorySize >> 24 & 0xff; // offset of start of central directory with respect to the starting disk number

      output[op3++] = localFileSize & 0xff;
      output[op3++] = localFileSize >> 8 & 0xff;
      output[op3++] = localFileSize >> 16 & 0xff;
      output[op3++] = localFileSize >> 24 & 0xff; // .ZIP file comment length

      commentLength = this.comment ? this.comment.length : 0;
      output[op3++] = commentLength & 0xff;
      output[op3++] = commentLength >> 8 & 0xff; // .ZIP file comment

      if (this.comment) {
        {
          output.set(this.comment, op3);
          op3 += commentLength;
        }
      }

      return output;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input
     * @param {Object=} opt_params options.
     * @return {!(Array.<number>|Uint8Array)}
     */


    Zlib$1.Zip.prototype.deflateWithOption = function (input, opt_params) {
      /** @type {Zlib.RawDeflate} */
      var deflator = new Zlib$1.RawDeflate(input, opt_params['deflateOption']);
      return deflator.compress();
    };
    /**
     * @param {(Array.<number>|Uint32Array)} key
     * @return {number}
     */


    Zlib$1.Zip.prototype.getByte = function (key) {
      /** @type {number} */
      var tmp = key[2] & 0xffff | 2;
      return tmp * (tmp ^ 1) >> 8 & 0xff;
    };
    /**
     * @param {(Array.<number>|Uint32Array|Object)} key
     * @param {number} n
     * @return {number}
     */


    Zlib$1.Zip.prototype.encode = function (key, n) {
      /** @type {number} */
      var tmp = this.getByte(
      /** @type {(Array.<number>|Uint32Array)} */
      key);
      this.updateKeys(
      /** @type {(Array.<number>|Uint32Array)} */
      key, n);
      return tmp ^ n;
    };
    /**
     * @param {(Array.<number>|Uint32Array)} key
     * @param {number} n
     */


    Zlib$1.Zip.prototype.updateKeys = function (key, n) {
      key[0] = Zlib$1.CRC32.single(key[0], n);
      key[1] = (((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681 >>> 0) + 1 >>> 0;
      key[2] = Zlib$1.CRC32.single(key[2], key[1] >>> 24);
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     * @return {!(Array.<number>|Uint32Array|Object)}
     */


    Zlib$1.Zip.prototype.createEncryptionKey = function (password) {
      /** @type {!(Array.<number>|Uint32Array)} */
      var key = [305419896, 591751049, 878082192];
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      {
        key = new Uint32Array(key);
      }

      for (i = 0, il = password.length; i < il; ++i) {
        this.updateKeys(key, password[i] & 0xff);
      }

      return key;
    };
    /**
     * build huffman table from length list.
     * @param {!(Array.<number>|Uint8Array)} lengths length list.
     * @return {!Array} huffman table.
     */


    Zlib$1.Huffman.buildHuffmanTable = function (lengths) {
      /** @type {number} length list size. */
      var listSize = lengths.length;
      /** @type {number} max code length for table size. */

      var maxCodeLength = 0;
      /** @type {number} min code length for table size. */

      var minCodeLength = Number.POSITIVE_INFINITY;
      /** @type {number} table size. */

      var size;
      /** @type {!(Array|Uint8Array)} huffman code table. */

      var table;
      /** @type {number} bit length. */

      var bitLength;
      /** @type {number} huffman code. */

      var code;
      /**
       * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
       * @type {number} skip length for table filling.
       */

      var skip;
      /** @type {number} reversed code. */

      var reversed;
      /** @type {number} reverse temp. */

      var rtemp;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limit. */

      var il;
      /** @type {number} loop counter. */

      var j;
      /** @type {number} table value. */

      var value; // Math.max は遅いので最長の値は for-loop で取得する

      for (i = 0, il = listSize; i < il; ++i) {
        if (lengths[i] > maxCodeLength) {
          maxCodeLength = lengths[i];
        }

        if (lengths[i] < minCodeLength) {
          minCodeLength = lengths[i];
        }
      }

      size = 1 << maxCodeLength;
      table = new Uint32Array(size); // ビット長の短い順からハフマン符号を割り当てる

      for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
        for (i = 0; i < listSize; ++i) {
          if (lengths[i] === bitLength) {
            // ビットオーダーが逆になるためビット長分並びを反転する
            for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
              reversed = reversed << 1 | rtemp & 1;
              rtemp >>= 1;
            } // 最大ビット長をもとにテーブルを作るため、
            // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
            // そのどちらでも良い場所は同じ値で埋めることで
            // 本来のビット長以上のビット数取得しても問題が起こらないようにする


            value = bitLength << 16 | i;

            for (j = reversed; j < size; j += skip) {
              table[j] = value;
            }

            ++code;
          }
        } // 次のビット長へ


        ++bitLength;
        code <<= 1;
        skip <<= 1;
      }

      return [table, maxCodeLength, minCodeLength];
    }; //-----------------------------------------------------------------------------

    /** @define {number} buffer block size. */


    var ZLIB_RAW_INFLATE_BUFFER_SIZE$1 = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]
    //-----------------------------------------------------------------------------

    var buildHuffmanTable$1 = Zlib$1.Huffman.buildHuffmanTable;
    /**
     * @constructor
     * @param {!(Uint8Array|Array.<number>)} input input buffer.
     * @param {Object} opt_params option parameter.
     *
     * opt_params は以下のプロパティを指定する事ができます。
     *   - index: input buffer の deflate コンテナの開始位置.
     *   - blockSize: バッファのブロックサイズ.
     *   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
     *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
     */

    Zlib$1.RawInflate = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} inflated buffer */
      this.buffer;
      /** @type {!Array.<(Array.<number>|Uint8Array)>} */

      this.blocks = [];
      /** @type {number} block size. */

      this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE$1;
      /** @type {!number} total output buffer pointer. */

      this.totalpos = 0;
      /** @type {!number} input buffer pointer. */

      this.ip = 0;
      /** @type {!number} bit stream reader buffer. */

      this.bitsbuf = 0;
      /** @type {!number} bit stream reader buffer size. */

      this.bitsbuflen = 0;
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */

      this.input = new Uint8Array(input);
      /** @type {!(Uint8Array|Array.<number>)} output buffer. */

      this.output;
      /** @type {!number} output buffer pointer. */

      this.op;
      /** @type {boolean} is final block flag. */

      this.bfinal = false;
      /** @type {Zlib.RawInflate.BufferType} buffer management. */

      this.bufferType = Zlib$1.RawInflate.BufferType.ADAPTIVE;
      /** @type {boolean} resize flag for memory size optimization. */

      this.resize = false; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (opt_params['index']) {
          this.ip = opt_params['index'];
        }

        if (opt_params['bufferSize']) {
          this.bufferSize = opt_params['bufferSize'];
        }

        if (opt_params['bufferType']) {
          this.bufferType = opt_params['bufferType'];
        }

        if (opt_params['resize']) {
          this.resize = opt_params['resize'];
        }
      } // initialize


      switch (this.bufferType) {
        case Zlib$1.RawInflate.BufferType.BLOCK:
          this.op = Zlib$1.RawInflate.MaxBackwardLength;
          this.output = new Uint8Array(Zlib$1.RawInflate.MaxBackwardLength + this.bufferSize + Zlib$1.RawInflate.MaxCopyLength);
          break;

        case Zlib$1.RawInflate.BufferType.ADAPTIVE:
          this.op = 0;
          this.output = new Uint8Array(this.bufferSize);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * @enum {number}
     */


    Zlib$1.RawInflate.BufferType = {
      BLOCK: 0,
      ADAPTIVE: 1
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array.<number>)} inflated buffer.
     */

    Zlib$1.RawInflate.prototype.decompress = function () {
      while (!this.bfinal) {
        this.parseBlock();
      }

      switch (this.bufferType) {
        case Zlib$1.RawInflate.BufferType.BLOCK:
          return this.concatBufferBlock();

        case Zlib$1.RawInflate.BufferType.ADAPTIVE:
          return this.concatBufferDynamic();

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * @const
     * @type {number} max backward length for LZ77.
     */


    Zlib$1.RawInflate.MaxBackwardLength = 32768;
    /**
     * @const
     * @type {number} max copy length for LZ77.
     */

    Zlib$1.RawInflate.MaxCopyLength = 258;
    /**
     * huffman order
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */

    Zlib$1.RawInflate.Order = function (table) {
      return new Uint16Array(table);
    }([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    /**
     * huffman length code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib$1.RawInflate.LengthCodeTable = function (table) {
      return new Uint16Array(table);
    }([0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b, 0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3, 0x00e3, 0x0102, 0x0102, 0x0102]);
    /**
     * huffman length extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib$1.RawInflate.LengthExtraTable = function (table) {
      return new Uint8Array(table);
    }([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
    /**
     * huffman dist code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib$1.RawInflate.DistCodeTable = function (table) {
      return new Uint16Array(table);
    }([0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001]);
    /**
     * huffman dist extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib$1.RawInflate.DistExtraTable = function (table) {
      return new Uint8Array(table);
    }([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    /**
     * fixed huffman length code table
     * @const
     * @type {!Array}
     */


    Zlib$1.RawInflate.FixedLiteralLengthTable = function (table) {
      return table;
    }(function () {
      var lengths = new Uint8Array(288);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
      }

      return buildHuffmanTable$1(lengths);
    }());
    /**
     * fixed huffman distance code table
     * @const
     * @type {!Array}
     */


    Zlib$1.RawInflate.FixedDistanceTable = function (table) {
      return table;
    }(function () {
      var lengths = new Uint8Array(30);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = 5;
      }

      return buildHuffmanTable$1(lengths);
    }());
    /**
     * parse deflated block.
     */


    Zlib$1.RawInflate.prototype.parseBlock = function () {
      /** @type {number} header */
      var hdr = this.readBits(3); // BFINAL

      if (hdr & 0x1) {
        this.bfinal = true;
      } // BTYPE


      hdr >>>= 1;

      switch (hdr) {
        // uncompressed
        case 0:
          this.parseUncompressedBlock();
          break;
        // fixed huffman

        case 1:
          this.parseFixedHuffmanBlock();
          break;
        // dynamic huffman

        case 2:
          this.parseDynamicHuffmanBlock();
          break;
        // reserved or other

        default:
          throw new Error('unknown BTYPE: ' + hdr);
      }
    };
    /**
     * read inflate bits
     * @param {number} length bits length.
     * @return {number} read bits.
     */


    Zlib$1.RawInflate.prototype.readBits = function (length) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {number} input and output byte. */

      var octet; // input byte

      if (ip + (length - bitsbuflen + 7 >> 3) >= inputLength) {
        throw new Error('input buffer is broken');
      } // not enough buffer


      while (bitsbuflen < length) {
        bitsbuf |= input[ip++] << bitsbuflen;
        bitsbuflen += 8;
      } // output byte


      octet = bitsbuf &
      /* MASK */
      (1 << length) - 1;
      bitsbuf >>>= length;
      bitsbuflen -= length;
      this.bitsbuf = bitsbuf;
      this.bitsbuflen = bitsbuflen;
      this.ip = ip;
      return octet;
    };
    /**
     * read huffman code using table
     * @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.
     * @return {number} huffman code.
     */


    Zlib$1.RawInflate.prototype.readCodeByTable = function (table) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {!(Array.<number>|Uint8Array)} huffman code table */

      var codeTable = table[0];
      /** @type {number} */

      var maxCodeLength = table[1];
      /** @type {number} code length & code (16bit, 16bit) */

      var codeWithLength;
      /** @type {number} code bits length */

      var codeLength; // not enough buffer

      while (bitsbuflen < maxCodeLength) {
        if (ip >= inputLength) {
          break;
        }

        bitsbuf |= input[ip++] << bitsbuflen;
        bitsbuflen += 8;
      } // read max length


      codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
      codeLength = codeWithLength >>> 16;

      if (codeLength > bitsbuflen) {
        throw new Error('invalid code length: ' + codeLength);
      }

      this.bitsbuf = bitsbuf >> codeLength;
      this.bitsbuflen = bitsbuflen - codeLength;
      this.ip = ip;
      return codeWithLength & 0xffff;
    };
    /**
     * parse uncompressed block.
     */


    Zlib$1.RawInflate.prototype.parseUncompressedBlock = function () {
      var input = this.input;
      var ip = this.ip;
      var output = this.output;
      var op = this.op;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {number} block length */

      var len;
      /** @type {number} number for check block length */

      var nlen;
      /** @type {number} output buffer length */

      var olength = output.length;
      /** @type {number} copy counter */

      var preCopy; // skip buffered header bits

      this.bitsbuf = 0;
      this.bitsbuflen = 0; // len

      if (ip + 1 >= inputLength) {
        throw new Error('invalid uncompressed block header: LEN');
      }

      len = input[ip++] | input[ip++] << 8; // nlen

      if (ip + 1 >= inputLength) {
        throw new Error('invalid uncompressed block header: NLEN');
      }

      nlen = input[ip++] | input[ip++] << 8; // check len & nlen

      if (len === ~nlen) {
        throw new Error('invalid uncompressed block header: length verify');
      } // check size


      if (ip + len > input.length) {
        throw new Error('input buffer is broken');
      } // expand buffer


      switch (this.bufferType) {
        case Zlib$1.RawInflate.BufferType.BLOCK:
          // pre copy
          while (op + len > output.length) {
            preCopy = olength - op;
            len -= preCopy;
            {
              output.set(input.subarray(ip, ip + preCopy), op);
              op += preCopy;
              ip += preCopy;
            }
            this.op = op;
            output = this.expandBufferBlock();
            op = this.op;
          }

          break;

        case Zlib$1.RawInflate.BufferType.ADAPTIVE:
          while (op + len > output.length) {
            output = this.expandBufferAdaptive({
              fixRatio: 2
            });
          }

          break;

        default:
          throw new Error('invalid inflate mode');
      } // copy


      {
        output.set(input.subarray(ip, ip + len), op);
        op += len;
        ip += len;
      }
      this.ip = ip;
      this.op = op;
      this.output = output;
    };
    /**
     * parse fixed huffman block.
     */


    Zlib$1.RawInflate.prototype.parseFixedHuffmanBlock = function () {
      switch (this.bufferType) {
        case Zlib$1.RawInflate.BufferType.ADAPTIVE:
          this.decodeHuffmanAdaptive(Zlib$1.RawInflate.FixedLiteralLengthTable, Zlib$1.RawInflate.FixedDistanceTable);
          break;

        case Zlib$1.RawInflate.BufferType.BLOCK:
          this.decodeHuffmanBlock(Zlib$1.RawInflate.FixedLiteralLengthTable, Zlib$1.RawInflate.FixedDistanceTable);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * parse dynamic huffman block.
     */


    Zlib$1.RawInflate.prototype.parseDynamicHuffmanBlock = function () {
      /** @type {number} number of literal and length codes. */
      var hlit = this.readBits(5) + 257;
      /** @type {number} number of distance codes. */

      var hdist = this.readBits(5) + 1;
      /** @type {number} number of code lengths. */

      var hclen = this.readBits(4) + 4;
      /** @type {!(Uint8Array|Array.<number>)} code lengths. */

      var codeLengths = new Uint8Array(Zlib$1.RawInflate.Order.length);
      /** @type {!Array} code lengths table. */

      var codeLengthsTable;
      /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */

      var litlenTable;
      /** @type {!(Uint8Array|Array.<number>)} distance code table. */

      var distTable;
      /** @type {!(Uint8Array|Array.<number>)} code length table. */

      var lengthTable;
      /** @type {number} */

      var code;
      /** @type {number} */

      var prev;
      /** @type {number} */

      var repeat;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limit. */

      var il; // decode code lengths

      for (i = 0; i < hclen; ++i) {
        codeLengths[Zlib$1.RawInflate.Order[i]] = this.readBits(3);
      } // decode length table


      codeLengthsTable = buildHuffmanTable$1(codeLengths);
      lengthTable = new Uint8Array(hlit + hdist);

      for (i = 0, il = hlit + hdist; i < il;) {
        code = this.readCodeByTable(codeLengthsTable);

        switch (code) {
          case 16:
            repeat = 3 + this.readBits(2);

            while (repeat--) {
              lengthTable[i++] = prev;
            }

            break;

          case 17:
            repeat = 3 + this.readBits(3);

            while (repeat--) {
              lengthTable[i++] = 0;
            }

            prev = 0;
            break;

          case 18:
            repeat = 11 + this.readBits(7);

            while (repeat--) {
              lengthTable[i++] = 0;
            }

            prev = 0;
            break;

          default:
            lengthTable[i++] = code;
            prev = code;
            break;
        }
      }

      litlenTable = buildHuffmanTable$1(lengthTable.subarray(0, hlit));
      distTable = buildHuffmanTable$1(lengthTable.subarray(hlit));

      switch (this.bufferType) {
        case Zlib$1.RawInflate.BufferType.ADAPTIVE:
          this.decodeHuffmanAdaptive(litlenTable, distTable);
          break;

        case Zlib$1.RawInflate.BufferType.BLOCK:
          this.decodeHuffmanBlock(litlenTable, distTable);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * decode huffman code
     * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
     * @param {!(Array.<number>|Uint8Array)} dist distination code table.
     */


    Zlib$1.RawInflate.prototype.decodeHuffmanBlock = function (litlen, dist) {
      var output = this.output;
      var op = this.op;
      this.currentLitlenTable = litlen;
      /** @type {number} output position limit. */

      var olength = output.length - Zlib$1.RawInflate.MaxCopyLength;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var lengthCodeTable = Zlib$1.RawInflate.LengthCodeTable;
      var lengthExtraTable = Zlib$1.RawInflate.LengthExtraTable;
      var distCodeTable = Zlib$1.RawInflate.DistCodeTable;
      var distExtraTable = Zlib$1.RawInflate.DistExtraTable;

      while ((code = this.readCodeByTable(litlen)) !== 256) {
        // literal
        if (code < 256) {
          if (op >= olength) {
            this.op = op;
            output = this.expandBufferBlock();
            op = this.op;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = lengthCodeTable[ti];

        if (lengthExtraTable[ti] > 0) {
          codeLength += this.readBits(lengthExtraTable[ti]);
        } // dist code


        code = this.readCodeByTable(dist);
        codeDist = distCodeTable[code];

        if (distExtraTable[code] > 0) {
          codeDist += this.readBits(distExtraTable[code]);
        } // lz77 decode


        if (op >= olength) {
          this.op = op;
          output = this.expandBufferBlock();
          op = this.op;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
    };
    /**
     * decode huffman code (adaptive)
     * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
     * @param {!(Array.<number>|Uint8Array)} dist distination code table.
     */


    Zlib$1.RawInflate.prototype.decodeHuffmanAdaptive = function (litlen, dist) {
      var output = this.output;
      var op = this.op;
      this.currentLitlenTable = litlen;
      /** @type {number} output position limit. */

      var olength = output.length;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var lengthCodeTable = Zlib$1.RawInflate.LengthCodeTable;
      var lengthExtraTable = Zlib$1.RawInflate.LengthExtraTable;
      var distCodeTable = Zlib$1.RawInflate.DistCodeTable;
      var distExtraTable = Zlib$1.RawInflate.DistExtraTable;

      while ((code = this.readCodeByTable(litlen)) !== 256) {
        // literal
        if (code < 256) {
          if (op >= olength) {
            output = this.expandBufferAdaptive();
            olength = output.length;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = lengthCodeTable[ti];

        if (lengthExtraTable[ti] > 0) {
          codeLength += this.readBits(lengthExtraTable[ti]);
        } // dist code


        code = this.readCodeByTable(dist);
        codeDist = distCodeTable[code];

        if (distExtraTable[code] > 0) {
          codeDist += this.readBits(distExtraTable[code]);
        } // lz77 decode


        if (op + codeLength > olength) {
          output = this.expandBufferAdaptive();
          olength = output.length;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
    };
    /**
     * expand output buffer.
     * @param {Object=} opt_param option parameters.
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib$1.RawInflate.prototype.expandBufferBlock = function (opt_param) {
      /** @type {!(Array.<number>|Uint8Array)} store buffer. */
      var buffer = new Uint8Array(this.op - Zlib$1.RawInflate.MaxBackwardLength);
      /** @type {number} backward base point */

      var backward = this.op - Zlib$1.RawInflate.MaxBackwardLength;
      var output = this.output; // copy to output buffer

      {
        buffer.set(output.subarray(Zlib$1.RawInflate.MaxBackwardLength, buffer.length));
      }
      this.blocks.push(buffer);
      this.totalpos += buffer.length; // copy to backward buffer

      {
        output.set(output.subarray(backward, backward + Zlib$1.RawInflate.MaxBackwardLength));
      }
      this.op = Zlib$1.RawInflate.MaxBackwardLength;
      return output;
    };
    /**
     * expand output buffer. (adaptive)
     * @param {Object=} opt_param option parameters.
     * @return {!(Array.<number>|Uint8Array)} output buffer pointer.
     */


    Zlib$1.RawInflate.prototype.expandBufferAdaptive = function (opt_param) {
      /** @type {!(Array.<number>|Uint8Array)} store buffer. */
      var buffer;
      /** @type {number} expantion ratio. */

      var ratio = this.input.length / this.ip + 1 | 0;
      /** @type {number} maximum number of huffman code. */

      var maxHuffCode;
      /** @type {number} new output buffer size. */

      var newSize;
      /** @type {number} max inflate size. */

      var maxInflateSize;
      var input = this.input;
      var output = this.output;

      if (opt_param) {
        if (typeof opt_param.fixRatio === 'number') {
          ratio = opt_param.fixRatio;
        }

        if (typeof opt_param.addRatio === 'number') {
          ratio += opt_param.addRatio;
        }
      } // calculate new buffer size


      if (ratio < 2) {
        maxHuffCode = (input.length - this.ip) / this.currentLitlenTable[2];
        maxInflateSize = maxHuffCode / 2 * 258 | 0;
        newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
      } else {
        newSize = output.length * ratio;
      } // buffer expantion


      {
        buffer = new Uint8Array(newSize);
        buffer.set(output);
      }
      this.output = buffer;
      return this.output;
    };
    /**
     * concat output buffer.
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib$1.RawInflate.prototype.concatBufferBlock = function () {
      /** @type {number} buffer pointer. */
      var pos = 0;
      /** @type {number} buffer pointer. */

      var limit = this.totalpos + (this.op - Zlib$1.RawInflate.MaxBackwardLength);
      /** @type {!(Array.<number>|Uint8Array)} output block array. */

      var output = this.output;
      /** @type {!Array} blocks array. */

      var blocks = this.blocks;
      /** @type {!(Array.<number>|Uint8Array)} output block array. */

      var block;
      /** @type {!(Array.<number>|Uint8Array)} output buffer. */

      var buffer = new Uint8Array(limit);
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limiter. */

      var il;
      /** @type {number} loop counter. */

      var j;
      /** @type {number} loop limiter. */

      var jl; // single buffer

      if (blocks.length === 0) {
        return this.output.subarray(Zlib$1.RawInflate.MaxBackwardLength, this.op);
      } // copy to buffer


      for (i = 0, il = blocks.length; i < il; ++i) {
        block = blocks[i];

        for (j = 0, jl = block.length; j < jl; ++j) {
          buffer[pos++] = block[j];
        }
      } // current buffer


      for (i = Zlib$1.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
        buffer[pos++] = output[i];
      }

      this.blocks = [];
      this.buffer = buffer;
      return this.buffer;
    };
    /**
     * concat output buffer. (dynamic)
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib$1.RawInflate.prototype.concatBufferDynamic = function () {
      /** @type {Array.<number>|Uint8Array} output buffer. */
      var buffer;
      var op = this.op;
      {
        if (this.resize) {
          buffer = new Uint8Array(op);
          buffer.set(this.output.subarray(0, op));
        } else {
          buffer = this.output.subarray(0, op);
        }
      }
      this.buffer = buffer;
      return this.buffer;
    };

    var buildHuffmanTable$1 = Zlib$1.Huffman.buildHuffmanTable;
    /**
     * @param {!(Uint8Array|Array.<number>)} input input buffer.
     * @param {number} ip input buffer pointer.
     * @param {number=} opt_buffersize buffer block size.
     * @constructor
     */

    Zlib$1.RawInflateStream = function (input, ip, opt_buffersize) {
      /** @type {!Array.<(Array|Uint8Array)>} */
      this.blocks = [];
      /** @type {number} block size. */

      this.bufferSize = opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE$1;
      /** @type {!number} total output buffer pointer. */

      this.totalpos = 0;
      /** @type {!number} input buffer pointer. */

      this.ip = ip === void 0 ? 0 : ip;
      /** @type {!number} bit stream reader buffer. */

      this.bitsbuf = 0;
      /** @type {!number} bit stream reader buffer size. */

      this.bitsbuflen = 0;
      /** @type {!(Array|Uint8Array)} input buffer. */

      this.input = new Uint8Array(input);
      /** @type {!(Uint8Array|Array)} output buffer. */

      this.output = new Uint8Array(this.bufferSize);
      /** @type {!number} output buffer pointer. */

      this.op = 0;
      /** @type {boolean} is final block flag. */

      this.bfinal = false;
      /** @type {number} uncompressed block length. */

      this.blockLength;
      /** @type {boolean} resize flag for memory size optimization. */

      this.resize = false;
      /** @type {Array} */

      this.litlenTable;
      /** @type {Array} */

      this.distTable;
      /** @type {number} */

      this.sp = 0; // stream pointer

      /** @type {Zlib.RawInflateStream.Status} */

      this.status = Zlib$1.RawInflateStream.Status.INITIALIZED; //
      // backup
      //

      /** @type {!number} */

      this.ip_;
      /** @type {!number} */

      this.bitsbuflen_;
      /** @type {!number} */

      this.bitsbuf_;
    };
    /**
     * @enum {number}
     */


    Zlib$1.RawInflateStream.BlockType = {
      UNCOMPRESSED: 0,
      FIXED: 1,
      DYNAMIC: 2
    };
    /**
     * @enum {number}
     */

    Zlib$1.RawInflateStream.Status = {
      INITIALIZED: 0,
      BLOCK_HEADER_START: 1,
      BLOCK_HEADER_END: 2,
      BLOCK_BODY_START: 3,
      BLOCK_BODY_END: 4,
      DECODE_BLOCK_START: 5,
      DECODE_BLOCK_END: 6
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */

    Zlib$1.RawInflateStream.prototype.decompress = function (newInput, ip) {
      /** @type {boolean} */
      var stop = false;

      if (newInput !== void 0) {
        this.input = newInput;
      }

      if (ip !== void 0) {
        this.ip = ip;
      } // decompress


      while (!stop) {
        switch (this.status) {
          // block header
          case Zlib$1.RawInflateStream.Status.INITIALIZED:
          case Zlib$1.RawInflateStream.Status.BLOCK_HEADER_START:
            if (this.readBlockHeader() < 0) {
              stop = true;
            }

            break;
          // block body

          case Zlib$1.RawInflateStream.Status.BLOCK_HEADER_END:
          /* FALLTHROUGH */

          case Zlib$1.RawInflateStream.Status.BLOCK_BODY_START:
            switch (this.currentBlockType) {
              case Zlib$1.RawInflateStream.BlockType.UNCOMPRESSED:
                if (this.readUncompressedBlockHeader() < 0) {
                  stop = true;
                }

                break;

              case Zlib$1.RawInflateStream.BlockType.FIXED:
                if (this.parseFixedHuffmanBlock() < 0) {
                  stop = true;
                }

                break;

              case Zlib$1.RawInflateStream.BlockType.DYNAMIC:
                if (this.parseDynamicHuffmanBlock() < 0) {
                  stop = true;
                }

                break;
            }

            break;
          // decode data

          case Zlib$1.RawInflateStream.Status.BLOCK_BODY_END:
          case Zlib$1.RawInflateStream.Status.DECODE_BLOCK_START:
            switch (this.currentBlockType) {
              case Zlib$1.RawInflateStream.BlockType.UNCOMPRESSED:
                if (this.parseUncompressedBlock() < 0) {
                  stop = true;
                }

                break;

              case Zlib$1.RawInflateStream.BlockType.FIXED:
              /* FALLTHROUGH */

              case Zlib$1.RawInflateStream.BlockType.DYNAMIC:
                if (this.decodeHuffman() < 0) {
                  stop = true;
                }

                break;
            }

            break;

          case Zlib$1.RawInflateStream.Status.DECODE_BLOCK_END:
            if (this.bfinal) {
              stop = true;
            } else {
              this.status = Zlib$1.RawInflateStream.Status.INITIALIZED;
            }

            break;
        }
      }

      return this.concatBuffer();
    };
    /**
     * @const
     * @type {number} max backward length for LZ77.
     */


    Zlib$1.RawInflateStream.MaxBackwardLength = 32768;
    /**
     * @const
     * @type {number} max copy length for LZ77.
     */

    Zlib$1.RawInflateStream.MaxCopyLength = 258;
    /**
     * huffman order
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */

    Zlib$1.RawInflateStream.Order = function (table) {
      return new Uint16Array(table);
    }([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    /**
     * huffman length code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib$1.RawInflateStream.LengthCodeTable = function (table) {
      return new Uint16Array(table);
    }([0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b, 0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3, 0x00e3, 0x0102, 0x0102, 0x0102]);
    /**
     * huffman length extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib$1.RawInflateStream.LengthExtraTable = function (table) {
      return new Uint8Array(table);
    }([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
    /**
     * huffman dist code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib$1.RawInflateStream.DistCodeTable = function (table) {
      return new Uint16Array(table);
    }([0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001]);
    /**
     * huffman dist extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib$1.RawInflateStream.DistExtraTable = function (table) {
      return new Uint8Array(table);
    }([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    /**
     * fixed huffman length code table
     * @const
     * @type {!Array}
     */


    Zlib$1.RawInflateStream.FixedLiteralLengthTable = function (table) {
      return table;
    }(function () {
      var lengths = new Uint8Array(288);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
      }

      return buildHuffmanTable$1(lengths);
    }());
    /**
     * fixed huffman distance code table
     * @const
     * @type {!Array}
     */


    Zlib$1.RawInflateStream.FixedDistanceTable = function (table) {
      return table;
    }(function () {
      var lengths = new Uint8Array(30);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = 5;
      }

      return buildHuffmanTable$1(lengths);
    }());
    /**
     * parse deflated block.
     */


    Zlib$1.RawInflateStream.prototype.readBlockHeader = function () {
      /** @type {number} header */
      var hdr;
      this.status = Zlib$1.RawInflateStream.Status.BLOCK_HEADER_START;
      this.save_();

      if ((hdr = this.readBits(3)) < 0) {
        this.restore_();
        return -1;
      } // BFINAL


      if (hdr & 0x1) {
        this.bfinal = true;
      } // BTYPE


      hdr >>>= 1;

      switch (hdr) {
        case 0:
          // uncompressed
          this.currentBlockType = Zlib$1.RawInflateStream.BlockType.UNCOMPRESSED;
          break;

        case 1:
          // fixed huffman
          this.currentBlockType = Zlib$1.RawInflateStream.BlockType.FIXED;
          break;

        case 2:
          // dynamic huffman
          this.currentBlockType = Zlib$1.RawInflateStream.BlockType.DYNAMIC;
          break;

        default:
          // reserved or other
          throw new Error('unknown BTYPE: ' + hdr);
      }

      this.status = Zlib$1.RawInflateStream.Status.BLOCK_HEADER_END;
    };
    /**
     * read inflate bits
     * @param {number} length bits length.
     * @return {number} read bits.
     */


    Zlib$1.RawInflateStream.prototype.readBits = function (length) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} input and output byte. */

      var octet; // not enough buffer

      while (bitsbuflen < length) {
        // input byte
        if (input.length <= ip) {
          return -1;
        }

        octet = input[ip++]; // concat octet

        bitsbuf |= octet << bitsbuflen;
        bitsbuflen += 8;
      } // output byte


      octet = bitsbuf &
      /* MASK */
      (1 << length) - 1;
      bitsbuf >>>= length;
      bitsbuflen -= length;
      this.bitsbuf = bitsbuf;
      this.bitsbuflen = bitsbuflen;
      this.ip = ip;
      return octet;
    };
    /**
     * read huffman code using table
     * @param {Array} table huffman code table.
     * @return {number} huffman code.
     */


    Zlib$1.RawInflateStream.prototype.readCodeByTable = function (table) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {!(Array|Uint8Array)} huffman code table */

      var codeTable = table[0];
      /** @type {number} */

      var maxCodeLength = table[1];
      /** @type {number} input byte */

      var octet;
      /** @type {number} code length & code (16bit, 16bit) */

      var codeWithLength;
      /** @type {number} code bits length */

      var codeLength; // not enough buffer

      while (bitsbuflen < maxCodeLength) {
        if (input.length <= ip) {
          return -1;
        }

        octet = input[ip++];
        bitsbuf |= octet << bitsbuflen;
        bitsbuflen += 8;
      } // read max length


      codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
      codeLength = codeWithLength >>> 16;

      if (codeLength > bitsbuflen) {
        throw new Error('invalid code length: ' + codeLength);
      }

      this.bitsbuf = bitsbuf >> codeLength;
      this.bitsbuflen = bitsbuflen - codeLength;
      this.ip = ip;
      return codeWithLength & 0xffff;
    };
    /**
     * read uncompressed block header
     */


    Zlib$1.RawInflateStream.prototype.readUncompressedBlockHeader = function () {
      /** @type {number} block length */
      var len;
      /** @type {number} number for check block length */

      var nlen;
      var input = this.input;
      var ip = this.ip;
      this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_START;

      if (ip + 4 >= input.length) {
        return -1;
      }

      len = input[ip++] | input[ip++] << 8;
      nlen = input[ip++] | input[ip++] << 8; // check len & nlen

      if (len === ~nlen) {
        throw new Error('invalid uncompressed block header: length verify');
      } // skip buffered header bits


      this.bitsbuf = 0;
      this.bitsbuflen = 0;
      this.ip = ip;
      this.blockLength = len;
      this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_END;
    };
    /**
     * parse uncompressed block.
     */


    Zlib$1.RawInflateStream.prototype.parseUncompressedBlock = function () {
      var input = this.input;
      var ip = this.ip;
      var output = this.output;
      var op = this.op;
      var len = this.blockLength;
      this.status = Zlib$1.RawInflateStream.Status.DECODE_BLOCK_START; // copy
      // XXX: とりあえず素直にコピー

      while (len--) {
        if (op === output.length) {
          output = this.expandBuffer({
            fixRatio: 2
          });
        } // not enough input buffer


        if (ip >= input.length) {
          this.ip = ip;
          this.op = op;
          this.blockLength = len + 1; // コピーしてないので戻す

          return -1;
        }

        output[op++] = input[ip++];
      }

      if (len < 0) {
        this.status = Zlib$1.RawInflateStream.Status.DECODE_BLOCK_END;
      }

      this.ip = ip;
      this.op = op;
      return 0;
    };
    /**
     * parse fixed huffman block.
     */


    Zlib$1.RawInflateStream.prototype.parseFixedHuffmanBlock = function () {
      this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_START;
      this.litlenTable = Zlib$1.RawInflateStream.FixedLiteralLengthTable;
      this.distTable = Zlib$1.RawInflateStream.FixedDistanceTable;
      this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_END;
      return 0;
    };
    /**
     * オブジェクトのコンテキストを別のプロパティに退避する.
     * @private
     */


    Zlib$1.RawInflateStream.prototype.save_ = function () {
      this.ip_ = this.ip;
      this.bitsbuflen_ = this.bitsbuflen;
      this.bitsbuf_ = this.bitsbuf;
    };
    /**
     * 別のプロパティに退避したコンテキストを復元する.
     * @private
     */


    Zlib$1.RawInflateStream.prototype.restore_ = function () {
      this.ip = this.ip_;
      this.bitsbuflen = this.bitsbuflen_;
      this.bitsbuf = this.bitsbuf_;
    };
    /**
     * parse dynamic huffman block.
     */


    Zlib$1.RawInflateStream.prototype.parseDynamicHuffmanBlock = function () {
      /** @type {number} number of literal and length codes. */
      var hlit;
      /** @type {number} number of distance codes. */

      var hdist;
      /** @type {number} number of code lengths. */

      var hclen;
      /** @type {!(Uint8Array|Array)} code lengths. */

      var codeLengths = new Uint8Array(Zlib$1.RawInflateStream.Order.length);
      /** @type {!Array} code lengths table. */

      var codeLengthsTable;
      this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_START;
      this.save_();
      hlit = this.readBits(5) + 257;
      hdist = this.readBits(5) + 1;
      hclen = this.readBits(4) + 4;

      if (hlit < 0 || hdist < 0 || hclen < 0) {
        this.restore_();
        return -1;
      }

      try {
        parseDynamicHuffmanBlockImpl.call(this);
      } catch (e) {
        this.restore_();
        return -1;
      }

      function parseDynamicHuffmanBlockImpl() {
        /** @type {number} */
        var bits;
        var code;
        var prev = 0;
        var repeat;
        /** @type {!(Uint8Array|Array.<number>)} code length table. */

        var lengthTable;
        /** @type {number} loop counter. */

        var i;
        /** @type {number} loop limit. */

        var il; // decode code lengths

        for (i = 0; i < hclen; ++i) {
          if ((bits = this.readBits(3)) < 0) {
            throw new Error('not enough input');
          }

          codeLengths[Zlib$1.RawInflateStream.Order[i]] = bits;
        } // decode length table


        codeLengthsTable = buildHuffmanTable$1(codeLengths);
        lengthTable = new Uint8Array(hlit + hdist);

        for (i = 0, il = hlit + hdist; i < il;) {
          code = this.readCodeByTable(codeLengthsTable);

          if (code < 0) {
            throw new Error('not enough input');
          }

          switch (code) {
            case 16:
              if ((bits = this.readBits(2)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 3 + bits;

              while (repeat--) {
                lengthTable[i++] = prev;
              }

              break;

            case 17:
              if ((bits = this.readBits(3)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 3 + bits;

              while (repeat--) {
                lengthTable[i++] = 0;
              }

              prev = 0;
              break;

            case 18:
              if ((bits = this.readBits(7)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 11 + bits;

              while (repeat--) {
                lengthTable[i++] = 0;
              }

              prev = 0;
              break;

            default:
              lengthTable[i++] = code;
              prev = code;
              break;
          }
        }

        this.litlenTable = buildHuffmanTable$1(lengthTable.subarray(0, hlit));
        this.distTable = buildHuffmanTable$1(lengthTable.subarray(hlit));
      }

      this.status = Zlib$1.RawInflateStream.Status.BLOCK_BODY_END;
      return 0;
    };
    /**
     * decode huffman code (dynamic)
     * @return {(number|undefined)} -1 is error.
     */


    Zlib$1.RawInflateStream.prototype.decodeHuffman = function () {
      var output = this.output;
      var op = this.op;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var litlen = this.litlenTable;
      var dist = this.distTable;
      var olength = output.length;
      var bits;
      this.status = Zlib$1.RawInflateStream.Status.DECODE_BLOCK_START;

      while (true) {
        this.save_();
        code = this.readCodeByTable(litlen);

        if (code < 0) {
          this.op = op;
          this.restore_();
          return -1;
        }

        if (code === 256) {
          break;
        } // literal


        if (code < 256) {
          if (op === olength) {
            output = this.expandBuffer();
            olength = output.length;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = Zlib$1.RawInflateStream.LengthCodeTable[ti];

        if (Zlib$1.RawInflateStream.LengthExtraTable[ti] > 0) {
          bits = this.readBits(Zlib$1.RawInflateStream.LengthExtraTable[ti]);

          if (bits < 0) {
            this.op = op;
            this.restore_();
            return -1;
          }

          codeLength += bits;
        } // dist code


        code = this.readCodeByTable(dist);

        if (code < 0) {
          this.op = op;
          this.restore_();
          return -1;
        }

        codeDist = Zlib$1.RawInflateStream.DistCodeTable[code];

        if (Zlib$1.RawInflateStream.DistExtraTable[code] > 0) {
          bits = this.readBits(Zlib$1.RawInflateStream.DistExtraTable[code]);

          if (bits < 0) {
            this.op = op;
            this.restore_();
            return -1;
          }

          codeDist += bits;
        } // lz77 decode


        if (op + codeLength >= olength) {
          output = this.expandBuffer();
          olength = output.length;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        } // break


        if (this.ip === this.input.length) {
          this.op = op;
          return -1;
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
      this.status = Zlib$1.RawInflateStream.Status.DECODE_BLOCK_END;
    };
    /**
     * expand output buffer. (dynamic)
     * @param {Object=} opt_param option parameters.
     * @return {!(Array|Uint8Array)} output buffer pointer.
     */


    Zlib$1.RawInflateStream.prototype.expandBuffer = function (opt_param) {
      /** @type {!(Array|Uint8Array)} store buffer. */
      var buffer;
      /** @type {number} expantion ratio. */

      var ratio = this.input.length / this.ip + 1 | 0;
      /** @type {number} maximum number of huffman code. */

      var maxHuffCode;
      /** @type {number} new output buffer size. */

      var newSize;
      /** @type {number} max inflate size. */

      var maxInflateSize;
      var input = this.input;
      var output = this.output;

      if (opt_param) {
        if (typeof opt_param.fixRatio === 'number') {
          ratio = opt_param.fixRatio;
        }

        if (typeof opt_param.addRatio === 'number') {
          ratio += opt_param.addRatio;
        }
      } // calculate new buffer size


      if (ratio < 2) {
        maxHuffCode = (input.length - this.ip) / this.litlenTable[2];
        maxInflateSize = maxHuffCode / 2 * 258 | 0;
        newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
      } else {
        newSize = output.length * ratio;
      } // buffer expantion


      {
        buffer = new Uint8Array(newSize);
        buffer.set(output);
      }
      this.output = buffer;
      return this.output;
    };
    /**
     * concat output buffer. (dynamic)
     * @return {!(Array|Uint8Array)} output buffer.
     */


    Zlib$1.RawInflateStream.prototype.concatBuffer = function () {
      /** @type {!(Array|Uint8Array)} output buffer. */
      var buffer;
      /** @type {number} */

      var op = this.op;
      /** @type {Uint8Array} */

      var tmp;

      if (this.resize) {
        {
          buffer = new Uint8Array(this.output.subarray(this.sp, op));
        }
      } else {
        buffer = this.output.subarray(this.sp, op);
      }

      this.sp = op; // compaction

      if (op > Zlib$1.RawInflateStream.MaxBackwardLength + this.bufferSize) {
        this.op = this.sp = Zlib$1.RawInflateStream.MaxBackwardLength;
        {
          tmp =
          /** @type {Uint8Array} */
          this.output;
          this.output = new Uint8Array(this.bufferSize + Zlib$1.RawInflateStream.MaxBackwardLength);
          this.output.set(tmp.subarray(op - Zlib$1.RawInflateStream.MaxBackwardLength, op));
        }
      }

      return buffer;
    };
    /**
     * @constructor
     * @param {!(Uint8Array|Array)} input deflated buffer.
     * @param {Object=} opt_params option parameters.
     *
     * opt_params は以下のプロパティを指定する事ができます。
     *   - index: input buffer の deflate コンテナの開始位置.
     *   - blockSize: バッファのブロックサイズ.
     *   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
     *   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
     *       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
     */


    Zlib$1.Inflate = function (input, opt_params) {
      /** @type {number} */
      var cmf;
      /** @type {number} */

      var flg;
      /** @type {!(Uint8Array|Array)} */

      this.input = input;
      /** @type {number} */

      this.ip = 0;
      /** @type {Zlib.RawInflate} */

      this.rawinflate;
      /** @type {(boolean|undefined)} verify flag. */

      this.verify; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (opt_params['index']) {
          this.ip = opt_params['index'];
        }

        if (opt_params['verify']) {
          this.verify = opt_params['verify'];
        }
      } // Compression Method and Flags


      cmf = input[this.ip++];
      flg = input[this.ip++]; // compression method

      switch (cmf & 0x0f) {
        case Zlib$1.CompressionMethod.DEFLATE:
          this.method = Zlib$1.CompressionMethod.DEFLATE;
          break;

        default:
          throw new Error('unsupported compression method');
      } // fcheck


      if (((cmf << 8) + flg) % 31 !== 0) {
        throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
      } // fdict (not supported)


      if (flg & 0x20) {
        throw new Error('fdict flag is not supported');
      } // RawInflate


      this.rawinflate = new Zlib$1.RawInflate(input, {
        'index': this.ip,
        'bufferSize': opt_params['bufferSize'],
        'bufferType': opt_params['bufferType'],
        'resize': opt_params['resize']
      });
    };
    /**
     * @enum {number}
     */


    Zlib$1.Inflate.BufferType = Zlib$1.RawInflate.BufferType;
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */

    Zlib$1.Inflate.prototype.decompress = function () {
      /** @type {!(Array|Uint8Array)} input buffer. */
      var input = this.input;
      /** @type {!(Uint8Array|Array)} inflated buffer. */

      var buffer;
      /** @type {number} adler-32 checksum */

      var adler32;
      buffer = this.rawinflate.decompress();
      this.ip = this.rawinflate.ip; // verify adler-32

      if (this.verify) {
        adler32 = (input[this.ip++] << 24 | input[this.ip++] << 16 | input[this.ip++] << 8 | input[this.ip++]) >>> 0;

        if (adler32 !== Zlib$1.Adler32(buffer)) {
          throw new Error('invalid adler-32 checksum');
        }
      }

      return buffer;
    };
    /* vim:set expandtab ts=2 sw=2 tw=80: */

    /**
     * @param {!(Uint8Array|Array)} input deflated buffer.
     * @constructor
     */


    Zlib$1.InflateStream = function (input) {
      /** @type {!(Uint8Array|Array)} */
      this.input = input === void 0 ? new Uint8Array() : input;
      /** @type {number} */

      this.ip = 0;
      /** @type {Zlib.RawInflateStream} */

      this.rawinflate = new Zlib$1.RawInflateStream(this.input, this.ip);
      /** @type {Zlib.CompressionMethod} */

      this.method;
      /** @type {!(Array|Uint8Array)} */

      this.output = this.rawinflate.output;
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */


    Zlib$1.InflateStream.prototype.decompress = function (input) {
      /** @type {!(Uint8Array|Array)} inflated buffer. */
      var buffer; // 新しい入力を入力バッファに結合する
      // XXX Array, Uint8Array のチェックを行うか確認する

      if (input !== void 0) {
        {
          var tmp = new Uint8Array(this.input.length + input.length);
          tmp.set(this.input, 0);
          tmp.set(input, this.input.length);
          this.input = tmp;
        }
      }

      if (this.method === void 0) {
        if (this.readHeader() < 0) {
          return new Uint8Array();
        }
      }

      buffer = this.rawinflate.decompress(this.input, this.ip);

      if (this.rawinflate.ip !== 0) {
        this.input = this.input.subarray(this.rawinflate.ip);
        this.ip = 0;
      } // verify adler-32

      /*
      if (this.verify) {
        adler32 =
          input[this.ip++] << 24 | input[this.ip++] << 16 |
          input[this.ip++] << 8 | input[this.ip++];
         if (adler32 !== Zlib.Adler32(buffer)) {
          throw new Error('invalid adler-32 checksum');
        }
      }
      */


      return buffer;
    };

    Zlib$1.InflateStream.prototype.readHeader = function () {
      var ip = this.ip;
      var input = this.input; // Compression Method and Flags

      var cmf = input[ip++];
      var flg = input[ip++];

      if (cmf === void 0 || flg === void 0) {
        return -1;
      } // compression method


      switch (cmf & 0x0f) {
        case Zlib$1.CompressionMethod.DEFLATE:
          this.method = Zlib$1.CompressionMethod.DEFLATE;
          break;

        default:
          throw new Error('unsupported compression method');
      } // fcheck


      if (((cmf << 8) + flg) % 31 !== 0) {
        throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
      } // fdict (not supported)


      if (flg & 0x20) {
        throw new Error('fdict flag is not supported');
      }

      this.ip = ip;
    };
    /**
     * @fileoverview GZIP (RFC1952) 展開コンテナ実装.
     */

    /**
     * @constructor
     * @param {!(Array|Uint8Array)} input input buffer.
     * @param {Object=} opt_params option parameters.
     */


    Zlib$1.Gunzip = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */
      this.input = input;
      /** @type {number} input buffer pointer. */

      this.ip = 0;
      /** @type {Array.<Zlib.GunzipMember>} */

      this.member = [];
      /** @type {boolean} */

      this.decompressed = false;
    };
    /**
     * @return {Array.<Zlib.GunzipMember>}
     */


    Zlib$1.Gunzip.prototype.getMembers = function () {
      if (!this.decompressed) {
        this.decompress();
      }

      return this.member.slice();
    };
    /**
     * inflate gzip data.
     * @return {!(Array.<number>|Uint8Array)} inflated buffer.
     */


    Zlib$1.Gunzip.prototype.decompress = function () {
      /** @type {number} input length. */
      var il = this.input.length;

      while (this.ip < il) {
        this.decodeMember();
      }

      this.decompressed = true;
      return this.concatMember();
    };
    /**
     * decode gzip member.
     */


    Zlib$1.Gunzip.prototype.decodeMember = function () {
      /** @type {Zlib.GunzipMember} */
      var member = new Zlib$1.GunzipMember();
      /** @type {number} */

      var isize;
      /** @type {Zlib.RawInflate} RawInflate implementation. */

      var rawinflate;
      /** @type {!(Array.<number>|Uint8Array)} inflated data. */

      var inflated;
      /** @type {number} inflate size */

      var inflen;
      /** @type {number} character code */

      var c;
      /** @type {number} character index in string. */

      var ci;
      /** @type {Array.<string>} character array. */

      var str;
      /** @type {number} modification time. */

      var mtime;
      /** @type {number} */

      var crc32;
      var input = this.input;
      var ip = this.ip;
      member.id1 = input[ip++];
      member.id2 = input[ip++]; // check signature

      if (member.id1 !== 0x1f || member.id2 !== 0x8b) {
        throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);
      } // check compression method


      member.cm = input[ip++];

      switch (member.cm) {
        case 8:
          /* XXX: use Zlib const */
          break;

        default:
          throw new Error('unknown compression method: ' + member.cm);
      } // flags


      member.flg = input[ip++]; // modification time

      mtime = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24;
      member.mtime = new Date(mtime * 1000); // extra flags

      member.xfl = input[ip++]; // operating system

      member.os = input[ip++]; // extra

      if ((member.flg & Zlib$1.Gzip.FlagsMask.FEXTRA) > 0) {
        member.xlen = input[ip++] | input[ip++] << 8;
        ip = this.decodeSubField(ip, member.xlen);
      } // fname


      if ((member.flg & Zlib$1.Gzip.FlagsMask.FNAME) > 0) {
        for (str = [], ci = 0; (c = input[ip++]) > 0;) {
          str[ci++] = String.fromCharCode(c);
        }

        member.name = str.join('');
      } // fcomment


      if ((member.flg & Zlib$1.Gzip.FlagsMask.FCOMMENT) > 0) {
        for (str = [], ci = 0; (c = input[ip++]) > 0;) {
          str[ci++] = String.fromCharCode(c);
        }

        member.comment = str.join('');
      } // fhcrc


      if ((member.flg & Zlib$1.Gzip.FlagsMask.FHCRC) > 0) {
        member.crc16 = Zlib$1.CRC32.calc(input, 0, ip) & 0xffff;

        if (member.crc16 !== (input[ip++] | input[ip++] << 8)) {
          throw new Error('invalid header crc16');
        }
      } // isize を事前に取得すると展開後のサイズが分かるため、
      // inflate処理のバッファサイズが事前に分かり、高速になる


      isize = input[input.length - 4] | input[input.length - 3] << 8 | input[input.length - 2] << 16 | input[input.length - 1] << 24; // isize の妥当性チェック
      // ハフマン符号では最小 2-bit のため、最大で 1/4 になる
      // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、
      // 1/128 になるとする
      // ここから入力バッファの残りが isize の 512 倍以上だったら
      // サイズ指定のバッファ確保は行わない事とする

      if (input.length - ip -
      /* CRC-32 */
      4 -
      /* ISIZE */
      4 < isize * 512) {
        inflen = isize;
      } // compressed block


      rawinflate = new Zlib$1.RawInflate(input, {
        'index': ip,
        'bufferSize': inflen
      });
      member.data = inflated = rawinflate.decompress();
      ip = rawinflate.ip; // crc32

      member.crc32 = crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;

      if (Zlib$1.CRC32.calc(inflated) !== crc32) {
        throw new Error('invalid CRC-32 checksum: 0x' + Zlib$1.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));
      } // input size


      member.isize = isize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;

      if ((inflated.length & 0xffffffff) !== isize) {
        throw new Error('invalid input size: ' + (inflated.length & 0xffffffff) + ' / ' + isize);
      }

      this.member.push(member);
      this.ip = ip;
    };
    /**
     * サブフィールドのデコード
     * XXX: 現在は何もせずスキップする
     */


    Zlib$1.Gunzip.prototype.decodeSubField = function (ip, length) {
      return ip + length;
    };
    /**
     * @return {!(Array.<number>|Uint8Array)}
     */


    Zlib$1.Gunzip.prototype.concatMember = function () {
      /** @type {Array.<Zlib.GunzipMember>} */
      var member = this.member;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {number} */

      var p = 0;
      /** @type {number} */

      var size = 0;
      /** @type {!(Array.<number>|Uint8Array)} */

      var buffer;

      for (i = 0, il = member.length; i < il; ++i) {
        size += member[i].data.length;
      }

      {
        buffer = new Uint8Array(size);

        for (i = 0; i < il; ++i) {
          buffer.set(member[i].data, p);
          p += member[i].data.length;
        }
      }
      return buffer;
    };
    /**
     * @constructor
     */


    Zlib$1.GunzipMember = function () {
      /** @type {number} signature first byte. */
      this.id1;
      /** @type {number} signature second byte. */

      this.id2;
      /** @type {number} compression method. */

      this.cm;
      /** @type {number} flags. */

      this.flg;
      /** @type {Date} modification time. */

      this.mtime;
      /** @type {number} extra flags. */

      this.xfl;
      /** @type {number} operating system number. */

      this.os;
      /** @type {number} CRC-16 value for FHCRC flag. */

      this.crc16;
      /** @type {number} extra length. */

      this.xlen;
      /** @type {number} CRC-32 value for verification. */

      this.crc32;
      /** @type {number} input size modulo 32 value. */

      this.isize;
      /** @type {string} filename. */

      this.name;
      /** @type {string} comment. */

      this.comment;
      /** @type {!(Uint8Array|Array.<number>)} */

      this.data;
    };

    Zlib$1.GunzipMember.prototype.getName = function () {
      return this.name;
    };

    Zlib$1.GunzipMember.prototype.getData = function () {
      return this.data;
    };

    Zlib$1.GunzipMember.prototype.getMtime = function () {
      return this.mtime;
    };
    /**
     * @fileoverview GZIP (RFC1952) 実装.
     */

    /**
     * @constructor
     * @param {!(Array|Uint8Array)} input input buffer.
     * @param {Object=} opt_params option parameters.
     */


    Zlib$1.Gzip = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */
      this.input = input;
      /** @type {number} input buffer pointer. */

      this.ip = 0;
      /** @type {!(Array.<number>|Uint8Array)} output buffer. */

      this.output;
      /** @type {number} output buffer. */

      this.op = 0;
      /** @type {!Object} flags option flags. */

      this.flags = {};
      /** @type {!string} filename. */

      this.filename;
      /** @type {!string} comment. */

      this.comment;
      /** @type {!Object} deflate options. */

      this.deflateOptions; // option parameters

      if (opt_params) {
        if (opt_params['flags']) {
          this.flags = opt_params['flags'];
        }

        if (typeof opt_params['filename'] === 'string') {
          this.filename = opt_params['filename'];
        }

        if (typeof opt_params['comment'] === 'string') {
          this.comment = opt_params['comment'];
        }

        if (opt_params['deflateOptions']) {
          this.deflateOptions = opt_params['deflateOptions'];
        }
      }

      if (!this.deflateOptions) {
        this.deflateOptions = {};
      }
    };
    /**
     * @type {number}
     * @const
     */


    Zlib$1.Gzip.DefaultBufferSize = 0x8000;
    /**
     * encode gzip members.
     * @return {!(Array|Uint8Array)} gzip binary array.
     */

    Zlib$1.Gzip.prototype.compress = function () {
      /** @type {number} flags. */
      var flg;
      /** @type {number} modification time. */

      var mtime;
      /** @type {number} CRC-16 value for FHCRC flag. */

      var crc16;
      /** @type {number} CRC-32 value for verification. */

      var crc32;
      /** @type {!Zlib.RawDeflate} raw deflate object. */

      var rawdeflate;
      /** @type {number} character code */

      var c;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limiter. */

      var il;
      /** @type {!(Array|Uint8Array)} output buffer. */

      var output = new Uint8Array(Zlib$1.Gzip.DefaultBufferSize);
      /** @type {number} output buffer pointer. */

      var op = 0;
      var input = this.input;
      var ip = this.ip;
      var filename = this.filename;
      var comment = this.comment; // check signature

      output[op++] = 0x1f;
      output[op++] = 0x8b; // check compression method

      output[op++] = 8;
      /* XXX: use Zlib const */
      // flags

      flg = 0;
      if (this.flags['fname']) flg |= Zlib$1.Gzip.FlagsMask.FNAME;
      if (this.flags['fcomment']) flg |= Zlib$1.Gzip.FlagsMask.FCOMMENT;
      if (this.flags['fhcrc']) flg |= Zlib$1.Gzip.FlagsMask.FHCRC; // XXX: FTEXT
      // XXX: FEXTRA

      output[op++] = flg; // modification time

      mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;
      output[op++] = mtime & 0xff;
      output[op++] = mtime >>> 8 & 0xff;
      output[op++] = mtime >>> 16 & 0xff;
      output[op++] = mtime >>> 24 & 0xff; // extra flags

      output[op++] = 0; // operating system

      output[op++] = Zlib$1.Gzip.OperatingSystem.UNKNOWN; // extra

      /* NOP */
      // fname

      if (this.flags['fname'] !== void 0) {
        for (i = 0, il = filename.length; i < il; ++i) {
          c = filename.charCodeAt(i);

          if (c > 0xff) {
            output[op++] = c >>> 8 & 0xff;
          }

          output[op++] = c & 0xff;
        }

        output[op++] = 0; // null termination
      } // fcomment


      if (this.flags['comment']) {
        for (i = 0, il = comment.length; i < il; ++i) {
          c = comment.charCodeAt(i);

          if (c > 0xff) {
            output[op++] = c >>> 8 & 0xff;
          }

          output[op++] = c & 0xff;
        }

        output[op++] = 0; // null termination
      } // fhcrc


      if (this.flags['fhcrc']) {
        crc16 = Zlib$1.CRC32.calc(output, 0, op) & 0xffff;
        output[op++] = crc16 & 0xff;
        output[op++] = crc16 >>> 8 & 0xff;
      } // add compress option


      this.deflateOptions['outputBuffer'] = output;
      this.deflateOptions['outputIndex'] = op; // compress

      rawdeflate = new Zlib$1.RawDeflate(input, this.deflateOptions);
      output = rawdeflate.compress();
      op = rawdeflate.op; // expand buffer

      {
        if (op + 8 > output.buffer.byteLength) {
          this.output = new Uint8Array(op + 8);
          this.output.set(new Uint8Array(output.buffer));
          output = this.output;
        } else {
          output = new Uint8Array(output.buffer);
        }
      } // crc32

      crc32 = Zlib$1.CRC32.calc(input);
      output[op++] = crc32 & 0xff;
      output[op++] = crc32 >>> 8 & 0xff;
      output[op++] = crc32 >>> 16 & 0xff;
      output[op++] = crc32 >>> 24 & 0xff; // input size

      il = input.length;
      output[op++] = il & 0xff;
      output[op++] = il >>> 8 & 0xff;
      output[op++] = il >>> 16 & 0xff;
      output[op++] = il >>> 24 & 0xff;
      this.ip = ip;

      if (op < output.length) {
        this.output = output = output.subarray(0, op);
      }

      return output;
    };
    /** @enum {number} */


    Zlib$1.Gzip.OperatingSystem = {
      FAT: 0,
      AMIGA: 1,
      VMS: 2,
      UNIX: 3,
      VM_CMS: 4,
      ATARI_TOS: 5,
      HPFS: 6,
      MACINTOSH: 7,
      Z_SYSTEM: 8,
      CP_M: 9,
      TOPS_20: 10,
      NTFS: 11,
      QDOS: 12,
      ACORN_RISCOS: 13,
      UNKNOWN: 255
    };
    /** @enum {number} */

    Zlib$1.Gzip.FlagsMask = {
      FTEXT: 0x01,
      FHCRC: 0x02,
      FEXTRA: 0x04,
      FNAME: 0x08,
      FCOMMENT: 0x10
    };
    /**
     * @fileoverview Heap Sort 実装. ハフマン符号化で使用する.
     */

    /**
     * カスタムハフマン符号で使用するヒープ実装
     * @param {number} length ヒープサイズ.
     * @constructor
     */

    Zlib$1.Heap = function (length) {
      this.buffer = new Uint16Array(length * 2);
      this.length = 0;
    };
    /**
     * 親ノードの index 取得
     * @param {number} index 子ノードの index.
     * @return {number} 親ノードの index.
     *
     */


    Zlib$1.Heap.prototype.getParent = function (index) {
      return ((index - 2) / 4 | 0) * 2;
    };
    /**
     * 子ノードの index 取得
     * @param {number} index 親ノードの index.
     * @return {number} 子ノードの index.
     */


    Zlib$1.Heap.prototype.getChild = function (index) {
      return 2 * index + 2;
    };
    /**
     * Heap に値を追加する
     * @param {number} index キー index.
     * @param {number} value 値.
     * @return {number} 現在のヒープ長.
     */


    Zlib$1.Heap.prototype.push = function (index, value) {
      var current,
          parent,
          heap = this.buffer,
          swap;
      current = this.length;
      heap[this.length++] = value;
      heap[this.length++] = index; // ルートノードにたどり着くまで入れ替えを試みる

      while (current > 0) {
        parent = this.getParent(current); // 親ノードと比較して親の方が小さければ入れ替える

        if (heap[current] > heap[parent]) {
          swap = heap[current];
          heap[current] = heap[parent];
          heap[parent] = swap;
          swap = heap[current + 1];
          heap[current + 1] = heap[parent + 1];
          heap[parent + 1] = swap;
          current = parent; // 入れ替えが必要なくなったらそこで抜ける
        } else {
          break;
        }
      }

      return this.length;
    };
    /**
     * Heapから一番大きい値を返す
     * @return {{index: number, value: number, length: number}} {index: キーindex,
     *     value: 値, length: ヒープ長} の Object.
     */


    Zlib$1.Heap.prototype.pop = function () {
      var index,
          value,
          heap = this.buffer,
          swap,
          current,
          parent;
      value = heap[0];
      index = heap[1]; // 後ろから値を取る

      this.length -= 2;
      heap[0] = heap[this.length];
      heap[1] = heap[this.length + 1];
      parent = 0; // ルートノードから下がっていく

      while (true) {
        current = this.getChild(parent); // 範囲チェック

        if (current >= this.length) {
          break;
        } // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択


        if (current + 2 < this.length && heap[current + 2] > heap[current]) {
          current += 2;
        } // 親ノードと比較して親の方が小さい場合は入れ替える


        if (heap[current] > heap[parent]) {
          swap = heap[parent];
          heap[parent] = heap[current];
          heap[current] = swap;
          swap = heap[parent + 1];
          heap[parent + 1] = heap[current + 1];
          heap[current + 1] = swap;
        } else {
          break;
        }

        parent = current;
      }

      return {
        index: index,
        value: value,
        length: this.length
      };
    };
    /* vim:set expandtab ts=2 sw=2 tw=80: */

    /**
     * @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.
     */

    /**
     * Raw Deflate 実装
     *
     * @constructor
     * @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.
     * @param {Object=} opt_params option parameters.
     *
     * typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に
     * 変換されます.
     * 別のオブジェクトになるため出力バッファを参照している変数などは
     * 更新する必要があります.
     */


    Zlib$1.RawDeflate = function (input, opt_params) {
      /** @type {Zlib.RawDeflate.CompressionType} */
      this.compressionType = Zlib$1.RawDeflate.CompressionType.DYNAMIC;
      /** @type {number} */

      this.lazy = 0;
      /** @type {!(Array.<number>|Uint32Array)} */

      this.freqsLitLen;
      /** @type {!(Array.<number>|Uint32Array)} */

      this.freqsDist;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.input = input instanceof Array ? new Uint8Array(input) : input;
      /** @type {!(Array.<number>|Uint8Array)} output output buffer. */

      this.output;
      /** @type {number} pos output buffer position. */

      this.op = 0; // option parameters

      if (opt_params) {
        if (opt_params['lazy']) {
          this.lazy = opt_params['lazy'];
        }

        if (typeof opt_params['compressionType'] === 'number') {
          this.compressionType = opt_params['compressionType'];
        }

        if (opt_params['outputBuffer']) {
          this.output = opt_params['outputBuffer'] instanceof Array ? new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];
        }

        if (typeof opt_params['outputIndex'] === 'number') {
          this.op = opt_params['outputIndex'];
        }
      }

      if (!this.output) {
        this.output = new Uint8Array(0x8000);
      }
    };
    /**
     * @enum {number}
     */


    Zlib$1.RawDeflate.CompressionType = {
      NONE: 0,
      FIXED: 1,
      DYNAMIC: 2,
      RESERVED: 3
    };
    /**
     * LZ77 の最小マッチ長
     * @const
     * @type {number}
     */

    Zlib$1.RawDeflate.Lz77MinLength = 3;
    /**
     * LZ77 の最大マッチ長
     * @const
     * @type {number}
     */

    Zlib$1.RawDeflate.Lz77MaxLength = 258;
    /**
     * LZ77 のウィンドウサイズ
     * @const
     * @type {number}
     */

    Zlib$1.RawDeflate.WindowSize = 0x8000;
    /**
     * 最長の符号長
     * @const
     * @type {number}
     */

    Zlib$1.RawDeflate.MaxCodeLength = 16;
    /**
     * ハフマン符号の最大数値
     * @const
     * @type {number}
     */

    Zlib$1.RawDeflate.HUFMAX = 286;
    /**
     * 固定ハフマン符号の符号化テーブル
     * @const
     * @type {Array.<Array.<number, number>>}
     */

    Zlib$1.RawDeflate.FixedHuffmanTable = function () {
      var table = [],
          i;

      for (i = 0; i < 288; i++) {
        switch (true) {
          case i <= 143:
            table.push([i + 0x030, 8]);
            break;

          case i <= 255:
            table.push([i - 144 + 0x190, 9]);
            break;

          case i <= 279:
            table.push([i - 256 + 0x000, 7]);
            break;

          case i <= 287:
            table.push([i - 280 + 0x0C0, 8]);
            break;

          default:
            throw 'invalid literal: ' + i;
        }
      }

      return table;
    }();
    /**
     * DEFLATE ブロックの作成
     * @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.
     */


    Zlib$1.RawDeflate.prototype.compress = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var blockArray;
      /** @type {number} */

      var position;
      /** @type {number} */

      var length;
      var input = this.input; // compression

      switch (this.compressionType) {
        case Zlib$1.RawDeflate.CompressionType.NONE:
          // each 65535-Byte (length header: 16-bit)
          for (position = 0, length = input.length; position < length;) {
            blockArray = input.subarray(position, position + 0xffff);
            position += blockArray.length;
            this.makeNocompressBlock(blockArray, position === length);
          }

          break;

        case Zlib$1.RawDeflate.CompressionType.FIXED:
          this.output = this.makeFixedHuffmanBlock(input, true);
          this.op = this.output.length;
          break;

        case Zlib$1.RawDeflate.CompressionType.DYNAMIC:
          this.output = this.makeDynamicHuffmanBlock(input, true);
          this.op = this.output.length;
          break;

        default:
          throw 'invalid compression type';
      }

      return this.output;
    };
    /**
     * 非圧縮ブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.
     */


    Zlib$1.RawDeflate.prototype.makeNocompressBlock = function (blockArray, isFinalBlock) {
      /** @type {number} */
      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {number} */

      var len;
      /** @type {number} */

      var nlen;
      var output = this.output;
      var op = this.op; // expand buffer

      {
        output = new Uint8Array(this.output.buffer);

        while (output.length <= op + blockArray.length + 5) {
          output = new Uint8Array(output.length << 1);
        }

        output.set(this.output);
      } // header

      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib$1.RawDeflate.CompressionType.NONE;
      output[op++] = bfinal | btype << 1; // length

      len = blockArray.length;
      nlen = ~len + 0x10000 & 0xffff;
      output[op++] = len & 0xff;
      output[op++] = len >>> 8 & 0xff;
      output[op++] = nlen & 0xff;
      output[op++] = nlen >>> 8 & 0xff; // copy buffer

      {
        output.set(blockArray, op);
        op += blockArray.length;
        output = output.subarray(0, op);
      }
      this.op = op;
      this.output = output;
      return output;
    };
    /**
     * 固定ハフマンブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.
     */


    Zlib$1.RawDeflate.prototype.makeFixedHuffmanBlock = function (blockArray, isFinalBlock) {
      /** @type {Zlib.BitStream} */
      var stream = new Zlib$1.BitStream(new Uint8Array(this.output.buffer), this.op);
      /** @type {number} */

      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {!(Array.<number>|Uint16Array)} */

      var data; // header

      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib$1.RawDeflate.CompressionType.FIXED;
      stream.writeBits(bfinal, 1, true);
      stream.writeBits(btype, 2, true);
      data = this.lz77(blockArray);
      this.fixedHuffman(data, stream);
      return stream.finish();
    };
    /**
     * 動的ハフマンブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.
     */


    Zlib$1.RawDeflate.prototype.makeDynamicHuffmanBlock = function (blockArray, isFinalBlock) {
      /** @type {Zlib.BitStream} */
      var stream = new Zlib$1.BitStream(new Uint8Array(this.output.buffer), this.op);
      /** @type {number} */

      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {!(Array.<number>|Uint16Array)} */

      var data;
      /** @type {number} */

      var hlit;
      /** @type {number} */

      var hdist;
      /** @type {number} */

      var hclen;
      /** @const @type {Array.<number>} */

      var hclenOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      /** @type {!(Array.<number>|Uint8Array)} */

      var litLenLengths;
      /** @type {!(Array.<number>|Uint16Array)} */

      var litLenCodes;
      /** @type {!(Array.<number>|Uint8Array)} */

      var distLengths;
      /** @type {!(Array.<number>|Uint16Array)} */

      var distCodes;
      /** @type {{
       *   codes: !(Array.<number>|Uint32Array),
       *   freqs: !(Array.<number>|Uint8Array)
       * }} */

      var treeSymbols;
      /** @type {!(Array.<number>|Uint8Array)} */

      var treeLengths;
      /** @type {Array} */

      var transLengths = new Array(19);
      /** @type {!(Array.<number>|Uint16Array)} */

      var treeCodes;
      /** @type {number} */

      var code;
      /** @type {number} */

      var bitlen;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il; // header

      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib$1.RawDeflate.CompressionType.DYNAMIC;
      stream.writeBits(bfinal, 1, true);
      stream.writeBits(btype, 2, true);
      data = this.lz77(blockArray); // リテラル・長さ, 距離のハフマン符号と符号長の算出

      litLenLengths = this.getLengths_(this.freqsLitLen, 15);
      litLenCodes = this.getCodesFromLengths_(litLenLengths);
      distLengths = this.getLengths_(this.freqsDist, 7);
      distCodes = this.getCodesFromLengths_(distLengths); // HLIT, HDIST の決定

      for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}

      for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {} // HCLEN


      treeSymbols = this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
      treeLengths = this.getLengths_(treeSymbols.freqs, 7);

      for (i = 0; i < 19; i++) {
        transLengths[i] = treeLengths[hclenOrder[i]];
      }

      for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}

      treeCodes = this.getCodesFromLengths_(treeLengths); // 出力

      stream.writeBits(hlit - 257, 5, true);
      stream.writeBits(hdist - 1, 5, true);
      stream.writeBits(hclen - 4, 4, true);

      for (i = 0; i < hclen; i++) {
        stream.writeBits(transLengths[i], 3, true);
      } // ツリーの出力


      for (i = 0, il = treeSymbols.codes.length; i < il; i++) {
        code = treeSymbols.codes[i];
        stream.writeBits(treeCodes[code], treeLengths[code], true); // extra bits

        if (code >= 16) {
          i++;

          switch (code) {
            case 16:
              bitlen = 2;
              break;

            case 17:
              bitlen = 3;
              break;

            case 18:
              bitlen = 7;
              break;

            default:
              throw 'invalid code: ' + code;
          }

          stream.writeBits(treeSymbols.codes[i], bitlen, true);
        }
      }

      this.dynamicHuffman(data, [litLenCodes, litLenLengths], [distCodes, distLengths], stream);
      return stream.finish();
    };
    /**
     * 動的ハフマン符号化(カスタムハフマンテーブル)
     * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
     * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
     * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
     */


    Zlib$1.RawDeflate.prototype.dynamicHuffman = function (dataArray, litLen, dist, stream) {
      /** @type {number} */
      var index;
      /** @type {number} */

      var length;
      /** @type {number} */

      var literal;
      /** @type {number} */

      var code;
      /** @type {number} */

      var litLenCodes;
      /** @type {number} */

      var litLenLengths;
      /** @type {number} */

      var distCodes;
      /** @type {number} */

      var distLengths;
      litLenCodes = litLen[0];
      litLenLengths = litLen[1];
      distCodes = dist[0];
      distLengths = dist[1]; // 符号を BitStream に書き込んでいく

      for (index = 0, length = dataArray.length; index < length; ++index) {
        literal = dataArray[index]; // literal or length

        stream.writeBits(litLenCodes[literal], litLenLengths[literal], true); // 長さ・距離符号

        if (literal > 256) {
          // length extra
          stream.writeBits(dataArray[++index], dataArray[++index], true); // distance

          code = dataArray[++index];
          stream.writeBits(distCodes[code], distLengths[code], true); // distance extra

          stream.writeBits(dataArray[++index], dataArray[++index], true); // 終端
        } else if (literal === 256) {
          break;
        }
      }

      return stream;
    };
    /**
     * 固定ハフマン符号化
     * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
     * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
     * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
     */


    Zlib$1.RawDeflate.prototype.fixedHuffman = function (dataArray, stream) {
      /** @type {number} */
      var index;
      /** @type {number} */

      var length;
      /** @type {number} */

      var literal; // 符号を BitStream に書き込んでいく

      for (index = 0, length = dataArray.length; index < length; index++) {
        literal = dataArray[index]; // 符号の書き込み

        Zlib$1.BitStream.prototype.writeBits.apply(stream, Zlib$1.RawDeflate.FixedHuffmanTable[literal]); // 長さ・距離符号

        if (literal > 0x100) {
          // length extra
          stream.writeBits(dataArray[++index], dataArray[++index], true); // distance

          stream.writeBits(dataArray[++index], 5); // distance extra

          stream.writeBits(dataArray[++index], dataArray[++index], true); // 終端
        } else if (literal === 0x100) {
          break;
        }
      }

      return stream;
    };
    /**
     * マッチ情報
     * @param {!number} length マッチした長さ.
     * @param {!number} backwardDistance マッチ位置との距離.
     * @constructor
     */


    Zlib$1.RawDeflate.Lz77Match = function (length, backwardDistance) {
      /** @type {number} match length. */
      this.length = length;
      /** @type {number} backward distance. */

      this.backwardDistance = backwardDistance;
    };
    /**
     * 長さ符号テーブル.
     * [コード, 拡張ビット, 拡張ビット長] の配列となっている.
     * @const
     * @type {!(Array.<number>|Uint32Array)}
     */


    Zlib$1.RawDeflate.Lz77Match.LengthCodeTable = function (table) {
      return new Uint32Array(table);
    }(function () {
      /** @type {!Array} */
      var table = [];
      /** @type {number} */

      var i;
      /** @type {!Array.<number>} */

      var c;

      for (i = 3; i <= 258; i++) {
        c = code(i);
        table[i] = c[2] << 24 | c[1] << 16 | c[0];
      }
      /**
       * @param {number} length lz77 length.
       * @return {!Array.<number>} lz77 codes.
       */


      function code(length) {
        switch (true) {
          case length === 3:
            return [257, length - 3, 0];

          case length === 4:
            return [258, length - 4, 0];

          case length === 5:
            return [259, length - 5, 0];

          case length === 6:
            return [260, length - 6, 0];

          case length === 7:
            return [261, length - 7, 0];

          case length === 8:
            return [262, length - 8, 0];

          case length === 9:
            return [263, length - 9, 0];

          case length === 10:
            return [264, length - 10, 0];

          case length <= 12:
            return [265, length - 11, 1];

          case length <= 14:
            return [266, length - 13, 1];

          case length <= 16:
            return [267, length - 15, 1];

          case length <= 18:
            return [268, length - 17, 1];

          case length <= 22:
            return [269, length - 19, 2];

          case length <= 26:
            return [270, length - 23, 2];

          case length <= 30:
            return [271, length - 27, 2];

          case length <= 34:
            return [272, length - 31, 2];

          case length <= 42:
            return [273, length - 35, 3];

          case length <= 50:
            return [274, length - 43, 3];

          case length <= 58:
            return [275, length - 51, 3];

          case length <= 66:
            return [276, length - 59, 3];

          case length <= 82:
            return [277, length - 67, 4];

          case length <= 98:
            return [278, length - 83, 4];

          case length <= 114:
            return [279, length - 99, 4];

          case length <= 130:
            return [280, length - 115, 4];

          case length <= 162:
            return [281, length - 131, 5];

          case length <= 194:
            return [282, length - 163, 5];

          case length <= 226:
            return [283, length - 195, 5];

          case length <= 257:
            return [284, length - 227, 5];

          case length === 258:
            return [285, length - 258, 0];

          default:
            throw 'invalid length: ' + length;
        }
      }

      return table;
    }());
    /**
     * 距離符号テーブル
     * @param {!number} dist 距離.
     * @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.
     * @private
     */


    Zlib$1.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function (dist) {
      /** @type {!Array.<number>} distance code table. */
      var r;

      switch (true) {
        case dist === 1:
          r = [0, dist - 1, 0];
          break;

        case dist === 2:
          r = [1, dist - 2, 0];
          break;

        case dist === 3:
          r = [2, dist - 3, 0];
          break;

        case dist === 4:
          r = [3, dist - 4, 0];
          break;

        case dist <= 6:
          r = [4, dist - 5, 1];
          break;

        case dist <= 8:
          r = [5, dist - 7, 1];
          break;

        case dist <= 12:
          r = [6, dist - 9, 2];
          break;

        case dist <= 16:
          r = [7, dist - 13, 2];
          break;

        case dist <= 24:
          r = [8, dist - 17, 3];
          break;

        case dist <= 32:
          r = [9, dist - 25, 3];
          break;

        case dist <= 48:
          r = [10, dist - 33, 4];
          break;

        case dist <= 64:
          r = [11, dist - 49, 4];
          break;

        case dist <= 96:
          r = [12, dist - 65, 5];
          break;

        case dist <= 128:
          r = [13, dist - 97, 5];
          break;

        case dist <= 192:
          r = [14, dist - 129, 6];
          break;

        case dist <= 256:
          r = [15, dist - 193, 6];
          break;

        case dist <= 384:
          r = [16, dist - 257, 7];
          break;

        case dist <= 512:
          r = [17, dist - 385, 7];
          break;

        case dist <= 768:
          r = [18, dist - 513, 8];
          break;

        case dist <= 1024:
          r = [19, dist - 769, 8];
          break;

        case dist <= 1536:
          r = [20, dist - 1025, 9];
          break;

        case dist <= 2048:
          r = [21, dist - 1537, 9];
          break;

        case dist <= 3072:
          r = [22, dist - 2049, 10];
          break;

        case dist <= 4096:
          r = [23, dist - 3073, 10];
          break;

        case dist <= 6144:
          r = [24, dist - 4097, 11];
          break;

        case dist <= 8192:
          r = [25, dist - 6145, 11];
          break;

        case dist <= 12288:
          r = [26, dist - 8193, 12];
          break;

        case dist <= 16384:
          r = [27, dist - 12289, 12];
          break;

        case dist <= 24576:
          r = [28, dist - 16385, 13];
          break;

        case dist <= 32768:
          r = [29, dist - 24577, 13];
          break;

        default:
          throw 'invalid distance';
      }

      return r;
    };
    /**
     * マッチ情報を LZ77 符号化配列で返す.
     * なお、ここでは以下の内部仕様で符号化している
     * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]
     * @return {!Array.<number>} LZ77 符号化 byte array.
     */


    Zlib$1.RawDeflate.Lz77Match.prototype.toLz77Array = function () {
      /** @type {number} */
      var length = this.length;
      /** @type {number} */

      var dist = this.backwardDistance;
      /** @type {Array} */

      var codeArray = [];
      /** @type {number} */

      var pos = 0;
      /** @type {!Array.<number>} */

      var code; // length

      code = Zlib$1.RawDeflate.Lz77Match.LengthCodeTable[length];
      codeArray[pos++] = code & 0xffff;
      codeArray[pos++] = code >> 16 & 0xff;
      codeArray[pos++] = code >> 24; // distance

      code = this.getDistanceCode_(dist);
      codeArray[pos++] = code[0];
      codeArray[pos++] = code[1];
      codeArray[pos++] = code[2];
      return codeArray;
    };
    /**
     * LZ77 実装
     * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.
     * @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.
     */


    Zlib$1.RawDeflate.prototype.lz77 = function (dataArray) {
      /** @type {number} input position */
      var position;
      /** @type {number} input length */

      var length;
      /** @type {number} loop counter */

      var i;
      /** @type {number} loop limiter */

      var il;
      /** @type {number} chained-hash-table key */

      var matchKey;
      /** @type {Object.<number, Array.<number>>} chained-hash-table */

      var table = {};
      /** @const @type {number} */

      var windowSize = Zlib$1.RawDeflate.WindowSize;
      /** @type {Array.<number>} match list */

      var matchList;
      /** @type {Zlib.RawDeflate.Lz77Match} longest match */

      var longestMatch;
      /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */

      var prevMatch;
      /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */

      var lz77buf = new Uint16Array(dataArray.length * 2);
      /** @type {number} lz77 output buffer pointer */

      var pos = 0;
      /** @type {number} lz77 skip length */

      var skipLength = 0;
      /** @type {!(Array.<number>|Uint32Array)} */

      var freqsLitLen = new Uint32Array(286);
      /** @type {!(Array.<number>|Uint32Array)} */

      var freqsDist = new Uint32Array(30);
      /** @type {number} */

      var lazy = this.lazy;
      /** @type {*} temporary variable */

      var tmp;
      freqsLitLen[256] = 1; // EOB の最低出現回数は 1

      /**
       * マッチデータの書き込み
       * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.
       * @param {!number} offset スキップ開始位置(相対指定).
       * @private
       */

      function writeMatch(match, offset) {
        /** @type {Array.<number>} */
        var lz77Array = match.toLz77Array();
        /** @type {number} */

        var i;
        /** @type {number} */

        var il;

        for (i = 0, il = lz77Array.length; i < il; ++i) {
          lz77buf[pos++] = lz77Array[i];
        }

        freqsLitLen[lz77Array[0]]++;
        freqsDist[lz77Array[3]]++;
        skipLength = match.length + offset - 1;
        prevMatch = null;
      } // LZ77 符号化


      for (position = 0, length = dataArray.length; position < length; ++position) {
        // ハッシュキーの作成
        for (matchKey = 0, i = 0, il = Zlib$1.RawDeflate.Lz77MinLength; i < il; ++i) {
          if (position + i === length) {
            break;
          }

          matchKey = matchKey << 8 | dataArray[position + i];
        } // テーブルが未定義だったら作成する


        if (table[matchKey] === void 0) {
          table[matchKey] = [];
        }

        matchList = table[matchKey]; // skip

        if (skipLength-- > 0) {
          matchList.push(position);
          continue;
        } // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)


        while (matchList.length > 0 && position - matchList[0] > windowSize) {
          matchList.shift();
        } // データ末尾でマッチしようがない場合はそのまま流しこむ


        if (position + Zlib$1.RawDeflate.Lz77MinLength >= length) {
          if (prevMatch) {
            writeMatch(prevMatch, -1);
          }

          for (i = 0, il = length - position; i < il; ++i) {
            tmp = dataArray[position + i];
            lz77buf[pos++] = tmp;
            ++freqsLitLen[tmp];
          }

          break;
        } // マッチ候補から最長のものを探す


        if (matchList.length > 0) {
          longestMatch = this.searchLongestMatch_(dataArray, position, matchList);

          if (prevMatch) {
            // 現在のマッチの方が前回のマッチよりも長い
            if (prevMatch.length < longestMatch.length) {
              // write previous literal
              tmp = dataArray[position - 1];
              lz77buf[pos++] = tmp;
              ++freqsLitLen[tmp]; // write current match

              writeMatch(longestMatch, 0);
            } else {
              // write previous match
              writeMatch(prevMatch, -1);
            }
          } else if (longestMatch.length < lazy) {
            prevMatch = longestMatch;
          } else {
            writeMatch(longestMatch, 0);
          } // 前回マッチしていて今回マッチがなかったら前回のを採用

        } else if (prevMatch) {
          writeMatch(prevMatch, -1);
        } else {
          tmp = dataArray[position];
          lz77buf[pos++] = tmp;
          ++freqsLitLen[tmp];
        }

        matchList.push(position); // マッチテーブルに現在の位置を保存
      } // 終端処理


      lz77buf[pos++] = 256;
      freqsLitLen[256]++;
      this.freqsLitLen = freqsLitLen;
      this.freqsDist = freqsDist;
      return (
        /** @type {!(Uint16Array|Array.<number>)} */
        lz77buf.subarray(0, pos)
      );
    };
    /**
     * マッチした候補の中から最長一致を探す
     * @param {!Object} data plain data byte array.
     * @param {!number} position plain data byte array position.
     * @param {!Array.<number>} matchList 候補となる位置の配列.
     * @return {!Zlib.RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.
     * @private
     */


    Zlib$1.RawDeflate.prototype.searchLongestMatch_ = function (data, position, matchList) {
      var match,
          currentMatch,
          matchMax = 0,
          matchLength,
          i,
          j,
          l,
          dl = data.length; // 候補を後ろから 1 つずつ絞り込んでゆく

      permatch: for (i = 0, l = matchList.length; i < l; i++) {
        match = matchList[l - i - 1];
        matchLength = Zlib$1.RawDeflate.Lz77MinLength; // 前回までの最長一致を末尾から一致検索する

        if (matchMax > Zlib$1.RawDeflate.Lz77MinLength) {
          for (j = matchMax; j > Zlib$1.RawDeflate.Lz77MinLength; j--) {
            if (data[match + j - 1] !== data[position + j - 1]) {
              continue permatch;
            }
          }

          matchLength = matchMax;
        } // 最長一致探索


        while (matchLength < Zlib$1.RawDeflate.Lz77MaxLength && position + matchLength < dl && data[match + matchLength] === data[position + matchLength]) {
          ++matchLength;
        } // マッチ長が同じ場合は後方を優先


        if (matchLength > matchMax) {
          currentMatch = match;
          matchMax = matchLength;
        } // 最長が確定したら後の処理は省略


        if (matchLength === Zlib$1.RawDeflate.Lz77MaxLength) {
          break;
        }
      }

      return new Zlib$1.RawDeflate.Lz77Match(matchMax, position - currentMatch);
    };
    /**
     * Tree-Transmit Symbols の算出
     * reference: PuTTY Deflate implementation
     * @param {number} hlit HLIT.
     * @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.
     * @param {number} hdist HDIST.
     * @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.
     * @return {{
     *   codes: !(Array.<number>|Uint32Array),
     *   freqs: !(Array.<number>|Uint8Array)
     * }} Tree-Transmit Symbols.
     */


    Zlib$1.RawDeflate.prototype.getTreeSymbols_ = function (hlit, litlenLengths, hdist, distLengths) {
      var src = new Uint32Array(hlit + hdist),
          i,
          j,
          runLength,
          l,
          result = new Uint32Array(286 + 30),
          nResult,
          rpt,
          freqs = new Uint8Array(19);
      j = 0;

      for (i = 0; i < hlit; i++) {
        src[j++] = litlenLengths[i];
      }

      for (i = 0; i < hdist; i++) {
        src[j++] = distLengths[i];
      } // 符号化


      nResult = 0;

      for (i = 0, l = src.length; i < l; i += j) {
        // Run Length Encoding
        for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}

        runLength = j;

        if (src[i] === 0) {
          // 0 の繰り返しが 3 回未満ならばそのまま
          if (runLength < 3) {
            while (runLength-- > 0) {
              result[nResult++] = 0;
              freqs[0]++;
            }
          } else {
            while (runLength > 0) {
              // 繰り返しは最大 138 までなので切り詰める
              rpt = runLength < 138 ? runLength : 138;

              if (rpt > runLength - 3 && rpt < runLength) {
                rpt = runLength - 3;
              } // 3-10 回 -> 17


              if (rpt <= 10) {
                result[nResult++] = 17;
                result[nResult++] = rpt - 3;
                freqs[17]++; // 11-138 回 -> 18
              } else {
                result[nResult++] = 18;
                result[nResult++] = rpt - 11;
                freqs[18]++;
              }

              runLength -= rpt;
            }
          }
        } else {
          result[nResult++] = src[i];
          freqs[src[i]]++;
          runLength--; // 繰り返し回数が3回未満ならばランレングス符号は要らない

          if (runLength < 3) {
            while (runLength-- > 0) {
              result[nResult++] = src[i];
              freqs[src[i]]++;
            } // 3 回以上ならばランレングス符号化

          } else {
            while (runLength > 0) {
              // runLengthを 3-6 で分割
              rpt = runLength < 6 ? runLength : 6;

              if (rpt > runLength - 3 && rpt < runLength) {
                rpt = runLength - 3;
              }

              result[nResult++] = 16;
              result[nResult++] = rpt - 3;
              freqs[16]++;
              runLength -= rpt;
            }
          }
        }
      }

      return {
        codes: result.subarray(0, nResult),
        freqs: freqs
      };
    };
    /**
     * ハフマン符号の長さを取得する
     * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.
     * @param {number} limit 符号長の制限.
     * @return {!(Array.<number>|Uint8Array)} 符号長配列.
     * @private
     */


    Zlib$1.RawDeflate.prototype.getLengths_ = function (freqs, limit) {
      /** @type {number} */
      var nSymbols = freqs.length;
      /** @type {Zlib.Heap} */

      var heap = new Zlib$1.Heap(2 * Zlib$1.RawDeflate.HUFMAX);
      /** @type {!(Array.<number>|Uint8Array)} */

      var length = new Uint8Array(nSymbols);
      /** @type {Array} */

      var nodes;
      /** @type {!(Array.<number>|Uint32Array)} */

      var values;
      /** @type {!(Array.<number>|Uint8Array)} */

      var codeLength;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il; // ヒープの構築

      for (i = 0; i < nSymbols; ++i) {
        if (freqs[i] > 0) {
          heap.push(i, freqs[i]);
        }
      }

      nodes = new Array(heap.length / 2);
      values = new Uint32Array(heap.length / 2); // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了

      if (nodes.length === 1) {
        length[heap.pop().index] = 1;
        return length;
      } // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定


      for (i = 0, il = heap.length / 2; i < il; ++i) {
        nodes[i] = heap.pop();
        values[i] = nodes[i].value;
      }

      codeLength = this.reversePackageMerge_(values, values.length, limit);

      for (i = 0, il = nodes.length; i < il; ++i) {
        length[nodes[i].index] = codeLength[i];
      }

      return length;
    };
    /**
     * Reverse Package Merge Algorithm.
     * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.
     * @param {number} symbols number of symbols.
     * @param {number} limit code length limit.
     * @return {!(Array.<number>|Uint8Array)} code lengths.
     */


    Zlib$1.RawDeflate.prototype.reversePackageMerge_ = function (freqs, symbols, limit) {
      /** @type {!(Array.<number>|Uint16Array)} */
      var minimumCost = new Uint16Array(limit);
      /** @type {!(Array.<number>|Uint8Array)} */

      var flag = new Uint8Array(limit);
      /** @type {!(Array.<number>|Uint8Array)} */

      var codeLength = new Uint8Array(symbols);
      /** @type {Array} */

      var value = new Array(limit);
      /** @type {Array} */

      var type = new Array(limit);
      /** @type {Array.<number>} */

      var currentPosition = new Array(limit);
      /** @type {number} */

      var excess = (1 << limit) - symbols;
      /** @type {number} */

      var half = 1 << limit - 1;
      /** @type {number} */

      var i;
      /** @type {number} */

      var j;
      /** @type {number} */

      var t;
      /** @type {number} */

      var weight;
      /** @type {number} */

      var next;
      /**
       * @param {number} j
       */

      function takePackage(j) {
        /** @type {number} */
        var x = type[j][currentPosition[j]];

        if (x === symbols) {
          takePackage(j + 1);
          takePackage(j + 1);
        } else {
          --codeLength[x];
        }

        ++currentPosition[j];
      }

      minimumCost[limit - 1] = symbols;

      for (j = 0; j < limit; ++j) {
        if (excess < half) {
          flag[j] = 0;
        } else {
          flag[j] = 1;
          excess -= half;
        }

        excess <<= 1;
        minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols;
      }

      minimumCost[0] = flag[0];
      value[0] = new Array(minimumCost[0]);
      type[0] = new Array(minimumCost[0]);

      for (j = 1; j < limit; ++j) {
        if (minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {
          minimumCost[j] = 2 * minimumCost[j - 1] + flag[j];
        }

        value[j] = new Array(minimumCost[j]);
        type[j] = new Array(minimumCost[j]);
      }

      for (i = 0; i < symbols; ++i) {
        codeLength[i] = limit;
      }

      for (t = 0; t < minimumCost[limit - 1]; ++t) {
        value[limit - 1][t] = freqs[t];
        type[limit - 1][t] = t;
      }

      for (i = 0; i < limit; ++i) {
        currentPosition[i] = 0;
      }

      if (flag[limit - 1] === 1) {
        --codeLength[0];
        ++currentPosition[limit - 1];
      }

      for (j = limit - 2; j >= 0; --j) {
        i = 0;
        weight = 0;
        next = currentPosition[j + 1];

        for (t = 0; t < minimumCost[j]; t++) {
          weight = value[j + 1][next] + value[j + 1][next + 1];

          if (weight > freqs[i]) {
            value[j][t] = weight;
            type[j][t] = symbols;
            next += 2;
          } else {
            value[j][t] = freqs[i];
            type[j][t] = i;
            ++i;
          }
        }

        currentPosition[j] = 0;

        if (flag[j] === 1) {
          takePackage(j);
        }
      }

      return codeLength;
    };
    /**
     * 符号長配列からハフマン符号を取得する
     * reference: PuTTY Deflate implementation
     * @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.
     * @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.
     * @private
     */


    Zlib$1.RawDeflate.prototype.getCodesFromLengths_ = function (lengths) {
      var codes = new Uint16Array(lengths.length),
          count = [],
          startCode = [],
          code = 0,
          i,
          il,
          j,
          m; // Count the codes of each length.

      for (i = 0, il = lengths.length; i < il; i++) {
        count[lengths[i]] = (count[lengths[i]] | 0) + 1;
      } // Determine the starting code for each length block.


      for (i = 1, il = Zlib$1.RawDeflate.MaxCodeLength; i <= il; i++) {
        startCode[i] = code;
        code += count[i] | 0;
        code <<= 1;
      } // Determine the code for each symbol. Mirrored, of course.


      for (i = 0, il = lengths.length; i < il; i++) {
        code = startCode[lengths[i]];
        startCode[lengths[i]] += 1;
        codes[i] = 0;

        for (j = 0, m = lengths[i]; j < m; j++) {
          codes[i] = codes[i] << 1 | code & 1;
          code >>>= 1;
        }
      }

      return codes;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {Object=} opt_params options.
     * @constructor
     */


    Zlib$1.Unzip = function (input, opt_params) {
      opt_params = opt_params || {};
      /** @type {!(Array.<number>|Uint8Array)} */

      this.input = input instanceof Array ? new Uint8Array(input) : input;
      /** @type {number} */

      this.ip = 0;
      /** @type {number} */

      this.eocdrOffset;
      /** @type {number} */

      this.numberOfThisDisk;
      /** @type {number} */

      this.startDisk;
      /** @type {number} */

      this.totalEntriesThisDisk;
      /** @type {number} */

      this.totalEntries;
      /** @type {number} */

      this.centralDirectorySize;
      /** @type {number} */

      this.centralDirectoryOffset;
      /** @type {number} */

      this.commentLength;
      /** @type {(Array.<number>|Uint8Array)} */

      this.comment;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      this.fileHeaderList;
      /** @type {Object.<string, number>} */

      this.filenameToIndex;
      /** @type {boolean} */

      this.verify = opt_params['verify'] || false;
      /** @type {(Array.<number>|Uint8Array)} */

      this.password = opt_params['password'];
    };

    Zlib$1.Unzip.CompressionMethod = Zlib$1.Zip.CompressionMethod;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$1.Unzip.FileHeaderSignature = Zlib$1.Zip.FileHeaderSignature;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$1.Unzip.LocalFileHeaderSignature = Zlib$1.Zip.LocalFileHeaderSignature;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib$1.Unzip.CentralDirectorySignature = Zlib$1.Zip.CentralDirectorySignature;
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {number} ip input position.
     * @constructor
     */

    Zlib$1.Unzip.FileHeader = function (input, ip) {
      /** @type {!(Array.<number>|Uint8Array)} */
      this.input = input;
      /** @type {number} */

      this.offset = ip;
      /** @type {number} */

      this.length;
      /** @type {number} */

      this.version;
      /** @type {number} */

      this.os;
      /** @type {number} */

      this.needVersion;
      /** @type {number} */

      this.flags;
      /** @type {number} */

      this.compression;
      /** @type {number} */

      this.time;
      /** @type {number} */

      this.date;
      /** @type {number} */

      this.crc32;
      /** @type {number} */

      this.compressedSize;
      /** @type {number} */

      this.plainSize;
      /** @type {number} */

      this.fileNameLength;
      /** @type {number} */

      this.extraFieldLength;
      /** @type {number} */

      this.fileCommentLength;
      /** @type {number} */

      this.diskNumberStart;
      /** @type {number} */

      this.internalFileAttributes;
      /** @type {number} */

      this.externalFileAttributes;
      /** @type {number} */

      this.relativeOffset;
      /** @type {string} */

      this.filename;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.extraField;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.comment;
    };

    Zlib$1.Unzip.FileHeader.prototype.parse = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip = this.offset; // central file header signature

      if (input[ip++] !== Zlib$1.Unzip.FileHeaderSignature[0] || input[ip++] !== Zlib$1.Unzip.FileHeaderSignature[1] || input[ip++] !== Zlib$1.Unzip.FileHeaderSignature[2] || input[ip++] !== Zlib$1.Unzip.FileHeaderSignature[3]) {
        throw new Error('invalid file header signature');
      } // version made by


      this.version = input[ip++];
      this.os = input[ip++]; // version needed to extract

      this.needVersion = input[ip++] | input[ip++] << 8; // general purpose bit flag

      this.flags = input[ip++] | input[ip++] << 8; // compression method

      this.compression = input[ip++] | input[ip++] << 8; // last mod file time

      this.time = input[ip++] | input[ip++] << 8; //last mod file date

      this.date = input[ip++] | input[ip++] << 8; // crc-32

      this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // compressed size

      this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // uncompressed size

      this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name length

      this.fileNameLength = input[ip++] | input[ip++] << 8; // extra field length

      this.extraFieldLength = input[ip++] | input[ip++] << 8; // file comment length

      this.fileCommentLength = input[ip++] | input[ip++] << 8; // disk number start

      this.diskNumberStart = input[ip++] | input[ip++] << 8; // internal file attributes

      this.internalFileAttributes = input[ip++] | input[ip++] << 8; // external file attributes

      this.externalFileAttributes = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24; // relative offset of local header

      this.relativeOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name

      this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength)); // extra field

      this.extraField = input.subarray(ip, ip += this.extraFieldLength); // file comment

      this.comment = input.subarray(ip, ip + this.fileCommentLength);
      this.length = ip - this.offset;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {number} ip input position.
     * @constructor
     */


    Zlib$1.Unzip.LocalFileHeader = function (input, ip) {
      /** @type {!(Array.<number>|Uint8Array)} */
      this.input = input;
      /** @type {number} */

      this.offset = ip;
      /** @type {number} */

      this.length;
      /** @type {number} */

      this.needVersion;
      /** @type {number} */

      this.flags;
      /** @type {number} */

      this.compression;
      /** @type {number} */

      this.time;
      /** @type {number} */

      this.date;
      /** @type {number} */

      this.crc32;
      /** @type {number} */

      this.compressedSize;
      /** @type {number} */

      this.plainSize;
      /** @type {number} */

      this.fileNameLength;
      /** @type {number} */

      this.extraFieldLength;
      /** @type {string} */

      this.filename;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.extraField;
    };

    Zlib$1.Unzip.LocalFileHeader.Flags = Zlib$1.Zip.Flags;

    Zlib$1.Unzip.LocalFileHeader.prototype.parse = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip = this.offset; // local file header signature

      if (input[ip++] !== Zlib$1.Unzip.LocalFileHeaderSignature[0] || input[ip++] !== Zlib$1.Unzip.LocalFileHeaderSignature[1] || input[ip++] !== Zlib$1.Unzip.LocalFileHeaderSignature[2] || input[ip++] !== Zlib$1.Unzip.LocalFileHeaderSignature[3]) {
        throw new Error('invalid local file header signature');
      } // version needed to extract


      this.needVersion = input[ip++] | input[ip++] << 8; // general purpose bit flag

      this.flags = input[ip++] | input[ip++] << 8; // compression method

      this.compression = input[ip++] | input[ip++] << 8; // last mod file time

      this.time = input[ip++] | input[ip++] << 8; //last mod file date

      this.date = input[ip++] | input[ip++] << 8; // crc-32

      this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // compressed size

      this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // uncompressed size

      this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name length

      this.fileNameLength = input[ip++] | input[ip++] << 8; // extra field length

      this.extraFieldLength = input[ip++] | input[ip++] << 8; // file name

      this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength)); // extra field

      this.extraField = input.subarray(ip, ip += this.extraFieldLength);
      this.length = ip - this.offset;
    };

    Zlib$1.Unzip.prototype.searchEndOfCentralDirectoryRecord = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip;

      for (ip = input.length - 12; ip > 0; --ip) {
        if (input[ip] === Zlib$1.Unzip.CentralDirectorySignature[0] && input[ip + 1] === Zlib$1.Unzip.CentralDirectorySignature[1] && input[ip + 2] === Zlib$1.Unzip.CentralDirectorySignature[2] && input[ip + 3] === Zlib$1.Unzip.CentralDirectorySignature[3]) {
          this.eocdrOffset = ip;
          return;
        }
      }

      throw new Error('End of Central Directory Record not found');
    };

    Zlib$1.Unzip.prototype.parseEndOfCentralDirectoryRecord = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip;

      if (!this.eocdrOffset) {
        this.searchEndOfCentralDirectoryRecord();
      }

      ip = this.eocdrOffset; // signature

      if (input[ip++] !== Zlib$1.Unzip.CentralDirectorySignature[0] || input[ip++] !== Zlib$1.Unzip.CentralDirectorySignature[1] || input[ip++] !== Zlib$1.Unzip.CentralDirectorySignature[2] || input[ip++] !== Zlib$1.Unzip.CentralDirectorySignature[3]) {
        throw new Error('invalid signature');
      } // number of this disk


      this.numberOfThisDisk = input[ip++] | input[ip++] << 8; // number of the disk with the start of the central directory

      this.startDisk = input[ip++] | input[ip++] << 8; // total number of entries in the central directory on this disk

      this.totalEntriesThisDisk = input[ip++] | input[ip++] << 8; // total number of entries in the central directory

      this.totalEntries = input[ip++] | input[ip++] << 8; // size of the central directory

      this.centralDirectorySize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // offset of start of central directory with respect to the starting disk number

      this.centralDirectoryOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // .ZIP file comment length

      this.commentLength = input[ip++] | input[ip++] << 8; // .ZIP file comment

      this.comment = input.subarray(ip, ip + this.commentLength);
    };

    Zlib$1.Unzip.prototype.parseFileHeader = function () {
      /** @type {Array.<Zlib.Unzip.FileHeader>} */
      var filelist = [];
      /** @type {Object.<string, number>} */

      var filetable = {};
      /** @type {number} */

      var ip;
      /** @type {Zlib.Unzip.FileHeader} */

      var fileHeader;
      /*: @type {number} */

      var i;
      /*: @type {number} */

      var il;

      if (this.fileHeaderList) {
        return;
      }

      if (this.centralDirectoryOffset === void 0) {
        this.parseEndOfCentralDirectoryRecord();
      }

      ip = this.centralDirectoryOffset;

      for (i = 0, il = this.totalEntries; i < il; ++i) {
        fileHeader = new Zlib$1.Unzip.FileHeader(this.input, ip);
        fileHeader.parse();
        ip += fileHeader.length;
        filelist[i] = fileHeader;
        filetable[fileHeader.filename] = i;
      }

      if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {
        throw new Error('invalid file header size');
      }

      this.fileHeaderList = filelist;
      this.filenameToIndex = filetable;
    };
    /**
     * @param {number} index file header index.
     * @param {Object=} opt_params
     * @return {!(Array.<number>|Uint8Array)} file data.
     */


    Zlib$1.Unzip.prototype.getFileData = function (index, opt_params) {
      opt_params = opt_params || {};
      /** @type {!(Array.<number>|Uint8Array)} */

      var input = this.input;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      var fileHeaderList = this.fileHeaderList;
      /** @type {Zlib.Unzip.LocalFileHeader} */

      var localFileHeader;
      /** @type {number} */

      var offset;
      /** @type {number} */

      var length;
      /** @type {!(Array.<number>|Uint8Array)} */

      var buffer;
      /** @type {number} */

      var crc32;
      /** @type {Array.<number>|Uint32Array|Object} */

      var key;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;

      if (!fileHeaderList) {
        this.parseFileHeader();
      }

      if (fileHeaderList[index] === void 0) {
        throw new Error('wrong index');
      }

      offset = fileHeaderList[index].relativeOffset;
      localFileHeader = new Zlib$1.Unzip.LocalFileHeader(this.input, offset);
      localFileHeader.parse();
      offset += localFileHeader.length;
      length = localFileHeader.compressedSize; // decryption

      if ((localFileHeader.flags & Zlib$1.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {
        if (!(opt_params['password'] || this.password)) {
          throw new Error('please set password');
        }

        key = this.createDecryptionKey(opt_params['password'] || this.password); // encryption header

        for (i = offset, il = offset + 12; i < il; ++i) {
          this.decode(key, input[i]);
        }

        offset += 12;
        length -= 12; // decryption

        for (i = offset, il = offset + length; i < il; ++i) {
          input[i] = this.decode(key, input[i]);
        }
      }

      switch (localFileHeader.compression) {
        case Zlib$1.Unzip.CompressionMethod.STORE:
          buffer = this.input.subarray(offset, offset + length);
          break;

        case Zlib$1.Unzip.CompressionMethod.DEFLATE:
          buffer = new Zlib$1.RawInflate(this.input, {
            'index': offset,
            'bufferSize': localFileHeader.plainSize
          }).decompress();
          break;

        default:
          throw new Error('unknown compression type');
      }

      if (this.verify) {
        crc32 = Zlib$1.CRC32.calc(buffer);

        if (localFileHeader.crc32 !== crc32) {
          throw new Error('wrong crc: file=0x' + localFileHeader.crc32.toString(16) + ', data=0x' + crc32.toString(16));
        }
      }

      return buffer;
    };
    /**
     * @return {Array.<string>}
     */


    Zlib$1.Unzip.prototype.getFilenames = function () {
      /** @type {Array.<string>} */
      var filenameList = [];
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      var fileHeaderList;

      if (!this.fileHeaderList) {
        this.parseFileHeader();
      }

      fileHeaderList = this.fileHeaderList;

      for (i = 0, il = fileHeaderList.length; i < il; ++i) {
        filenameList[i] = fileHeaderList[i].filename;
      }

      return filenameList;
    };
    /**
     * @param {string} filename extract filename.
     * @param {Object=} opt_params
     * @return {!(Array.<number>|Uint8Array)} decompressed data.
     */


    Zlib$1.Unzip.prototype.decompress = function (filename, opt_params) {
      /** @type {number} */
      var index;

      if (!this.filenameToIndex) {
        this.parseFileHeader();
      }

      index = this.filenameToIndex[filename];

      if (index === void 0) {
        throw new Error(filename + ' not found');
      }

      return this.getFileData(index, opt_params);
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     */


    Zlib$1.Unzip.prototype.setPassword = function (password) {
      this.password = password;
    };
    /**
     * @param {(Array.<number>|Uint32Array|Object)} key
     * @param {number} n
     * @return {number}
     */


    Zlib$1.Unzip.prototype.decode = function (key, n) {
      n ^= this.getByte(
      /** @type {(Array.<number>|Uint32Array)} */
      key);
      this.updateKeys(
      /** @type {(Array.<number>|Uint32Array)} */
      key, n);
      return n;
    }; // common method


    Zlib$1.Unzip.prototype.updateKeys = Zlib$1.Zip.prototype.updateKeys;
    Zlib$1.Unzip.prototype.createDecryptionKey = Zlib$1.Zip.prototype.createEncryptionKey;
    Zlib$1.Unzip.prototype.getByte = Zlib$1.Zip.prototype.getByte;
    /**
     * @fileoverview 雑多な関数群をまとめたモジュール実装.
     */

    /**
     * Byte String から Byte Array に変換.
     * @param {!string} str byte string.
     * @return {!Array.<number>} byte array.
     */

    Zlib$1.Util.stringToByteArray = function (str) {
      /** @type {!Array.<(string|number)>} */
      var tmp = str.split('');
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;

      for (i = 0, il = tmp.length; i < il; i++) {
        tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;
      }

      return tmp;
    };
    /**
     * @fileoverview Adler32 checksum 実装.
     */

    /**
     * Adler32 ハッシュ値の作成
     * @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
     * @return {number} Adler32 ハッシュ値.
     */


    Zlib$1.Adler32 = function (array) {
      if (typeof array === 'string') {
        array = Zlib$1.Util.stringToByteArray(array);
      }

      return Zlib$1.Adler32.update(1, array);
    };
    /**
     * Adler32 ハッシュ値の更新
     * @param {number} adler 現在のハッシュ値.
     * @param {!(Array|Uint8Array)} array 更新に使用する byte array.
     * @return {number} Adler32 ハッシュ値.
     */


    Zlib$1.Adler32.update = function (adler, array) {
      /** @type {number} */
      var s1 = adler & 0xffff;
      /** @type {number} */

      var s2 = adler >>> 16 & 0xffff;
      /** @type {number} array length */

      var len = array.length;
      /** @type {number} loop length (don't overflow) */

      var tlen;
      /** @type {number} array index */

      var i = 0;

      while (len > 0) {
        tlen = len > Zlib$1.Adler32.OptimizationParameter ? Zlib$1.Adler32.OptimizationParameter : len;
        len -= tlen;

        do {
          s1 += array[i++];
          s2 += s1;
        } while (--tlen);

        s1 %= 65521;
        s2 %= 65521;
      }

      return (s2 << 16 | s1) >>> 0;
    };
    /**
     * Adler32 最適化パラメータ
     * 現状では 1024 程度が最適.
     * @see http://jsperf.com/adler-32-simple-vs-optimized/3
     * @define {number}
     */


    Zlib$1.Adler32.OptimizationParameter = 1024;
    /**
     * ビットストリーム
     * @constructor
     * @param {!(Array|Uint8Array)=} buffer output buffer.
     * @param {number=} bufferPosition start buffer pointer.
     */

    Zlib$1.BitStream = function (buffer, bufferPosition) {
      /** @type {number} buffer index. */
      this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;
      /** @type {number} bit index. */

      this.bitindex = 0;
      /** @type {!(Array|Uint8Array)} bit-stream output buffer. */

      this.buffer = buffer instanceof Uint8Array ? buffer : new Uint8Array(Zlib$1.BitStream.DefaultBlockSize); // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする

      if (this.buffer.length * 2 <= this.index) {
        throw new Error("invalid index");
      } else if (this.buffer.length <= this.index) {
        this.expandBuffer();
      }
    };
    /**
     * デフォルトブロックサイズ.
     * @const
     * @type {number}
     */


    Zlib$1.BitStream.DefaultBlockSize = 0x8000;
    /**
     * expand buffer.
     * @return {!(Array|Uint8Array)} new buffer.
     */

    Zlib$1.BitStream.prototype.expandBuffer = function () {
      /** @type {!(Array|Uint8Array)} old buffer. */
      var oldbuf = this.buffer;
      /** @type {number} loop limiter. */

      var il = oldbuf.length;
      /** @type {!(Array|Uint8Array)} new buffer. */

      var buffer = new Uint8Array(il << 1); // copy buffer

      {
        buffer.set(oldbuf);
      }
      return this.buffer = buffer;
    };
    /**
     * 数値をビットで指定した数だけ書き込む.
     * @param {number} number 書き込む数値.
     * @param {number} n 書き込むビット数.
     * @param {boolean=} reverse 逆順に書き込むならば true.
     */


    Zlib$1.BitStream.prototype.writeBits = function (number, n, reverse) {
      var buffer = this.buffer;
      var index = this.index;
      var bitindex = this.bitindex;
      /** @type {number} current octet. */

      var current = buffer[index];
      /** @type {number} loop counter. */

      var i;
      /**
       * 32-bit 整数のビット順を逆にする
       * @param {number} n 32-bit integer.
       * @return {number} reversed 32-bit integer.
       * @private
       */

      function rev32_(n) {
        return Zlib$1.BitStream.ReverseTable[n & 0xFF] << 24 | Zlib$1.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16 | Zlib$1.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8 | Zlib$1.BitStream.ReverseTable[n >>> 24 & 0xFF];
      }

      if (reverse && n > 1) {
        number = n > 8 ? rev32_(number) >> 32 - n : Zlib$1.BitStream.ReverseTable[number] >> 8 - n;
      } // Byte 境界を超えないとき


      if (n + bitindex < 8) {
        current = current << n | number;
        bitindex += n; // Byte 境界を超えるとき
      } else {
        for (i = 0; i < n; ++i) {
          current = current << 1 | number >> n - i - 1 & 1; // next byte

          if (++bitindex === 8) {
            bitindex = 0;
            buffer[index++] = Zlib$1.BitStream.ReverseTable[current];
            current = 0; // expand

            if (index === buffer.length) {
              buffer = this.expandBuffer();
            }
          }
        }
      }

      buffer[index] = current;
      this.buffer = buffer;
      this.bitindex = bitindex;
      this.index = index;
    };
    /**
     * ストリームの終端処理を行う
     * @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.
     */


    Zlib$1.BitStream.prototype.finish = function () {
      var buffer = this.buffer;
      var index = this.index;
      /** @type {!(Array|Uint8Array)} output buffer. */

      var output; // bitindex が 0 の時は余分に index が進んでいる状態

      if (this.bitindex > 0) {
        buffer[index] <<= 8 - this.bitindex;
        buffer[index] = Zlib$1.BitStream.ReverseTable[buffer[index]];
        index++;
      } // array truncation


      {
        output = buffer.subarray(0, index);
      }
      return output;
    };
    /**
     * 0-255 のビット順を反転したテーブル
     * @const
     * @type {!(Uint8Array|Array.<number>)}
     */


    Zlib$1.BitStream.ReverseTable = function (table) {
      return table;
    }(function () {
      /** @type {!(Array|Uint8Array)} reverse table. */
      var table = new Uint8Array(256);
      /** @type {number} loop counter. */

      var i; // generate

      for (i = 0; i < 256; ++i) {
        table[i] = function (n) {
          var r = n;
          var s = 7;

          for (n >>>= 1; n; n >>>= 1) {
            r <<= 1;
            r |= n & 1;
            --s;
          }

          return (r << s & 0xff) >>> 0;
        }(i);
      }

      return table;
    }());
    /**
     * CRC32 ハッシュ値を取得
     * @param {!(Array.<number>|Uint8Array)} data data byte array.
     * @param {number=} pos data position.
     * @param {number=} length data length.
     * @return {number} CRC32.
     */


    Zlib$1.CRC32.calc = function (data, pos, length) {
      return Zlib$1.CRC32.update(data, 0, pos, length);
    };
    /**
     * CRC32ハッシュ値を更新
     * @param {!(Array.<number>|Uint8Array)} data data byte array.
     * @param {number} crc CRC32.
     * @param {number=} pos data position.
     * @param {number=} length data length.
     * @return {number} CRC32.
     */


    Zlib$1.CRC32.update = function (data, crc, pos, length) {
      var table = Zlib$1.CRC32.Table;
      var i = typeof pos === 'number' ? pos : pos = 0;
      var il = typeof length === 'number' ? length : data.length;
      crc ^= 0xffffffff; // loop unrolling for performance

      for (i = il & 7; i--; ++pos) {
        crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 0xff];
      }

      for (i = il >> 3; i--; pos += 8) {
        crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 1]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 2]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 3]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 4]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 5]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 6]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 7]) & 0xff];
      }

      return (crc ^ 0xffffffff) >>> 0;
    };
    /**
     * @param {number} num
     * @param {number} crc
     * @returns {number}
     */


    Zlib$1.CRC32.single = function (num, crc) {
      return (Zlib$1.CRC32.Table[(num ^ crc) & 0xff] ^ num >>> 8) >>> 0;
    };
    /**
     * @type {Array.<number>}
     * @const
     * @private
     */


    Zlib$1.CRC32.Table_ = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d];
    /**
     * @type {!(Array.<number>|Uint32Array)} CRC-32 Table.
     * @const
     */

    Zlib$1.CRC32.Table = new Uint32Array(Zlib$1.CRC32.Table_);
    /**
     * @fileoverview Deflate (RFC1951) 実装.
     * Deflateアルゴリズム本体は Zlib.RawDeflate で実装されている.
     */

    /**
     * Zlib Deflate
     * @constructor
     * @param {!(Array|Uint8Array)} input 符号化する対象の byte array.
     * @param {Object=} opt_params option parameters.
     */

    Zlib$1.Deflate = function (input, opt_params) {
      /** @type {!(Array|Uint8Array)} */
      this.input = input;
      /** @type {!(Array|Uint8Array)} */

      this.output = new Uint8Array(Zlib$1.Deflate.DefaultBufferSize);
      /** @type {Zlib.Deflate.CompressionType} */

      this.compressionType = Zlib$1.Deflate.CompressionType.DYNAMIC;
      /** @type {Zlib.RawDeflate} */

      this.rawDeflate;
      /** @type {Object} */

      var rawDeflateOption = {};
      /** @type {string} */

      var prop; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (typeof opt_params['compressionType'] === 'number') {
          this.compressionType = opt_params['compressionType'];
        }
      } // copy options


      for (prop in opt_params) {
        rawDeflateOption[prop] = opt_params[prop];
      } // set raw-deflate output buffer


      rawDeflateOption['outputBuffer'] = this.output;
      this.rawDeflate = new Zlib$1.RawDeflate(this.input, rawDeflateOption);
    };
    /**
     * @const
     * @type {number} デフォルトバッファサイズ.
     */


    Zlib$1.Deflate.DefaultBufferSize = 0x8000;
    /**
     * @enum {number}
     */

    Zlib$1.Deflate.CompressionType = Zlib$1.RawDeflate.CompressionType;
    /**
     * 直接圧縮に掛ける.
     * @param {!(Array|Uint8Array)} input target buffer.
     * @param {Object=} opt_params option parameters.
     * @return {!(Array|Uint8Array)} compressed data byte array.
     */

    Zlib$1.Deflate.compress = function (input, opt_params) {
      return new Zlib$1.Deflate(input, opt_params).compress();
    };
    /**
     * Deflate Compression.
     * @return {!(Array|Uint8Array)} compressed data byte array.
     */


    Zlib$1.Deflate.prototype.compress = function () {
      /** @type {Zlib.CompressionMethod} */
      var cm;
      /** @type {number} */

      var cinfo;
      /** @type {number} */

      var cmf;
      /** @type {number} */

      var flg;
      /** @type {number} */

      var fcheck;
      /** @type {number} */

      var fdict;
      /** @type {number} */

      var flevel;
      /** @type {number} */

      var adler;
      /** @type {!(Array|Uint8Array)} */

      var output;
      /** @type {number} */

      var pos = 0;
      output = this.output; // Compression Method and Flags

      cm = Zlib$1.CompressionMethod.DEFLATE;

      switch (cm) {
        case Zlib$1.CompressionMethod.DEFLATE:
          cinfo = Math.LOG2E * Math.log(Zlib$1.RawDeflate.WindowSize) - 8;
          break;

        default:
          throw new Error('invalid compression method');
      }

      cmf = cinfo << 4 | cm;
      output[pos++] = cmf; // Flags

      fdict = 0;

      switch (cm) {
        case Zlib$1.CompressionMethod.DEFLATE:
          switch (this.compressionType) {
            case Zlib$1.Deflate.CompressionType.NONE:
              flevel = 0;
              break;

            case Zlib$1.Deflate.CompressionType.FIXED:
              flevel = 1;
              break;

            case Zlib$1.Deflate.CompressionType.DYNAMIC:
              flevel = 2;
              break;

            default:
              throw new Error('unsupported compression type');
          }

          break;

        default:
          throw new Error('invalid compression method');
      }

      flg = flevel << 6 | fdict << 5;
      fcheck = 31 - (cmf * 256 + flg) % 31;
      flg |= fcheck;
      output[pos++] = flg; // Adler-32 checksum

      adler = Zlib$1.Adler32(this.input);
      this.rawDeflate.op = pos;
      output = this.rawDeflate.compress();
      pos = output.length;
      {
        // subarray 分を元にもどす
        output = new Uint8Array(output.buffer); // expand buffer

        if (output.length <= pos + 4) {
          this.output = new Uint8Array(output.length + 4);
          this.output.set(output);
          output = this.output;
        }

        output = output.subarray(0, pos + 4);
      } // adler32

      output[pos++] = adler >> 24 & 0xff;
      output[pos++] = adler >> 16 & 0xff;
      output[pos++] = adler >> 8 & 0xff;
      output[pos++] = adler & 0xff;
      return output;
    };

    if (typeof btoa === 'undefined') {
      require('btoa');
    }

    if (typeof process === 'object' && typeof window === 'undefined') {
      global.atob = function (str) {
        return Buffer.from(str, 'base64').toString('binary');
      };
    }
    /**
     * Make the target element movable by clicking and dragging on the handle.  This is not a general purprose function,
     * it makes several options specific to igv dialogs, the primary one being that the
     * target is absolutely positioned in pixel coordinates

     */


    let dragData; // Its assumed we are only dragging one element at a time.

    function makeDraggable(target, handle) {
      handle.addEventListener('mousedown', dragStart.bind(target));
    }

    function dragStart(event) {
      event.stopPropagation();
      event.preventDefault();
      offset(this);
      const dragFunction = drag.bind(this);
      const dragEndFunction = dragEnd.bind(this);
      const computedStyle = getComputedStyle(this);
      const top = parseInt(computedStyle.top.replace("px", ""));
      const left = parseInt(computedStyle.left.replace("px", ""));
      dragData = {
        dragFunction: dragFunction,
        dragEndFunction: dragEndFunction,
        screenX: event.screenX,
        screenY: event.screenY,
        top: top,
        left: left
      };
      document.addEventListener('mousemove', dragFunction);
      document.addEventListener('mouseup', dragEndFunction);
      document.addEventListener('mouseleave', dragEndFunction);
      document.addEventListener('mouseexit', dragEndFunction);
    }

    function drag(event) {
      if (!dragData) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();
      const dx = event.screenX - dragData.screenX;
      const dy = event.screenY - dragData.screenY;
      this.style.left = `${dragData.left + dx}px`;
      this.style.top = `${dragData.top + dy}px`;
    }

    function dragEnd(event) {
      if (!dragData) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();
      const dragFunction = dragData.dragFunction;
      const dragEndFunction = dragData.dragEndFunction;
      document.removeEventListener('mousemove', dragFunction);
      document.removeEventListener('mouseup', dragEndFunction);
      document.removeEventListener('mouseleave', dragEndFunction);
      document.removeEventListener('mouseexit', dragEndFunction);
      dragData = undefined;
    }

    const appleCrayonPalette = {
      licorice: "#000000",
      lead: "#1e1e1e",
      tungsten: "#3a3a3a",
      iron: "#545453",
      steel: "#6e6e6e",
      tin: "#878687",
      nickel: "#888787",
      aluminum: "#a09fa0",
      magnesium: "#b8b8b8",
      silver: "#d0d0d0",
      mercury: "#e8e8e8",
      snow: "#ffffff",
      //
      cayenne: "#891100",
      mocha: "#894800",
      aspargus: "#888501",
      fern: "#458401",
      clover: "#028401",
      moss: "#018448",
      teal: "#008688",
      ocean: "#004a88",
      midnight: "#001888",
      eggplant: "#491a88",
      plum: "#891e88",
      maroon: "#891648",
      //
      maraschino: "#ff2101",
      tangerine: "#ff8802",
      lemon: "#fffa03",
      lime: "#83f902",
      spring: "#05f802",
      seam_foam: "#03f987",
      turquoise: "#00fdff",
      aqua: "#008cff",
      blueberry: "#002eff",
      grape: "#8931ff",
      magenta: "#ff39ff",
      strawberry: "#ff2987",
      //
      salmon: "#ff726e",
      cantaloupe: "#ffce6e",
      banana: "#fffb6d",
      honeydew: "#cefa6e",
      flora: "#68f96e",
      spindrift: "#68fbd0",
      ice: "#68fdff",
      sky: "#6acfff",
      orchid: "#6e76ff",
      lavender: "#d278ff",
      bubblegum: "#ff7aff",
      carnation: "#ff7fd3"
    }; // The MIT License (MIT)

    /**
     * @constructor
     * @param {Object} options A set op options to pass to the throttle function
     *        @param {number} requestsPerSecond The amount of requests per second
     *                                          the library will limit to
     */

    class Throttle {
      constructor(options) {
        this.requestsPerSecond = options.requestsPerSecond || 10;
        this.lastStartTime = 0;
        this.queued = [];
      }
      /**
       * Adds a promise
       * @param {Function} async function to be executed
       * @param {Object} options A set of options.
       * @return {Promise} A promise
       */


      add(asyncFunction, options) {
        var self = this;
        return new Promise(function (resolve, reject) {
          self.queued.push({
            resolve: resolve,
            reject: reject,
            asyncFunction: asyncFunction
          });
          self.dequeue();
        });
      }
      /**
       * Adds all the promises passed as parameters
       * @param {Function} promises An array of functions that return a promise
       * @param {Object} options A set of options.
       * @param {number} options.signal An AbortSignal object that can be used to abort the returned promise
       * @param {number} options.weight A "weight" of each operation resolving by array of promises
       * @return {Promise} A promise that succeeds when all the promises passed as options do
       */


      addAll(promises, options) {
        var addedPromises = promises.map(function (promise) {
          return this.add(promise, options);
        }.bind(this));
        return Promise.all(addedPromises);
      }

      /**
       * Dequeues a promise
       * @return {void}
       */
      dequeue() {
        if (this.queued.length > 0) {
          var now = new Date(),
              inc = 1000 / this.requestsPerSecond + 1,
              elapsed = now - this.lastStartTime;

          if (elapsed >= inc) {
            this._execute();
          } else {
            // we have reached the limit, schedule a dequeue operation
            setTimeout(function () {
              this.dequeue();
            }.bind(this), inc - elapsed);
          }
        }
      }
      /**
       * Executes the promise
       * @private
       * @return {void}
       */


      async _execute() {
        this.lastStartTime = new Date();
        var candidate = this.queued.shift();
        const f = candidate.asyncFunction;

        try {
          const r = await f();
          candidate.resolve(r);
        } catch (e) {
          candidate.reject(e);
        }
      }

    }
    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */


    new Throttle({
      requestsPerSecond: 8
    });

    class Textbox {
      constructor({
        value,
        label,
        onchange
      }) {
        this.elem = div({
          class: 'igv-ui-generic-dialog-label-input'
        });

        if (label) {
          const div$1 = div();
          div$1.innerHTML = label;
          this.elem.appendChild(div$1);
        }

        this.textBox = create('input');

        if (value) {
          this.textBox.value = value;
        }

        this.elem.appendChild(this.textBox);

        if (onchange) {
          this.textBox.addEventListener('change', e => onchange(this.textBox.value));
        }
      }

      get value() {
        return this.textBox.value;
      }

      set value(v) {
        this.textBox.value = v;
      }

    }
    /**
     * Generic container for UI components
     */


    class Panel {
      constructor() {
        this.elem = create('div', {
          class: 'igv-ui-panel-column'
        });
      }

      add(component) {
        if (component instanceof Node) {
          this.elem.append(component);
        } else if (typeof component === 'object') {
          this.elem.append(component.elem);
        } else {
          // Assuming a string, possibly html
          const wrapper = div();
          wrapper.innerHTML = component;
          this.elem.append(wrapper);
        }
      }

    }

    class Dialog {
      constructor({
        label,
        content,
        okHandler,
        cancelHandler
      }) {
        const cancel = () => {
          hide(this.elem);

          if (typeof cancelHandler === 'function') {
            cancelHandler(this);
          }
        }; // dialog container


        this.elem = div({
          class: 'igv-ui-generic-dialog-container'
        }); // dialog header

        const header = div({
          class: 'igv-ui-generic-dialog-header'
        });
        this.elem.appendChild(header);
        attachDialogCloseHandlerWithParent(header, cancel); // dialog label

        if (label) {
          const labelDiv = div({
            class: 'igv-ui-dialog-one-liner'
          });
          this.elem.appendChild(labelDiv);
          labelDiv.innerHTML = label;
        } // input container


        content.elem.style.margin = '8px';
        this.elem.appendChild(content.elem); // ok | cancel

        const buttons = div({
          class: 'igv-ui-generic-dialog-ok-cancel'
        });
        this.elem.appendChild(buttons); // ok

        this.ok = div();
        buttons.appendChild(this.ok);
        this.ok.textContent = 'OK'; // cancel

        this.cancel = div();
        buttons.appendChild(this.cancel);
        this.cancel.textContent = 'Cancel';
        this.ok.addEventListener('click', e => {
          hide(this.elem);

          if (typeof okHandler === 'function') {
            okHandler(this);
          }
        });
        this.cancel.addEventListener('click', cancel);
        makeDraggable(this.elem, header); // Consume all clicks in component

        this.elem.addEventListener('click', e => {
          e.preventDefault();
          e.stopPropagation();
        });
      }

      present(options, e) {
        this.label.textContent = options.label;
        this.input.value = options.value;
        this.callback = options.callback;
        const page = pageCoordinates(e);
        this.clampLocation(page.x, page.y);
        show(this.elem);
      }

      clampLocation(pageX, pageY) {
        let popoverRect = this.elem.getBoundingClientRect();
        let parentRect = this.parent.getBoundingClientRect();
        const y = Math.min(Math.max(pageY, parentRect.y), parentRect.y + parentRect.height - popoverRect.height);
        const x = Math.min(Math.max(pageX, parentRect.x), parentRect.x + parentRect.width - popoverRect.width);
        this.elem.style.left = x + "px";
        this.elem.style.top = y + "px";
      }

    }

    class DataRangeDialog {
      constructor(parent, okHandler) {
        const panel = new Panel();
        this.minbox = new Textbox({
          label: "Minimum",
          value: "0"
        });
        panel.add(this.minbox);
        this.maxbox = new Textbox({
          label: "Maximum",
          value: "0"
        });
        panel.add(this.maxbox);
        let callback;

        if (okHandler) {
          callback = e => {
            okHandler(Number.parseFloat(this.minbox.value), Number.parseFloat(this.maxbox.value));
          };
        } else {
          callback = d => {};
        }

        this.dialog = new Dialog({
          //label: 'Multi-select',
          content: panel,
          okHandler: callback
        }); // Overide some css styles -- TODO redesign this.

        this.dialog.elem.style.position = "absolute";
        hide(this.dialog.elem);
        parent.appendChild(this.dialog.elem);
      }

      show({
        min,
        max
      }) {
        if (min !== undefined) this.minbox.value = min.toString();
        if (max !== undefined) this.maxbox.value = max.toString();
        show(this.dialog.elem);
      }

    }

    const httpMessages = {
      "401": "Access unauthorized",
      "403": "Access forbidden",
      "404": "Not found"
    };

    class AlertDialog {
      constructor(parent) {
        // container
        this.container = div({
          class: "igv-ui-alert-dialog-container"
        });
        parent.appendChild(this.container);
        this.container.setAttribute('tabIndex', '-1'); // header

        const header = div();
        this.container.appendChild(header);
        this.errorHeadline = div();
        header.appendChild(this.errorHeadline);
        this.errorHeadline.textContent = ''; // body container

        let bodyContainer = div({
          id: 'igv-ui-alert-dialog-body'
        });
        this.container.appendChild(bodyContainer); // body copy

        this.body = div({
          id: 'igv-ui-alert-dialog-body-copy'
        });
        bodyContainer.appendChild(this.body); // ok container

        let ok_container = div();
        this.container.appendChild(ok_container); // ok

        this.ok = div();
        ok_container.appendChild(this.ok);
        this.ok.textContent = 'OK';

        const okHandler = () => {
          if (typeof this.callback === 'function') {
            this.callback("OK");
            this.callback = undefined;
          }

          this.body.innerHTML = '';
          hide(this.container);
        };

        this.ok.addEventListener('click', event => {
          event.stopPropagation();
          okHandler();
        });
        this.container.addEventListener('keypress', event => {
          event.stopPropagation();

          if ('Enter' === event.key) {
            okHandler();
          }
        });
        makeDraggable(this.container, header);
        hide(this.container);
      }

      present(alert, callback) {
        this.errorHeadline.textContent = alert.message ? 'ERROR' : '';
        let string = alert.message || alert;

        if (httpMessages.hasOwnProperty(string)) {
          string = httpMessages[string];
        }

        this.body.innerHTML = string;
        this.callback = callback;
        show(this.container);
        this.container.focus();
      }

    }

    let alertDialog;
    const Alert$1 = {
      init(root) {
        if (!alertDialog) {
          alertDialog = new AlertDialog(root);
        }
      },

      presentAlert(alert, callback) {
        if (!alertDialog) {
          this.init(document.body);
        }

        alertDialog.present(alert, callback);
      }

    };

    class InputDialog {
      constructor(parent) {
        this.parent = parent; // dialog container

        this.container = div({
          class: 'igv-ui-generic-dialog-container'
        });
        parent.appendChild(this.container); // const { x, y, width, height } = this.container.getBoundingClientRect();
        // console.log(`InputDialog - x ${ x } y ${ y } width ${ width } height ${ height }`)
        // dialog header

        const header = div({
          class: 'igv-ui-generic-dialog-header'
        });
        this.container.appendChild(header); // dialog label

        this.label = div({
          class: 'igv-ui-generic-dialog-one-liner'
        });
        this.container.appendChild(this.label);
        this.label.text = 'Unlabeled'; // input container

        this.input_container = div({
          class: 'igv-ui-generic-dialog-input'
        });
        this.container.appendChild(this.input_container); //

        this.input = document.createElement("input");
        this.input_container.appendChild(this.input); // ok | cancel

        const buttons = div({
          class: 'igv-ui-generic-dialog-ok-cancel'
        });
        this.container.appendChild(buttons); // ok

        this.ok = div();
        buttons.appendChild(this.ok);
        this.ok.textContent = 'OK'; // cancel

        this.cancel = div();
        buttons.appendChild(this.cancel);
        this.cancel.textContent = 'Cancel';
        hide(this.container);
        this.input.addEventListener('keyup', e => {
          if (13 === e.keyCode) {
            if (typeof this.callback === 'function') {
              this.callback(this.input.value);
              this.callback = undefined;
            }

            this.input.value = undefined;
            hide(this.container);
          }
        });
        this.ok.addEventListener('click', () => {
          if (typeof this.callback === 'function') {
            this.callback(this.input.value);
            this.callback = undefined;
          }

          this.input.value = undefined;
          hide(this.container);
        });

        const cancel = () => {
          this.input.value = '';
          hide(this.container);
        };

        this.cancel.addEventListener('click', cancel);
        attachDialogCloseHandlerWithParent(header, cancel);
        makeDraggable(this.container, header);
      }

      present(options, e) {
        this.label.textContent = options.label;
        this.input.value = options.value;
        this.callback = options.callback || options.click;
        show(this.container);
        const {
          x,
          y
        } = pageCoordinates(e);
        this.clampLocation(x, y);
      }

      clampLocation(pageX, pageY) {
        const {
          width: w,
          height: h
        } = this.container.getBoundingClientRect();
        const {
          x: px,
          y: py,
          width: pw,
          height: ph
        } = this.parent.getBoundingClientRect();
        const y = Math.min(Math.max(pageY, py), py + ph - h);
        const x = Math.min(Math.max(pageX, px), px + pw - w);
        this.container.style.left = `${x}px`;
        this.container.style.top = `${y}px`;
      }

    }

    class GenericContainer {
      constructor({
        parent,
        top,
        left,
        width,
        height,
        border,
        closeHandler
      }) {
        let container = div({
          class: 'igv-ui-generic-container'
        });
        parent.appendChild(container);
        hide(container);
        this.container = container;

        if (top !== undefined) {
          this.container.style.top = `${top}px`;
        }

        if (left !== undefined) {
          this.container.style.left = `${left}px`;
        }

        if (width !== undefined) {
          this.container.style.width = `${width}px`;
        }

        if (height !== undefined) {
          this.container.style.height = `${height}px`;
        }

        if (border) {
          this.container.style.border = border;
        } //
        // let bbox = parent.getBoundingClientRect();
        // this.origin = {x: bbox.x, y: bbox.y};
        // this.container.offset({left: this.origin.x, top: this.origin.y});
        // header


        const header = div();
        this.container.appendChild(header); // close button

        attachDialogCloseHandlerWithParent(header, e => {
          hide(this.container);

          if (typeof closeHandler === "function") {
            closeHandler(e);
          }
        });
        makeDraggable(this.container, header);
      }

      show() {
        show(this.container);
      }

      hide() {
        hide(this.container);
      }

      dispose() {
        if (this.container.parent) {
          this.container.parent.removeChild(this.container);
        }
      }

    }

    class ColorPicker extends GenericContainer {
      constructor({
        parent,
        top,
        left,
        width,
        height,
        defaultColors,
        colorHandler
      }) {
        super({
          parent,
          top,
          left,
          width,
          height,
          border: '1px solid gray'
        });
        createColorSwatchSelector(this.container, colorHandler, defaultColors);
      }

    }

    const createColorSwatchSelector = (container, colorHandler, defaultColors) => {
      const hexColorStrings = Object.values(appleCrayonPalette);

      for (let hexColorString of hexColorStrings) {
        const swatch = div({
          class: 'igv-ui-color-swatch'
        });
        container.appendChild(swatch);
        decorateSwatch(swatch, hexColorString, colorHandler);
      }

      if (defaultColors) {
        for (let hexColorString of defaultColors) {
          const swatch = div({
            class: 'igv-ui-color-swatch'
          });
          container.appendChild(swatch);
          decorateSwatch(swatch, hexColorString, colorHandler);
        }
      }
    };

    const decorateSwatch = (swatch, hexColorString, colorHandler) => {
      swatch.style.backgroundColor = hexColorString;
      swatch.addEventListener('mouseenter', e => swatch.style.borderColor = hexColorString);
      swatch.addEventListener('mouseleave', e => swatch.style.borderColor = 'white');
      swatch.addEventListener('click', event => {
        event.stopPropagation();
        colorHandler(hexColorString);
      });
      swatch.addEventListener('touchend', event => {
        event.stopPropagation();
        colorHandler(hexColorString);
      });
    };

    function embedCSS() {
      var css = '.igv-ui-popover {\n  cursor: default;\n  position: absolute;\n  z-index: 2048;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: 1px;\n  font-family: \"Open Sans\", sans-serif;\n  font-size: small;\n  background-color: white; }\n  .igv-ui-popover > div:first-child {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: flex-end;\n    align-items: center;\n    width: 100%;\n    height: 24px;\n    cursor: move;\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n    border-bottom-color: #7F7F7F;\n    border-bottom-style: solid;\n    border-bottom-width: thin;\n    background-color: #eee; }\n    .igv-ui-popover > div:first-child > div {\n      margin-right: 4px;\n      height: 12px;\n      width: 12px;\n      color: #7F7F7F; }\n    .igv-ui-popover > div:first-child > div:hover {\n      cursor: pointer;\n      color: #444; }\n  .igv-ui-popover > div:last-child {\n    overflow-y: auto;\n    overflow-x: hidden;\n    max-height: 400px;\n    background-color: white; }\n    .igv-ui-popover > div:last-child > div {\n      -webkit-user-select: all;\n      /* Chrome/Safari */\n      -moz-user-select: all;\n      /* Firefox */\n      margin-left: 4px;\n      margin-right: 4px;\n      max-width: 384px;\n      min-width: 220px;\n      overflow-x: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap; }\n      .igv-ui-popover > div:last-child > div > span {\n        font-weight: bolder; }\n    .igv-ui-popover > div:last-child hr {\n      width: 100%; }\n\n.igv-ui-alert-dialog-container {\n  box-sizing: content-box;\n  position: absolute;\n  z-index: 2048;\n  top: 50%;\n  left: 50%;\n  width: 400px;\n  height: 200px;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  outline: none;\n  font-family: \"Open Sans\", sans-serif;\n  font-size: 15px;\n  font-weight: 400;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center; }\n  .igv-ui-alert-dialog-container > div:first-child {\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-items: center;\n    width: 100%;\n    height: 24px;\n    cursor: move;\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n    border-bottom-color: #7F7F7F;\n    border-bottom-style: solid;\n    border-bottom-width: thin;\n    background-color: #eee; }\n    .igv-ui-alert-dialog-container > div:first-child div:first-child {\n      padding-left: 8px; }\n  .igv-ui-alert-dialog-container #igv-ui-alert-dialog-body {\n    color: #373737;\n    width: 100%;\n    height: calc(100% - 24px - 64px);\n    overflow-y: scroll; }\n    .igv-ui-alert-dialog-container #igv-ui-alert-dialog-body #igv-ui-alert-dialog-body-copy {\n      cursor: pointer;\n      margin: 16px;\n      width: auto;\n      height: auto;\n      overflow-wrap: break-word;\n      word-break: break-word;\n      background-color: white;\n      border: unset; }\n  .igv-ui-alert-dialog-container > div:last-child {\n    width: 100%;\n    margin-bottom: 10px;\n    background-color: white;\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: center;\n    align-items: center; }\n    .igv-ui-alert-dialog-container > div:last-child div {\n      margin: unset;\n      width: 40px;\n      height: 30px;\n      line-height: 30px;\n      text-align: center;\n      color: white;\n      font-family: \"Open Sans\", sans-serif;\n      font-size: small;\n      font-weight: 400;\n      border-color: #2B81AF;\n      border-style: solid;\n      border-width: thin;\n      border-radius: 4px;\n      background-color: #2B81AF; }\n    .igv-ui-alert-dialog-container > div:last-child div:hover {\n      cursor: pointer;\n      border-color: #25597f;\n      background-color: #25597f; }\n\n.igv-ui-color-swatch {\n  position: relative;\n  box-sizing: content-box;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: wrap;\n  justify-content: center;\n  align-items: center;\n  width: 32px;\n  height: 32px;\n  border-style: solid;\n  border-width: 2px;\n  border-color: white;\n  border-radius: 4px; }\n\n.igv-ui-color-swatch:hover {\n  border-color: dimgray; }\n\n.igv-ui-colorpicker-menu-close-button {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  width: 100%;\n  height: 32px;\n  margin-top: 4px;\n  margin-bottom: 4px;\n  padding-right: 8px; }\n  .igv-ui-colorpicker-menu-close-button i.fa {\n    display: block;\n    margin-left: 4px;\n    margin-right: 4px;\n    color: #5f5f5f; }\n  .igv-ui-colorpicker-menu-close-button i.fa:hover,\n  .igv-ui-colorpicker-menu-close-button i.fa:focus,\n  .igv-ui-colorpicker-menu-close-button i.fa:active {\n    cursor: pointer;\n    color: #0f0f0f; }\n\n.igv-ui-generic-dialog-container {\n  box-sizing: content-box;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 300px;\n  height: 200px;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: \"Open Sans\", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  z-index: 2048;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center; }\n  .igv-ui-generic-dialog-container .igv-ui-generic-dialog-header {\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: flex-end;\n    align-items: center;\n    width: 100%;\n    height: 24px;\n    cursor: move;\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n    border-bottom-color: #7F7F7F;\n    border-bottom-style: solid;\n    border-bottom-width: thin;\n    background-color: #eee; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-header div {\n      margin-right: 4px;\n      margin-bottom: 2px;\n      height: 12px;\n      width: 12px;\n      color: #7F7F7F; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-header div:hover {\n      cursor: pointer;\n      color: #444; }\n  .igv-ui-generic-dialog-container .igv-ui-generic-dialog-one-liner {\n    color: #373737;\n    width: 95%;\n    height: 24px;\n    line-height: 24px;\n    text-align: left;\n    margin-top: 8px;\n    padding-left: 8px;\n    overflow-wrap: break-word;\n    background-color: white; }\n  .igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input {\n    margin-top: 8px;\n    width: 95%;\n    height: 24px;\n    color: #373737;\n    line-height: 24px;\n    padding-left: 8px;\n    background-color: white;\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: flex-start;\n    align-items: center; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input div {\n      width: 30%;\n      height: 100%;\n      font-size: 16px;\n      text-align: right;\n      padding-right: 8px;\n      background-color: white; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input input {\n      display: block;\n      height: 100%;\n      width: 100%;\n      padding-left: 4px;\n      font-family: \"Open Sans\", sans-serif;\n      font-weight: 400;\n      color: #373737;\n      text-align: left;\n      outline: none;\n      border-style: solid;\n      border-width: thin;\n      border-color: #7F7F7F;\n      background-color: white; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input input {\n      width: 50%;\n      font-size: 16px; }\n  .igv-ui-generic-dialog-container .igv-ui-generic-dialog-input {\n    margin-top: 8px;\n    width: calc(100% - 16px);\n    height: 24px;\n    color: #373737;\n    line-height: 24px;\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: space-around;\n    align-items: center; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-input input {\n      display: block;\n      height: 100%;\n      width: 100%;\n      padding-left: 4px;\n      font-family: \"Open Sans\", sans-serif;\n      font-weight: 400;\n      color: #373737;\n      text-align: left;\n      outline: none;\n      border-style: solid;\n      border-width: thin;\n      border-color: #7F7F7F;\n      background-color: white; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-input input {\n      font-size: 16px; }\n  .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel {\n    width: 100%;\n    height: 28px;\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: space-around;\n    align-items: center; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div {\n      margin-top: 32px;\n      color: white;\n      font-family: \"Open Sans\", sans-serif;\n      font-size: 14px;\n      font-weight: 400;\n      width: 75px;\n      height: 28px;\n      line-height: 28px;\n      text-align: center;\n      border-color: transparent;\n      border-style: solid;\n      border-width: thin;\n      border-radius: 2px; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:first-child {\n      margin-left: 32px;\n      margin-right: 0;\n      background-color: #5ea4e0; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:last-child {\n      margin-left: 0;\n      margin-right: 32px;\n      background-color: #c4c4c4; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:first-child:hover {\n      cursor: pointer;\n      background-color: #3b5c7f; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:last-child:hover {\n      cursor: pointer;\n      background-color: #7f7f7f; }\n  .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok {\n    width: 100%;\n    height: 36px;\n    margin-top: 32px;\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: space-around;\n    align-items: center; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok div {\n      width: 98px;\n      height: 36px;\n      line-height: 36px;\n      text-align: center;\n      color: white;\n      font-family: \"Open Sans\", sans-serif;\n      font-size: medium;\n      font-weight: 400;\n      border-color: white;\n      border-style: solid;\n      border-width: thin;\n      border-radius: 4px;\n      background-color: #2B81AF; }\n    .igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok div:hover {\n      cursor: pointer;\n      background-color: #25597f; }\n\n.igv-ui-generic-container {\n  box-sizing: content-box;\n  position: absolute;\n  z-index: 2048;\n  background-color: white;\n  cursor: pointer;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n  align-items: center; }\n  .igv-ui-generic-container div:first-child {\n    cursor: move;\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: flex-end;\n    align-items: center;\n    height: 24px;\n    width: 100%;\n    background-color: #dddddd; }\n    .igv-ui-generic-container div:first-child div {\n      display: block;\n      color: #5f5f5f;\n      cursor: pointer;\n      width: 14px;\n      height: 14px;\n      margin-right: 8px;\n      margin-bottom: 4px; }\n\n.igv-ui-dialog {\n  z-index: 2048;\n  position: fixed;\n  width: fit-content;\n  height: fit-content;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  background-color: white;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: \"Open Sans\", sans-serif;\n  font-size: medium;\n  font-weight: 400; }\n  .igv-ui-dialog .igv-ui-dialog-header {\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: flex-end;\n    align-items: center;\n    width: 100%;\n    height: 24px;\n    cursor: move;\n    border-top-left-radius: 4px;\n    border-top-right-radius: 4px;\n    border-bottom-color: #7F7F7F;\n    border-bottom-style: solid;\n    border-bottom-width: thin;\n    background-color: #eee; }\n    .igv-ui-dialog .igv-ui-dialog-header div {\n      margin-right: 4px;\n      margin-bottom: 2px;\n      height: 12px;\n      width: 12px;\n      color: #7F7F7F; }\n    .igv-ui-dialog .igv-ui-dialog-header div:hover {\n      cursor: pointer;\n      color: #444; }\n  .igv-ui-dialog .igv-ui-dialog-one-liner {\n    width: 95%;\n    height: 24px;\n    line-height: 24px;\n    text-align: left;\n    margin: 8px;\n    overflow-wrap: break-word;\n    background-color: white;\n    font-weight: bold; }\n  .igv-ui-dialog .igv-ui-dialog-ok-cancel {\n    width: 100%;\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: space-around;\n    align-items: center; }\n    .igv-ui-dialog .igv-ui-dialog-ok-cancel div {\n      margin: 16px;\n      margin-top: 32px;\n      color: white;\n      font-family: \"Open Sans\", sans-serif;\n      font-size: 14px;\n      font-weight: 400;\n      width: 75px;\n      height: 28px;\n      line-height: 28px;\n      text-align: center;\n      border-color: transparent;\n      border-style: solid;\n      border-width: thin;\n      border-radius: 2px; }\n    .igv-ui-dialog .igv-ui-dialog-ok-cancel div:first-child {\n      background-color: #5ea4e0; }\n    .igv-ui-dialog .igv-ui-dialog-ok-cancel div:last-child {\n      background-color: #c4c4c4; }\n    .igv-ui-dialog .igv-ui-dialog-ok-cancel div:first-child:hover {\n      cursor: pointer;\n      background-color: #3b5c7f; }\n    .igv-ui-dialog .igv-ui-dialog-ok-cancel div:last-child:hover {\n      cursor: pointer;\n      background-color: #7f7f7f; }\n  .igv-ui-dialog .igv-ui-dialog-ok {\n    width: 100%;\n    height: 36px;\n    margin-top: 32px;\n    display: flex;\n    flex-flow: row;\n    flex-wrap: nowrap;\n    justify-content: space-around;\n    align-items: center; }\n    .igv-ui-dialog .igv-ui-dialog-ok div {\n      width: 98px;\n      height: 36px;\n      line-height: 36px;\n      text-align: center;\n      color: white;\n      font-family: \"Open Sans\", sans-serif;\n      font-size: medium;\n      font-weight: 400;\n      border-color: white;\n      border-style: solid;\n      border-width: thin;\n      border-radius: 4px;\n      background-color: #2B81AF; }\n    .igv-ui-dialog .igv-ui-dialog-ok div:hover {\n      cursor: pointer;\n      background-color: #25597f; }\n\n.igv-ui-panel, .igv-ui-panel-column, .igv-ui-panel-row {\n  z-index: 2048;\n  background-color: white;\n  font-family: \"Open Sans\", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  display: flex;\n  justify-content: flex-start;\n  align-items: flex-start; }\n\n.igv-ui-panel-column {\n  display: flex;\n  flex-direction: column; }\n\n.igv-ui-panel-row {\n  display: flex;\n  flex-direction: row; }\n\n.igv-ui-textbox {\n  background-color: white;\n  font-family: \"Open Sans\", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  display: flex;\n  justify-content: flex-start;\n  align-items: flex-start; }\n\n/*# sourceMappingURL=igv-ui.css.map */\n';
      var style = document.createElement('style');
      style.setAttribute('type', 'text/css');
      style.innerHTML = css;
      document.head.insertBefore(style, document.head.childNodes[document.head.childNodes.length - 1]);
    }

    if (typeof document !== 'undefined') {
      if (!stylesheetExists("igv-ui.css")) {
        // console.log('igv-ui. will call embedCSS() ...');
        embedCSS(); // console.log('... done.');
      }

      function stylesheetExists(stylesheetName) {
        for (let ss of document.styleSheets) {
          ss = ss.href ? ss.href.replace(/^.*[\\\/]/, '') : '';

          if (ss === stylesheetName) {
            return true;
          }
        }

        return false;
      }
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2018 Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * A collection of properties and methods shared by all (or most) track types.
     *
     * @param config
     * @param browser
     * @constructor
     */

    class TrackBase {
      constructor(config, browser) {
        if (config.displayMode) {
          config.displayMode = config.displayMode.toUpperCase();
        }

        this.config = config;
        this.browser = browser;
        this.url = config.url;
        this.type = config.type;
        this.description = config.description;
        this.supportHiDPI = config.supportHiDPI === undefined ? true : config.supportHiDPI;

        if (config.name || config.label) {
          this.name = config.name || config.label;
        } else {
          if (isFilePath(config.url)) this.name = config.url.name;else this.name = config.url;
        }

        this.id = this.config.id === undefined ? this.name : this.config.id;
        this.order = config.order;
        this.color = config.color;
        this.altColor = config.altColor;

        if ("civic-ws" === config.sourceType) {
          // Ugly proxy for specialized track type
          this.defaultColor = "rgb(155,20,20)";
        } else {
          this.defaultColor = "rgb(0,0,150)";
        }

        this.autoscaleGroup = config.autoscaleGroup;
        this.removable = config.removable === undefined ? true : config.removable; // Defaults to true

        this.height = config.height || 100;
        this.autoHeight = config.autoHeight;
        this.minHeight = config.minHeight || Math.min(25, this.height);
        this.maxHeight = config.maxHeight || Math.max(1000, this.height);
        this.visibilityWindow = config.visibilityWindow;
      }
      /**
       * Default implementation -- update config with current values.
       * to create session object for bookmarking, sharing.  Updates the track "config" object to reflect the
       * current state.  Only simple properties (string, number, boolean) are updated.
       */


      getState() {
        // Create copy of config, minus transient properties (convention is name starts with '_')
        const state = {};

        for (let key of Object.keys(this.config)) {
          if (!key.startsWith("_")) {
            state[key] = this.config[key];
          }
        } // Update original config values with any changes


        for (let key of Object.keys(state)) {
          if (key.startsWith("_")) continue; // transient property

          const value = this[key];

          if (value && (isSimpleType(value) || typeof value === "boolean")) {
            state[key] = value;
          }
        }

        if (this.color) state.color = this.color;
        if (this.altColor) state.altColor = this.altColor; // Flatten dataRange if present

        if (!this.autoscale && this.dataRange) {
          if (state.min !== undefined && state.min !== null) {
            state.min = this.dataRange.min;
          }

          if (state.max !== undefined && state.max !== null) {
            state.max = this.dataRange.max;
          }
        } // Check for non-json-if-yable properties.  Perhaps we should test what can be saved.


        for (let key of Object.keys(state)) {
          if (typeof state[key] === 'function') {
            throw Error(`Property '${key}' of track '${this.name} is a function. Functions cannot be saved in sessions.`);
          }

          if (state[key] instanceof File) {
            throw Error(`Property '${key}' of track '${this.name} is a local File. Local file references cannot be saved in sessions.`);
          }

          if (state[key] instanceof Promise) {
            throw Error(`Property '${key}' of track '${this.name} is a Promise. Promises cannot be saved in sessions.`);
          }
        } // Remove properties with undefined values, no reason to save these


        let keys = Object.keys(state);

        for (let key of keys) {
          if (state[key] === undefined) {
            delete state[key];
          }
        }

        return state;
      }

      supportsWholeGenome() {
        return false;
      }

      getGenomeId() {
        return this.browser.genome ? this.browser.genome.id : undefined;
      }
      /**
       * Set certain track properties, usually from a "track" line.  Not all UCSC properties are supported.
       *
       * Track configuration settings have precendence over track line properties, so if both are present ignore the
       * track line.
       *
       * @param properties
       */


      setTrackProperties(properties) {
        const tracklineConfg = {};
        let tokens;

        for (let key of Object.keys(properties)) {
          switch (key.toLowerCase()) {
            case "usescore":
              tracklineConfg.useScore = properties[key] === 1 || properties[key] === "1" || properties[key] === "on" || properties[key] === true;
              break;

            case "visibility":
              //0 - hide, 1 - dense, 2 - full, 3 - pack, and 4 - squish
              switch (properties[key]) {
                case "2":
                case "3":
                case "pack":
                case "full":
                  tracklineConfg.displayMode = "EXPANDED";
                  break;

                case "4":
                case "squish":
                  tracklineConfg.displayMode = "SQUISHED";
                  break;

                case "1":
                case "dense":
                  tracklineConfg.displayMode = "COLLAPSED";
              }

              break;

            case "color":
            case "altcolor":
              tracklineConfg[key] = properties[key].startsWith("rgb(") ? properties[key] : "rgb(" + properties[key] + ")";
              break;

            case "featurevisiblitywindow":
            case "visibilitywindow":
              tracklineConfg.visibilityWindow = Number.parseInt(properties[key]);
              break;

            case "maxheightpixels":
              tokens = properties[key].split(":");

              if (tokens.length === 3) {
                tracklineConfg.minHeight = Number.parseInt(tokens[2]);
                tracklineConfg.height = Number.parseInt(tokens[1]);
                tracklineConfg.maxHeight = Number.parseInt(tokens[0]);
              }

              break;

            case "viewlimits":
              if (!this.config.autoscale) {
                // autoscale in the config has precedence
                tokens = properties[key].split(":");
                let min = 0;
                let max;

                if (tokens.length == 1) {
                  max = Number.parseFloat(tokens[0]);
                } else if (tokens.length == 2) {
                  min = Number.parseFloat(tokens[0]);
                  max = Number.parseFloat(tokens[1]);
                }

                tracklineConfg.autoscale = false;
                tracklineConfg.dataRange = {
                  min,
                  max
                };
              }

            case "name":
              tracklineConfg[key] = properties[key];
          }
        } // Track configuration objects have precendence over track line properties


        for (let key of Object.keys(tracklineConfg)) {
          if (!this.config.hasOwnProperty(key)) {
            this[key] = tracklineConfg[key];
          }
        }
      }

      getVisibilityWindow() {
        return this.visibilityWindow;
      }

      clickedFeatures(clickState) {
        // We use the cached features rather than method to avoid async load.  If the
        // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.
        const features = clickState.viewport.getCachedFeatures();

        if (!features || features.length === 0) {
          return [];
        }

        const genomicLocation = clickState.genomicLocation; // When zoomed out we need some tolerance around genomicLocation

        const tolerance = clickState.referenceFrame.bpPerPixel > 0.2 ? 3 * clickState.referenceFrame.bpPerPixel : 0;
        const ss = Math.floor(genomicLocation) - tolerance;
        const ee = Math.floor(genomicLocation) + tolerance;
        return FeatureUtils.findOverlapping(features, ss, ee);
      }
      /**
       * Default popup text function -- just extracts string and number properties in random order.
       * @param feature
       * @returns {Array}
       */


      static extractPopupData(feature, genomeId) {
        const filteredProperties = new Set(['row', 'color', 'chr', 'start', 'end', 'cdStart', 'cdEnd', 'strand', 'alpha']);
        const data = [];
        let alleles, alleleFreqs;

        for (var property in feature) {
          if (feature.hasOwnProperty(property) && !filteredProperties.has(property) && isSimpleType(feature[property])) {
            let value = feature[property];
            data.push({
              name: capitalize(property),
              value: value
            });

            if (property === "alleles") {
              alleles = feature[property];
            } else if (property === "alleleFreqs") {
              alleleFreqs = feature[property];
            }
          }
        } //const genomeId = this.getGenomeId()


        if (alleles && alleleFreqs) {
          if (alleles.endsWith(",")) {
            alleles = alleles.substr(0, alleles.length - 1);
          }

          if (alleleFreqs.endsWith(",")) {
            alleleFreqs = alleleFreqs.substr(0, alleleFreqs.length - 1);
          }

          let a = alleles.split(",");
          let af = alleleFreqs.split(",");

          if (af.length > 1) {
            let b = [];

            for (let i = 0; i < af.length; i++) {
              b.push({
                a: a[i],
                af: Number.parseFloat(af[i])
              });
            }

            b.sort(function (x, y) {
              return x.af - y.af;
            });
            let ref = b[b.length - 1].a;

            if (ref.length === 1) {
              for (let i = b.length - 2; i >= 0; i--) {
                let alt = b[i].a;

                if (alt.length === 1) {
                  const cravatLink = TrackBase.getCravatLink(feature.chr, feature.start + 1, ref, alt, genomeId);

                  if (cravatLink) {
                    data.push("<hr/>");
                    data.push(cravatLink);
                  }
                }
              }
            }
          }
        }

        if (feature.attributes) {
          for (let key of Object.keys(feature.attributes)) {
            data.push({
              name: key,
              value: feature.attributes[key]
            });
          }
        } // final chr position


        let posString = `${feature.chr}:${numberFormatter(feature.start + 1)}-${numberFormatter(feature.end)}`;

        if (feature.strand) {
          posString += ` (${feature.strand})`;
        }

        data.push('<hr\>');
        data.push(posString);
        return data;
      }

      static getCravatLink(chr, position, ref, alt, genomeID) {
        if ("hg38" === genomeID || "GRCh38" === genomeID) {
          const cravatChr = chr.startsWith("chr") ? chr : "chr" + chr;
          return `<a target="_blank" href="https://run.opencravat.org/result/nocache/variant.html` + `?chrom=${cravatChr}&pos=${position}&ref_base=${ref}&alt_base=${alt}">Cravat ${ref}->${alt}</a>`; // return "<a target='_blank' " +
          //     "href='https://www.cravat.us/CRAVAT/variant.html?variant=" +
          //     cravatChr + "_" + position + "_+_" + ref + "_" + alt + "'>Cravat " + ref + "->" + alt + "</a>"
        } else {
          return undefined;
        }
      }

    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    const knownAltBases = new Set(["A", "C", "T", "G"].map(c => c.charCodeAt(0)));

    function createVCFVariant(tokens) {
      return new Variant(tokens);
    }

    class Variant {
      constructor(tokens) {
        this.chr = tokens[0]; // TODO -- use genome aliases

        this.pos = parseInt(tokens[1]);
        this.names = tokens[2]; // id in VCF

        this.referenceBases = tokens[3];
        this.alternateBases = tokens[4];
        this.quality = tokens[5];
        this.filter = tokens[6];
        this.info = getInfoObject(tokens[7]);
        this.init();
      }

      init() {
        const ref = this.referenceBases;
        const altBases = this.alternateBases;

        if (this.info) {
          if (this.info["VT"]) {
            this.type = this.info["VT"];
          } else if (this.info["SVTYPE"]) {
            this.type = "SV";
          } else if (this.info["PERIOD"]) {
            this.type = "STR";
          }
        }

        if (this.type === undefined) {
          this.type = determineType(ref, altBases);
        }

        if (this.type === "NONVARIANT") {
          this.heterozygosity = 0;
        } // Determine start/end coordinates -- these are the coordinates representing the actual variant,
        // not the leading or trailing reference


        if (this.info["END"]) {
          this.start = this.pos - 1;

          if (this.info["CHR2"] && this.info["CHR2"] !== this.chr) {
            this.end = this.start + 1;
          } else {
            this.end = Number.parseInt(this.info["END"]);
          }
        } else {
          if (this.type === "NONVARIANT") {
            this.start = this.pos - 1; // convert to 0-based coordinate convention

            this.end = this.start + ref.length;
          } else {
            const altTokens = altBases.split(",").filter(token => token.length > 0);
            this.alleles = [];
            this.start = undefined;
            this.end = undefined;

            for (let alt of altTokens) {
              this.alleles.push(alt); // We don't yet handle  SV and other special alt representations

              if ("SV" !== this.type && isKnownAlt(alt)) {
                let altLength = alt.length;
                let lengthOnRef = ref.length; // Trim off matching bases.  Try first match, then right -> left,  then any remaining left -> right

                let s = 0;

                if (ref.charCodeAt(0) === alt.charCodeAt(0)) {
                  s++;
                  altLength--;
                  lengthOnRef--;
                } // right -> left from end


                while (altLength > 0 && lengthOnRef > 0) {
                  const altIdx = s + altLength - 1;
                  const refIdx = s + lengthOnRef - 1;

                  if (alt.charCodeAt(altIdx) === ref.charCodeAt(refIdx)) {
                    altLength--;
                    lengthOnRef--;
                  } else {
                    break;
                  }
                } // if any remaining, left -> right


                while (altLength > 0 && lengthOnRef > 0) {
                  const altIdx = s;
                  const refIdx = s;

                  if (alt.charCodeAt(altIdx) === ref.charCodeAt(refIdx)) {
                    s++;
                    altLength--;
                    lengthOnRef--;
                  } else {
                    break;
                  }
                }

                const alleleStart = this.pos + s - 1; // -1 for zero based coordinates

                const alleleEnd = alleleStart + lengthOnRef; // insertions have zero length on ref, but we give them 1

                this.start = this.start === undefined ? alleleStart : Math.min(this.start, alleleStart);
                this.end = this.end === undefined ? alleleEnd : Math.max(this.end, alleleEnd);
              }
            } // Default to single base representation @ position for variant types not otherwise handled


            if (this.start === undefined) {
              this.start = this.pos - 1;
              this.end = this.pos;
            }
          }
        }
      }

      popupData(genomicLocation, genomeId) {
        var self = this,
            fields,
            gt;
        const posString = this.end === this.pos ? this.pos : `${this.pos}-${this.end}`;
        fields = [{
          name: "Chr",
          value: this.chr
        }, {
          name: "Pos",
          value: posString
        }, {
          name: "Names",
          value: this.names ? this.names : ""
        }, {
          name: "Ref",
          value: this.referenceBases
        }, {
          name: "Alt",
          value: this.alternateBases.replace("<", "&lt;")
        }, {
          name: "Qual",
          value: this.quality
        }, {
          name: "Filter",
          value: this.filter
        }];

        if ("SNP" === this.type) {
          let ref = this.referenceBases;

          if (ref.length === 1) {
            let altArray = this.alternateBases.split(",");

            for (let alt of altArray) {
              if (alt.length === 1) {
                let l = TrackBase.getCravatLink(this.chr, this.pos, ref, alt, genomeId);

                if (l) {
                  fields.push("<hr/>");
                  fields.push(l);
                }
              }
            }
          }
        }

        if (this.hasOwnProperty("heterozygosity")) {
          fields.push({
            name: "Heterozygosity",
            value: this.heterozygosity
          });
        }

        if (this.info) {
          fields.push('<hr>');
          Object.keys(this.info).forEach(function (key) {
            fields.push({
              name: key,
              value: arrayToString(self.info[key])
            });
          });
        } // Special case of VCF with a single sample


        if (this.calls && this.calls.length === 1) {
          fields.push('<hr>');
          gt = this.alleles[this.calls[0].genotype[0]] + this.alleles[this.calls[0].genotype[1]];
          fields.push({
            name: "Genotype",
            value: gt
          });
        }

        return fields;
      }

      isRefBlock() {
        return "NONVARIANT" === this.type;
      }

    }

    function getInfoObject(infoStr) {
      var info = {};

      if (infoStr) {
        infoStr.split(';').forEach(function (elem) {
          var element = elem.split('=');
          info[element[0]] = element[1];
        });
      }

      return info;
    }

    function isKnownAlt(alt) {
      for (let i = 0; i < alt.length; i++) {
        if (!knownAltBases.has(alt.charCodeAt(i))) {
          return false;
        }
      }

      return true;
    }

    function determineType(ref, altAlleles) {
      const refLength = ref.length;

      if (altAlleles === undefined) {
        return "UNKNOWN";
      } else if (altAlleles.trim().length === 0 || altAlleles === "<NON_REF>" || altAlleles === "<*>" || altAlleles === ".") {
        return "NONVARIANT";
      } else {
        const alleles = altAlleles.split(",");
        const types = alleles.map(function (a) {
          if (refLength === 1 && a.length === 1) {
            return "SNP";
          } else {
            return "<NON_REF>" === a ? "NONVARIANT" : "OTHER";
          }
        });
        let type = types[0];

        for (let t of types) {
          if (t !== type) {
            return "MIXED";
          }
        }

        return type;
      }
    }

    function arrayToString(value, delim) {
      if (delim === undefined) delim = ",";

      if (!Array.isArray(value)) {
        return value;
      }

      return value.join(delim);
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Parser for VCF files.
     */

    class VcfParser {
      construtor() {}

      async parseHeader(dataWrapper) {
        const header = {}; // First line must be file format

        let line = await dataWrapper.nextLine();

        if (line.startsWith("##fileformat")) {
          header.version = line.substr(13);
        } else {
          throw new Error("Invalid VCF file: missing fileformat line");
        }

        while ((line = await dataWrapper.nextLine()) !== undefined) {
          if (line.startsWith("#")) {
            let id;
            const values = {};

            if (line.startsWith("##")) {
              if (line.startsWith("##INFO") || line.startsWith("##FILTER") || line.startsWith("##FORMAT")) {
                const ltIdx = line.indexOf("<");
                const gtIdx = line.lastIndexOf(">");

                if (!(ltIdx > 2 && gtIdx > 0)) {
                  console.log("Malformed VCF header line: " + line);
                  continue;
                }

                const type = line.substring(2, ltIdx - 1);
                if (!header[type]) header[type] = {}; //##INFO=<ID=AF,Number=A,Type=Float,Description="Allele frequency based on Flow Evaluator observation counts">
                // ##FILTER=<ID=NOCALL,Description="Generic filter. Filtering details stored in FR info tag.">
                // ##FORMAT=<ID=AF,Number=A,Type=Float,Description="Allele frequency based on Flow Evaluator observation counts">

                const tokens = splitStringRespectingQuotes(line.substring(ltIdx + 1, gtIdx - 1), ",");

                for (let token of tokens) {
                  var kv = token.split("=");

                  if (kv.length > 1) {
                    if (kv[0] === "ID") {
                      id = kv[1];
                    } else {
                      values[kv[0]] = kv[1];
                    }
                  }
                }

                if (id) {
                  header[type][id] = values;
                }
              }
            } else if (line.startsWith("#CHROM")) {
              const tokens = line.split("\t");

              if (tokens.length > 8) {
                // call set names -- use column index for id
                header.callSets = [];

                for (let j = 9; j < tokens.length; j++) {
                  header.callSets.push({
                    id: j,
                    name: tokens[j]
                  });
                }
              }
            }
          } else {
            break;
          }
        }

        this.header = header; // Will need to intrepret genotypes and info field

        return header;
      }
      /**
       * Parse data as a collection of Variant objects.
       *
       * @param data
       * @returns {Array}
       */


      async parseFeatures(dataWrapper) {
        const allFeatures = [];
        const callSets = this.header.callSets;
        const nExpectedColumns = 8 + (callSets ? callSets.length + 1 : 0);
        let line;

        while ((line = await dataWrapper.nextLine()) !== undefined) {
          if (line && !line.startsWith("#")) {
            const tokens = line.split("\t");

            if (tokens.length === nExpectedColumns) {
              const variant = createVCFVariant(tokens);
              variant.header = this.header; // Keep a pointer to the header to interpret fields for popup text

              allFeatures.push(variant);

              if (tokens.length > 9) {
                // Format
                const callFields = extractCallFields(tokens[8].split(":"));
                variant.calls = {};

                for (let index = 9; index < tokens.length; index++) {
                  const token = tokens[index];
                  var callSet = callSets[index - 9],
                      call = {
                    callSetName: callSet.name,
                    info: {}
                  };
                  variant.calls[callSet.id] = call;
                  token.split(":").forEach(function (callToken, idx) {
                    switch (idx) {
                      case callFields.genotypeIndex:
                        call.genotype = [];
                        callToken.split(/[\|\/]/).forEach(function (s) {
                          call.genotype.push('.' === s ? s : parseInt(s));
                        });
                        break;

                      default:
                        call.info[callFields.fields[idx]] = callToken;
                    }
                  });
                }
              }
            }
          }
        }

        return allFeatures;
      }

    }

    function extractCallFields(tokens) {
      const callFields = {
        genotypeIndex: -1,
        fields: tokens
      };

      for (let i = 0; i < tokens.length; i++) {
        if ("GT" === tokens[i]) {
          callFields.genotypeIndex = i;
        }
      }

      return callFields;
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var check = function (it) {
      return it && it.Math == Math && it;
    }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


    var global$o = // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
    function () {
      return this;
    }() || Function('return this')();

    var FunctionPrototype$1 = Function.prototype;
    var bind = FunctionPrototype$1.bind;
    var call$3 = FunctionPrototype$1.call;
    var callBind = bind && bind.bind(call$3);
    var functionUncurryThis = bind ? function (fn) {
      return fn && callBind(call$3, fn);
    } : function (fn) {
      return fn && function () {
        return call$3.apply(fn, arguments);
      };
    };

    var fails$5 = function (exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };

    // https://tc39.es/ecma262/#sec-iscallable

    var isCallable$c = function (argument) {
      return typeof argument == 'function';
    };

    var global$n = global$o;
    var String$3 = global$n.String;

    var tryToString$2 = function (argument) {
      try {
        return String$3(argument);
      } catch (error) {
        return 'Object';
      }
    };

    var global$m = global$o;
    var isCallable$b = isCallable$c;
    var tryToString$1 = tryToString$2;
    var TypeError$9 = global$m.TypeError; // `Assert: IsCallable(argument) is true`

    var aCallable$2 = function (argument) {
      if (isCallable$b(argument)) return argument;
      throw TypeError$9(tryToString$1(argument) + ' is not a function');
    };

    var uncurryThis$8 = functionUncurryThis;
    var arraySlice$1 = uncurryThis$8([].slice);

    var arraySlice = arraySlice$1;
    var floor = Math.floor;

    var mergeSort = function (array, comparefn) {
      var length = array.length;
      var middle = floor(length / 2);
      return length < 8 ? insertionSort(array, comparefn) : merge(array, mergeSort(arraySlice(array, 0, middle), comparefn), mergeSort(arraySlice(array, middle), comparefn), comparefn);
    };

    var insertionSort = function (array, comparefn) {
      var length = array.length;
      var i = 1;
      var element, j;

      while (i < length) {
        j = i;
        element = array[i];

        while (j && comparefn(array[j - 1], element) > 0) {
          array[j] = array[--j];
        }

        if (j !== i++) array[j] = element;
      }

      return array;
    };

    var merge = function (array, left, right, comparefn) {
      var llength = left.length;
      var rlength = right.length;
      var lindex = 0;
      var rindex = 0;

      while (lindex < llength || rindex < rlength) {
        array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
      }

      return array;
    };

    var arraySort = mergeSort;

    var arrayBufferNative = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

    var fails$4 = fails$5; // Detect IE8's incomplete defineProperty implementation

    var descriptors = !fails$4(function () {
      // eslint-disable-next-line es/no-object-defineproperty -- required for testing
      return Object.defineProperty({}, 1, {
        get: function () {
          return 7;
        }
      })[1] != 7;
    });

    var isCallable$a = isCallable$c;

    var isObject$6 = function (it) {
      return typeof it == 'object' ? it !== null : isCallable$a(it);
    };

    var global$l = global$o;
    var TypeError$8 = global$l.TypeError; // `RequireObjectCoercible` abstract operation
    // https://tc39.es/ecma262/#sec-requireobjectcoercible

    var requireObjectCoercible$1 = function (it) {
      if (it == undefined) throw TypeError$8("Can't call method on " + it);
      return it;
    };

    var global$k = global$o;
    var requireObjectCoercible = requireObjectCoercible$1;
    var Object$4 = global$k.Object; // `ToObject` abstract operation
    // https://tc39.es/ecma262/#sec-toobject

    var toObject$2 = function (argument) {
      return Object$4(requireObjectCoercible(argument));
    };

    var uncurryThis$7 = functionUncurryThis;
    var toObject$1 = toObject$2;
    var hasOwnProperty = uncurryThis$7({}.hasOwnProperty); // `HasOwnProperty` abstract operation
    // https://tc39.es/ecma262/#sec-hasownproperty

    var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
      return hasOwnProperty(toObject$1(it), key);
    };

    var shared$3 = {exports: {}};

    var global$j = global$o; // eslint-disable-next-line es/no-object-defineproperty -- safe

    var defineProperty$1 = Object.defineProperty;

    var setGlobal$2 = function (key, value) {
      try {
        defineProperty$1(global$j, key, {
          value: value,
          configurable: true,
          writable: true
        });
      } catch (error) {
        global$j[key] = value;
      }

      return value;
    };

    var global$i = global$o;
    var setGlobal$1 = setGlobal$2;
    var SHARED = '__core-js_shared__';
    var store$3 = global$i[SHARED] || setGlobal$1(SHARED, {});
    var sharedStore = store$3;

    var store$2 = sharedStore;
    (shared$3.exports = function (key, value) {
      return store$2[key] || (store$2[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: '3.19.1',
      mode: 'global',
      copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
    });

    var uncurryThis$6 = functionUncurryThis;
    var id = 0;
    var postfix = Math.random();
    var toString$1 = uncurryThis$6(1.0.toString);

    var uid$3 = function (key) {
      return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$1(++id + postfix, 36);
    };

    var global$h = global$o;
    var isCallable$9 = isCallable$c;

    var aFunction = function (argument) {
      return isCallable$9(argument) ? argument : undefined;
    };

    var getBuiltIn$2 = function (namespace, method) {
      return arguments.length < 2 ? aFunction(global$h[namespace]) : global$h[namespace] && global$h[namespace][method];
    };

    var getBuiltIn$1 = getBuiltIn$2;
    var engineUserAgent = getBuiltIn$1('navigator', 'userAgent') || '';

    var global$g = global$o;
    var userAgent$2 = engineUserAgent;
    var process$1 = global$g.process;
    var Deno = global$g.Deno;
    var versions = process$1 && process$1.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match, version$1;

    if (v8) {
      match = v8.split('.'); // in old Chrome, versions of V8 isn't V8 = Chrome / 10
      // but their correct versions are not interesting for us

      version$1 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    } // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
    // so check `userAgent` even if `.v8` exists, but 0


    if (!version$1 && userAgent$2) {
      match = userAgent$2.match(/Edge\/(\d+)/);

      if (!match || match[1] >= 74) {
        match = userAgent$2.match(/Chrome\/(\d+)/);
        if (match) version$1 = +match[1];
      }
    }

    var engineV8Version = version$1;

    /* eslint-disable es/no-symbol -- required for testing */
    var V8_VERSION = engineV8Version;
    var fails$3 = fails$5; // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing

    var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$3(function () {
      var symbol = Symbol(); // Chrome 38 Symbol has incorrect toString conversion
      // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances

      return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });

    /* eslint-disable es/no-symbol -- required for testing */
    var NATIVE_SYMBOL$1 = nativeSymbol;
    var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == 'symbol';

    var global$f = global$o;
    var shared$2 = shared$3.exports;
    var hasOwn$5 = hasOwnProperty_1;
    var uid$2 = uid$3;
    var NATIVE_SYMBOL = nativeSymbol;
    var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
    var WellKnownSymbolsStore = shared$2('wks');
    var Symbol$1 = global$f.Symbol;
    var symbolFor = Symbol$1 && Symbol$1['for'];
    var createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;

    var wellKnownSymbol$4 = function (name) {
      if (!hasOwn$5(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
        var description = 'Symbol.' + name;

        if (NATIVE_SYMBOL && hasOwn$5(Symbol$1, name)) {
          WellKnownSymbolsStore[name] = Symbol$1[name];
        } else if (USE_SYMBOL_AS_UID$1 && symbolFor) {
          WellKnownSymbolsStore[name] = symbolFor(description);
        } else {
          WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
        }
      }

      return WellKnownSymbolsStore[name];
    };

    var wellKnownSymbol$3 = wellKnownSymbol$4;
    var TO_STRING_TAG$2 = wellKnownSymbol$3('toStringTag');
    var test = {};
    test[TO_STRING_TAG$2] = 'z';
    var toStringTagSupport = String(test) === '[object z]';

    var uncurryThis$5 = functionUncurryThis;
    var toString = uncurryThis$5({}.toString);
    var stringSlice = uncurryThis$5(''.slice);

    var classofRaw$1 = function (it) {
      return stringSlice(toString(it), 8, -1);
    };

    var global$e = global$o;
    var TO_STRING_TAG_SUPPORT = toStringTagSupport;
    var isCallable$8 = isCallable$c;
    var classofRaw = classofRaw$1;
    var wellKnownSymbol$2 = wellKnownSymbol$4;
    var TO_STRING_TAG$1 = wellKnownSymbol$2('toStringTag');
    var Object$3 = global$e.Object; // ES3 wrong here

    var CORRECT_ARGUMENTS = classofRaw(function () {
      return arguments;
    }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

    var tryGet = function (it, key) {
      try {
        return it[key];
      } catch (error) {
        /* empty */
      }
    }; // getting tag from ES6+ `Object.prototype.toString`


    var classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
      var O, tag, result;
      return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
      : typeof (tag = tryGet(O = Object$3(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && isCallable$8(O.callee) ? 'Arguments' : result;
    };

    var objectDefineProperty = {};

    var global$d = global$o;
    var isObject$5 = isObject$6;
    var document$1 = global$d.document; // typeof document.createElement is 'object' in old IE

    var EXISTS$1 = isObject$5(document$1) && isObject$5(document$1.createElement);

    var documentCreateElement = function (it) {
      return EXISTS$1 ? document$1.createElement(it) : {};
    };

    var DESCRIPTORS$4 = descriptors;
    var fails$2 = fails$5;
    var createElement = documentCreateElement; // Thank's IE8 for his funny defineProperty

    var ie8DomDefine = !DESCRIPTORS$4 && !fails$2(function () {
      // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
      return Object.defineProperty(createElement('div'), 'a', {
        get: function () {
          return 7;
        }
      }).a != 7;
    });

    var global$c = global$o;
    var isObject$4 = isObject$6;
    var String$2 = global$c.String;
    var TypeError$7 = global$c.TypeError; // `Assert: Type(argument) is Object`

    var anObject$2 = function (argument) {
      if (isObject$4(argument)) return argument;
      throw TypeError$7(String$2(argument) + ' is not an object');
    };

    var call$2 = Function.prototype.call;
    var functionCall = call$2.bind ? call$2.bind(call$2) : function () {
      return call$2.apply(call$2, arguments);
    };

    var uncurryThis$4 = functionUncurryThis;
    var objectIsPrototypeOf = uncurryThis$4({}.isPrototypeOf);

    var global$b = global$o;
    var getBuiltIn = getBuiltIn$2;
    var isCallable$7 = isCallable$c;
    var isPrototypeOf$1 = objectIsPrototypeOf;
    var USE_SYMBOL_AS_UID = useSymbolAsUid;
    var Object$2 = global$b.Object;
    var isSymbol$2 = USE_SYMBOL_AS_UID ? function (it) {
      return typeof it == 'symbol';
    } : function (it) {
      var $Symbol = getBuiltIn('Symbol');
      return isCallable$7($Symbol) && isPrototypeOf$1($Symbol.prototype, Object$2(it));
    };

    var aCallable$1 = aCallable$2; // `GetMethod` abstract operation
    // https://tc39.es/ecma262/#sec-getmethod

    var getMethod$1 = function (V, P) {
      var func = V[P];
      return func == null ? undefined : aCallable$1(func);
    };

    var global$a = global$o;
    var call$1 = functionCall;
    var isCallable$6 = isCallable$c;
    var isObject$3 = isObject$6;
    var TypeError$6 = global$a.TypeError; // `OrdinaryToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-ordinarytoprimitive

    var ordinaryToPrimitive$1 = function (input, pref) {
      var fn, val;
      if (pref === 'string' && isCallable$6(fn = input.toString) && !isObject$3(val = call$1(fn, input))) return val;
      if (isCallable$6(fn = input.valueOf) && !isObject$3(val = call$1(fn, input))) return val;
      if (pref !== 'string' && isCallable$6(fn = input.toString) && !isObject$3(val = call$1(fn, input))) return val;
      throw TypeError$6("Can't convert object to primitive value");
    };

    var global$9 = global$o;
    var call = functionCall;
    var isObject$2 = isObject$6;
    var isSymbol$1 = isSymbol$2;
    var getMethod = getMethod$1;
    var ordinaryToPrimitive = ordinaryToPrimitive$1;
    var wellKnownSymbol$1 = wellKnownSymbol$4;
    var TypeError$5 = global$9.TypeError;
    var TO_PRIMITIVE = wellKnownSymbol$1('toPrimitive'); // `ToPrimitive` abstract operation
    // https://tc39.es/ecma262/#sec-toprimitive

    var toPrimitive$1 = function (input, pref) {
      if (!isObject$2(input) || isSymbol$1(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;

      if (exoticToPrim) {
        if (pref === undefined) pref = 'default';
        result = call(exoticToPrim, input, pref);
        if (!isObject$2(result) || isSymbol$1(result)) return result;
        throw TypeError$5("Can't convert object to primitive value");
      }

      if (pref === undefined) pref = 'number';
      return ordinaryToPrimitive(input, pref);
    };

    var toPrimitive = toPrimitive$1;
    var isSymbol = isSymbol$2; // `ToPropertyKey` abstract operation
    // https://tc39.es/ecma262/#sec-topropertykey

    var toPropertyKey$1 = function (argument) {
      var key = toPrimitive(argument, 'string');
      return isSymbol(key) ? key : key + '';
    };

    var global$8 = global$o;
    var DESCRIPTORS$3 = descriptors;
    var IE8_DOM_DEFINE = ie8DomDefine;
    var anObject$1 = anObject$2;
    var toPropertyKey = toPropertyKey$1;
    var TypeError$4 = global$8.TypeError; // eslint-disable-next-line es/no-object-defineproperty -- safe

    var $defineProperty = Object.defineProperty; // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty

    objectDefineProperty.f = DESCRIPTORS$3 ? $defineProperty : function defineProperty(O, P, Attributes) {
      anObject$1(O);
      P = toPropertyKey(P);
      anObject$1(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {
        /* empty */
      }
      if ('get' in Attributes || 'set' in Attributes) throw TypeError$4('Accessors not supported');
      if ('value' in Attributes) O[P] = Attributes.value;
      return O;
    };

    var createPropertyDescriptor$1 = function (bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      };
    };

    var DESCRIPTORS$2 = descriptors;
    var definePropertyModule = objectDefineProperty;
    var createPropertyDescriptor = createPropertyDescriptor$1;
    var createNonEnumerableProperty$3 = DESCRIPTORS$2 ? function (object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function (object, key, value) {
      object[key] = value;
      return object;
    };

    var redefine$1 = {exports: {}};

    var uncurryThis$3 = functionUncurryThis;
    var isCallable$5 = isCallable$c;
    var store$1 = sharedStore;
    var functionToString = uncurryThis$3(Function.toString); // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper

    if (!isCallable$5(store$1.inspectSource)) {
      store$1.inspectSource = function (it) {
        return functionToString(it);
      };
    }

    var inspectSource$2 = store$1.inspectSource;

    var global$7 = global$o;
    var isCallable$4 = isCallable$c;
    var inspectSource$1 = inspectSource$2;
    var WeakMap$1 = global$7.WeakMap;
    var nativeWeakMap = isCallable$4(WeakMap$1) && /native code/.test(inspectSource$1(WeakMap$1));

    var shared$1 = shared$3.exports;
    var uid$1 = uid$3;
    var keys = shared$1('keys');

    var sharedKey$2 = function (key) {
      return keys[key] || (keys[key] = uid$1(key));
    };

    var hiddenKeys$1 = {};

    var NATIVE_WEAK_MAP = nativeWeakMap;
    var global$6 = global$o;
    var uncurryThis$2 = functionUncurryThis;
    var isObject$1 = isObject$6;
    var createNonEnumerableProperty$2 = createNonEnumerableProperty$3;
    var hasOwn$4 = hasOwnProperty_1;
    var shared = sharedStore;
    var sharedKey$1 = sharedKey$2;
    var hiddenKeys = hiddenKeys$1;
    var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
    var TypeError$3 = global$6.TypeError;
    var WeakMap = global$6.WeakMap;
    var set, get, has;

    var enforce = function (it) {
      return has(it) ? get(it) : set(it, {});
    };

    var getterFor = function (TYPE) {
      return function (it) {
        var state;

        if (!isObject$1(it) || (state = get(it)).type !== TYPE) {
          throw TypeError$3('Incompatible receiver, ' + TYPE + ' required');
        }

        return state;
      };
    };

    if (NATIVE_WEAK_MAP || shared.state) {
      var store = shared.state || (shared.state = new WeakMap());
      var wmget = uncurryThis$2(store.get);
      var wmhas = uncurryThis$2(store.has);
      var wmset = uncurryThis$2(store.set);

      set = function (it, metadata) {
        if (wmhas(store, it)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        wmset(store, it, metadata);
        return metadata;
      };

      get = function (it) {
        return wmget(store, it) || {};
      };

      has = function (it) {
        return wmhas(store, it);
      };
    } else {
      var STATE = sharedKey$1('state');
      hiddenKeys[STATE] = true;

      set = function (it, metadata) {
        if (hasOwn$4(it, STATE)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty$2(it, STATE, metadata);
        return metadata;
      };

      get = function (it) {
        return hasOwn$4(it, STATE) ? it[STATE] : {};
      };

      has = function (it) {
        return hasOwn$4(it, STATE);
      };
    }

    var internalState = {
      set: set,
      get: get,
      has: has,
      enforce: enforce,
      getterFor: getterFor
    };

    var DESCRIPTORS$1 = descriptors;
    var hasOwn$3 = hasOwnProperty_1;
    var FunctionPrototype = Function.prototype; // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe

    var getDescriptor = DESCRIPTORS$1 && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn$3(FunctionPrototype, 'name'); // additional protection from minified / mangled / dropped function names

    var PROPER = EXISTS && function something() {
      /* empty */
    }.name === 'something';

    var CONFIGURABLE = EXISTS && (!DESCRIPTORS$1 || DESCRIPTORS$1 && getDescriptor(FunctionPrototype, 'name').configurable);
    var functionName = {
      EXISTS: EXISTS,
      PROPER: PROPER,
      CONFIGURABLE: CONFIGURABLE
    };

    var global$5 = global$o;
    var isCallable$3 = isCallable$c;
    var hasOwn$2 = hasOwnProperty_1;
    var createNonEnumerableProperty$1 = createNonEnumerableProperty$3;
    var setGlobal = setGlobal$2;
    var inspectSource = inspectSource$2;
    var InternalStateModule = internalState;
    var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
    var getInternalState = InternalStateModule.get;
    var enforceInternalState = InternalStateModule.enforce;
    var TEMPLATE = String(String).split('String');
    (redefine$1.exports = function (O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;
      var name = options && options.name !== undefined ? options.name : key;
      var state;

      if (isCallable$3(value)) {
        if (String(name).slice(0, 7) === 'Symbol(') {
          name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
        }

        if (!hasOwn$2(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
          createNonEnumerableProperty$1(value, 'name', name);
        }

        state = enforceInternalState(value);

        if (!state.source) {
          state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
        }
      }

      if (O === global$5) {
        if (simple) O[key] = value;else setGlobal(key, value);
        return;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }

      if (simple) O[key] = value;else createNonEnumerableProperty$1(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
    })(Function.prototype, 'toString', function toString() {
      return isCallable$3(this) && getInternalState(this).source || inspectSource(this);
    });

    var fails$1 = fails$5;
    var correctPrototypeGetter = !fails$1(function () {
      function F() {
        /* empty */
      }

      F.prototype.constructor = null; // eslint-disable-next-line es/no-object-getprototypeof -- required for testing

      return Object.getPrototypeOf(new F()) !== F.prototype;
    });

    var global$4 = global$o;
    var hasOwn$1 = hasOwnProperty_1;
    var isCallable$2 = isCallable$c;
    var toObject = toObject$2;
    var sharedKey = sharedKey$2;
    var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
    var IE_PROTO = sharedKey('IE_PROTO');
    var Object$1 = global$4.Object;
    var ObjectPrototype$1 = Object$1.prototype; // `Object.getPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.getprototypeof

    var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object$1.getPrototypeOf : function (O) {
      var object = toObject(O);
      if (hasOwn$1(object, IE_PROTO)) return object[IE_PROTO];
      var constructor = object.constructor;

      if (isCallable$2(constructor) && object instanceof constructor) {
        return constructor.prototype;
      }

      return object instanceof Object$1 ? ObjectPrototype$1 : null;
    };

    var global$3 = global$o;
    var isCallable$1 = isCallable$c;
    var String$1 = global$3.String;
    var TypeError$2 = global$3.TypeError;

    var aPossiblePrototype$1 = function (argument) {
      if (typeof argument == 'object' || isCallable$1(argument)) return argument;
      throw TypeError$2("Can't set " + String$1(argument) + ' as a prototype');
    };

    /* eslint-disable no-proto -- safe */
    var uncurryThis$1 = functionUncurryThis;
    var anObject = anObject$2;
    var aPossiblePrototype = aPossiblePrototype$1; // `Object.setPrototypeOf` method
    // https://tc39.es/ecma262/#sec-object.setprototypeof
    // Works with __proto__ only. Old v8 can't work with null proto objects.
    // eslint-disable-next-line es/no-object-setprototypeof -- safe

    var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;

      try {
        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
        setter = uncurryThis$1(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
        setter(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
        /* empty */
      }

      return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter(O, proto);else O.__proto__ = proto;
        return O;
      };
    }() : undefined);

    var NATIVE_ARRAY_BUFFER = arrayBufferNative;
    var DESCRIPTORS = descriptors;
    var global$2 = global$o;
    var isCallable = isCallable$c;
    var isObject = isObject$6;
    var hasOwn = hasOwnProperty_1;
    var classof = classof$1;
    var tryToString = tryToString$2;
    var createNonEnumerableProperty = createNonEnumerableProperty$3;
    var redefine = redefine$1.exports;
    var defineProperty = objectDefineProperty.f;
    var isPrototypeOf = objectIsPrototypeOf;
    var getPrototypeOf = objectGetPrototypeOf;
    var setPrototypeOf = objectSetPrototypeOf;
    var wellKnownSymbol = wellKnownSymbol$4;
    var uid = uid$3;
    var Int8Array = global$2.Int8Array;
    var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
    var Uint8ClampedArray = global$2.Uint8ClampedArray;
    var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
    var TypedArray = Int8Array && getPrototypeOf(Int8Array);
    var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
    var ObjectPrototype = Object.prototype;
    var TypeError$1 = global$2.TypeError;
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
    var TYPED_ARRAY_CONSTRUCTOR = uid('TYPED_ARRAY_CONSTRUCTOR'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

    var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global$2.opera) !== 'Opera';
    var TYPED_ARRAY_TAG_REQIRED = false;
    var NAME, Constructor, Prototype;
    var TypedArrayConstructorsList = {
      Int8Array: 1,
      Uint8Array: 1,
      Uint8ClampedArray: 1,
      Int16Array: 2,
      Uint16Array: 2,
      Int32Array: 4,
      Uint32Array: 4,
      Float32Array: 4,
      Float64Array: 8
    };
    var BigIntArrayConstructorsList = {
      BigInt64Array: 8,
      BigUint64Array: 8
    };

    var isView = function isView(it) {
      if (!isObject(it)) return false;
      var klass = classof(it);
      return klass === 'DataView' || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
    };

    var isTypedArray = function (it) {
      if (!isObject(it)) return false;
      var klass = classof(it);
      return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
    };

    var aTypedArray$1 = function (it) {
      if (isTypedArray(it)) return it;
      throw TypeError$1('Target is not a typed array');
    };

    var aTypedArrayConstructor = function (C) {
      if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
      throw TypeError$1(tryToString(C) + ' is not a typed array constructor');
    };

    var exportTypedArrayMethod$1 = function (KEY, property, forced) {
      if (!DESCRIPTORS) return;
      if (forced) for (var ARRAY in TypedArrayConstructorsList) {
        var TypedArrayConstructor = global$2[ARRAY];
        if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
          delete TypedArrayConstructor.prototype[KEY];
        } catch (error) {
          /* empty */
        }
      }

      if (!TypedArrayPrototype[KEY] || forced) {
        redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
      }
    };

    var exportTypedArrayStaticMethod = function (KEY, property, forced) {
      var ARRAY, TypedArrayConstructor;
      if (!DESCRIPTORS) return;

      if (setPrototypeOf) {
        if (forced) for (ARRAY in TypedArrayConstructorsList) {
          TypedArrayConstructor = global$2[ARRAY];
          if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
            delete TypedArrayConstructor[KEY];
          } catch (error) {
            /* empty */
          }
        }

        if (!TypedArray[KEY] || forced) {
          // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
          try {
            return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
          } catch (error) {
            /* empty */
          }
        } else return;
      }

      for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = global$2[ARRAY];

        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
          redefine(TypedArrayConstructor, KEY, property);
        }
      }
    };

    for (NAME in TypedArrayConstructorsList) {
      Constructor = global$2[NAME];
      Prototype = Constructor && Constructor.prototype;
      if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);else NATIVE_ARRAY_BUFFER_VIEWS = false;
    }

    for (NAME in BigIntArrayConstructorsList) {
      Constructor = global$2[NAME];
      Prototype = Constructor && Constructor.prototype;
      if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
    } // WebKit bug - typed arrays constructors prototype is Object.prototype


    if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
      // eslint-disable-next-line no-shadow -- safe
      TypedArray = function TypedArray() {
        throw TypeError$1('Incorrect invocation');
      };

      if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
        if (global$2[NAME]) setPrototypeOf(global$2[NAME], TypedArray);
      }
    }

    if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
      TypedArrayPrototype = TypedArray.prototype;
      if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
        if (global$2[NAME]) setPrototypeOf(global$2[NAME].prototype, TypedArrayPrototype);
      }
    } // WebKit bug - one more object in Uint8ClampedArray prototype chain


    if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
      setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
    }

    if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
      TYPED_ARRAY_TAG_REQIRED = true;
      defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
        get: function () {
          return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
        }
      });

      for (NAME in TypedArrayConstructorsList) if (global$2[NAME]) {
        createNonEnumerableProperty(global$2[NAME], TYPED_ARRAY_TAG, NAME);
      }
    }

    var arrayBufferViewCore = {
      NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
      TYPED_ARRAY_CONSTRUCTOR: TYPED_ARRAY_CONSTRUCTOR,
      TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
      aTypedArray: aTypedArray$1,
      aTypedArrayConstructor: aTypedArrayConstructor,
      exportTypedArrayMethod: exportTypedArrayMethod$1,
      exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
      isView: isView,
      isTypedArray: isTypedArray,
      TypedArray: TypedArray,
      TypedArrayPrototype: TypedArrayPrototype
    };

    var userAgent$1 = engineUserAgent;
    var firefox = userAgent$1.match(/firefox\/(\d+)/i);
    var engineFfVersion = !!firefox && +firefox[1];

    var UA = engineUserAgent;
    var engineIsIeOrEdge = /MSIE|Trident/.test(UA);

    var userAgent = engineUserAgent;
    var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
    var engineWebkitVersion = !!webkit && +webkit[1];

    var global$1 = global$o;
    var uncurryThis = functionUncurryThis;
    var fails = fails$5;
    var aCallable = aCallable$2;
    var internalSort = arraySort;
    var ArrayBufferViewCore = arrayBufferViewCore;
    var FF = engineFfVersion;
    var IE_OR_EDGE = engineIsIeOrEdge;
    var V8 = engineV8Version;
    var WEBKIT = engineWebkitVersion;
    var Array$1 = global$1.Array;
    var aTypedArray = ArrayBufferViewCore.aTypedArray;
    var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
    var Uint16Array$1 = global$1.Uint16Array;
    var un$Sort = Uint16Array$1 && uncurryThis(Uint16Array$1.prototype.sort); // WebKit

    var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function () {
      un$Sort(new Uint16Array$1(2), null);
    }) && fails(function () {
      un$Sort(new Uint16Array$1(2), {});
    }));
    var STABLE_SORT = !!un$Sort && !fails(function () {
      // feature detection can be too slow, so check engines versions
      if (V8) return V8 < 74;
      if (FF) return FF < 67;
      if (IE_OR_EDGE) return true;
      if (WEBKIT) return WEBKIT < 602;
      var array = new Uint16Array$1(516);
      var expected = Array$1(516);
      var index, mod;

      for (index = 0; index < 516; index++) {
        mod = index % 4;
        array[index] = 515 - index;
        expected[index] = index - 2 * mod + 3;
      }

      un$Sort(array, function (a, b) {
        return (a / 4 | 0) - (b / 4 | 0);
      });

      for (index = 0; index < 516; index++) {
        if (array[index] !== expected[index]) return true;
      }
    });

    var getSortCompare = function (comparefn) {
      return function (x, y) {
        if (comparefn !== undefined) return +comparefn(x, y) || 0; // eslint-disable-next-line no-self-compare -- NaN check

        if (y !== y) return -1; // eslint-disable-next-line no-self-compare -- NaN check

        if (x !== x) return 1;
        if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
        return x > y;
      };
    }; // `%TypedArray%.prototype.sort` method
    // https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort


    exportTypedArrayMethod('sort', function sort(comparefn) {
      if (comparefn !== undefined) aCallable(comparefn);
      if (STABLE_SORT) return un$Sort(this, comparefn);
      return internalSort(aTypedArray(this), getSortCompare(comparefn));
    }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    // TODO -- big endian?
    class BinaryParser$1 {
      constructor(dataView, littleEndian) {
        this.littleEndian = littleEndian !== undefined ? littleEndian : true;
        this.position = 0;
        this.view = dataView;
        this.length = dataView.byteLength;
      }

      available() {
        return this.length - this.position;
      }

      remLength() {
        return this.length - this.position;
      }

      hasNext() {
        return this.position < this.length - 1;
      }

      getByte() {
        var retValue = this.view.getUint8(this.position, this.littleEndian);
        this.position++;
        return retValue;
      }

      getShort() {
        var retValue = this.view.getInt16(this.position, this.littleEndian);
        this.position += 2;
        return retValue;
      }

      getUShort() {
        // var byte1 = this.getByte(),
        //     byte2 = this.getByte(),
        //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));
        //     return retValue;
        //
        var retValue = this.view.getUint16(this.position, this.littleEndian);
        this.position += 2;
        return retValue;
      }

      getInt() {
        var retValue = this.view.getInt32(this.position, this.littleEndian);
        this.position += 4;
        return retValue;
      }

      getUInt() {
        var retValue = this.view.getUint32(this.position, this.littleEndian);
        this.position += 4;
        return retValue;
      }

      getLong() {
        // DataView doesn't support long. So we'll try manually
        var b = [];
        b[0] = this.view.getUint8(this.position);
        b[1] = this.view.getUint8(this.position + 1);
        b[2] = this.view.getUint8(this.position + 2);
        b[3] = this.view.getUint8(this.position + 3);
        b[4] = this.view.getUint8(this.position + 4);
        b[5] = this.view.getUint8(this.position + 5);
        b[6] = this.view.getUint8(this.position + 6);
        b[7] = this.view.getUint8(this.position + 7);
        var value = 0;

        if (this.littleEndian) {
          for (let i = b.length - 1; i >= 0; i--) {
            value = value * 256 + b[i];
          }
        } else {
          for (let i = 0; i < b.length; i++) {
            value = value * 256 + b[i];
          }
        }

        this.position += 8;
        return value;
      }

      getString(len) {
        var s = "";
        var c;

        while ((c = this.view.getUint8(this.position++)) !== 0) {
          s += String.fromCharCode(c);
          if (len && s.length === len) break;
        }

        return s;
      }

      getFixedLengthString(len) {
        var s = "";
        var i;
        var c;

        for (i = 0; i < len; i++) {
          c = this.view.getUint8(this.position++);

          if (c > 0) {
            s += String.fromCharCode(c);
          }
        }

        return s;
      }

      getFixedLengthTrimmedString(len) {
        var s = "";
        var i;
        var c;

        for (i = 0; i < len; i++) {
          c = this.view.getUint8(this.position++);

          if (c > 32) {
            s += String.fromCharCode(c);
          }
        }

        return s;
      }

      getFloat() {
        var retValue = this.view.getFloat32(this.position, this.littleEndian);
        this.position += 4;
        return retValue;
      }

      getDouble() {
        var retValue = this.view.getFloat64(this.position, this.littleEndian);
        this.position += 8;
        return retValue;
      }

      skip(n) {
        this.position += n;
        return this.position;
      }
      /**
       * Return a BGZip (bam and tabix) virtual pointer
       * TODO -- why isn't 8th byte used ?
       * @returns {*}
       */


      getVPointer() {
        var position = this.position,
            offset = this.view.getUint8(position + 1) << 8 | this.view.getUint8(position),
            byte6 = (this.view.getUint8(position + 6) & 0xff) * 0x100000000,
            byte5 = (this.view.getUint8(position + 5) & 0xff) * 0x1000000,
            byte4 = (this.view.getUint8(position + 4) & 0xff) * 0x10000,
            byte3 = (this.view.getUint8(position + 3) & 0xff) * 0x100,
            byte2 = this.view.getUint8(position + 2) & 0xff,
            block = byte6 + byte5 + byte4 + byte3 + byte2;
        this.position += 8; //       if (block == 0 && offset == 0) {
        //           return null;
        //       } else {

        return new VPointer$1(block, offset); //       }
      }

    }

    class VPointer$1 {
      constructor(block, offset) {
        this.block = block;
        this.offset = offset;
      }

      isLessThan(vp) {
        return this.block < vp.block || this.block === vp.block && this.offset < vp.offset;
      }

      isGreaterThan(vp) {
        return this.block > vp.block || this.block === vp.block && this.offset > vp.offset;
      }

      print() {
        return "" + this.block + ":" + this.offset;
      }

    }

    const CSI1_MAGIC$1 = 21582659; // CSI\1

    const CSI2_MAGIC$1 = 38359875; // CSI\2

    async function parseCsiIndex(arrayBuffer, genome) {
      const idx = new CSIIndex();
      idx.parse(arrayBuffer, genome);
      return idx;
    }

    class CSIIndex {
      constructor(tabix) {
        this.tabix = true; // Means whatever is indexed is BGZipped
      }

      parse(arrayBuffer, genome) {
        const parser = new BinaryParser$1(new DataView(arrayBuffer));
        const magic = parser.getInt();

        if (magic !== CSI1_MAGIC$1) {
          if (magic === CSI2_MAGIC$1) {
            throw Error("CSI version 2 is not supported.  Please enter an issue at https://github.com/igvteam/igv.js");
          } else {
            throw Error("Not a CSI index");
          }
        }

        this.indices = [];
        this.blockMin = Number.MAX_SAFE_INTEGER;
        this.blockMax = 0;
        this.sequenceIndexMap = {};
        this.minShift = parser.getInt();
        this.depth = parser.getInt();
        const lAux = parser.getInt();

        if (lAux >= 28) {
          // Tabix header parameters aren't used, but they must be read to advance the pointer
          parser.getInt();
          parser.getInt();
          parser.getInt();
          parser.getInt();
          parser.getInt();
          parser.getInt();
          const l_nm = parser.getInt();
          const nameEndPos = parser.position + l_nm;
          let i = 0;

          while (parser.position < nameEndPos) {
            let seq_name = parser.getString(); // Translate to "official" chr name.

            if (genome) {
              seq_name = genome.getChromosomeName(seq_name);
            }

            this.sequenceIndexMap[seq_name] = i;
            i++;
          }
        }

        const MAX_BIN = this.bin_limit() + 1;
        const nref = parser.getInt();

        for (let ref = 0; ref < nref; ref++) {
          const binIndex = [];
          const loffset = [];
          const nbin = parser.getInt();

          for (let b = 0; b < nbin; b++) {
            const binNumber = parser.getInt();
            loffset[binNumber] = parser.getVPointer();

            if (binNumber > MAX_BIN) {
              // This is a psuedo bin, not used but we have to consume the bytes
              parser.getInt(); // # of chunks for this bin

              parser.getVPointer(); // unmapped beg

              parser.getVPointer(); // unmapped end

              parser.getLong();
              parser.getLong();
            } else {
              binIndex[binNumber] = [];
              const nchnk = parser.getInt(); // # of chunks for this bin

              for (let i = 0; i < nchnk; i++) {
                const cs = parser.getVPointer(); //chunk_beg

                const ce = parser.getVPointer(); //chunk_end

                if (cs && ce) {
                  if (cs.block < this.blockMin) {
                    this.blockMin = cs.block; // Block containing first alignment
                  }

                  if (ce.block > this.blockMax) {
                    this.blockMax = ce.block;
                  }

                  binIndex[binNumber].push([cs, ce]);
                }
              }
            }
          }

          if (nbin > 0) {
            this.indices[ref] = {
              binIndex: binIndex,
              loffset: loffset
            };
          }
        }
      }
      /**
       * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.
       *
       * @param refId  the sequence dictionary index of the chromosome
       * @param min  genomic start position
       * @param max  genomic end position
       * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}
       */


      blocksForRange(refId, min, max) {
        const ba = this.indices[refId];

        if (!ba) {
          return [];
        } else {
          const overlappingBins = this.reg2bins(min, max); // List of bin #s that overlap min, max

          if (overlappingBins.length == 0) return [];
          const chunks = []; // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned

          for (let binRange of overlappingBins) {
            for (let bin = binRange[0]; bin <= binRange[1]; bin++) {
              if (ba.binIndex[bin]) {
                const binChunks = ba.binIndex[bin];
                const nchnk = binChunks.length;

                for (let c = 0; c < nchnk; ++c) {
                  const cs = binChunks[c][0];
                  const ce = binChunks[c][1];
                  chunks.push({
                    minv: cs,
                    maxv: ce,
                    bin: bin
                  });
                }
              }
            }
          }

          const lowestOffset = ba.loffset[overlappingBins[0]];
          return optimizeChunks$1(chunks, lowestOffset);
        }
      } // reg2bins implementation adapted from GMOD/tabix-js  https://github.com/GMOD/tabix-js/blob/master/src/csi.ts


      reg2bins(beg, end) {
        beg -= 1; // < convert to 1-based closed

        if (beg < 1) beg = 1;
        if (end > 2 ** 50) end = 2 ** 34; // 17 GiB ought to be enough for anybody

        end -= 1;
        let l = 0;
        let t = 0;
        let s = this.minShift + this.depth * 3;
        const bins = [];

        for (; l <= this.depth; s -= 3, t += 1 << l * 3, l += 1) {
          const b = t + (beg >> s);
          const e = t + (end >> s);
          if (e - b + bins.length > this.maxBinNumber) throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`); //for (let i = b; i <= e; i += 1) bins.push(i)

          bins.push([b, e]);
        }

        return bins;
      } // function reg2bins(beg, end, min_shift, depth) {
      //     let l, t, n, s = min_shift + depth * 3;
      //     const bins = [];
      //     for (--end, l = n = t = 0; l <= depth; s -= 3, t += 1 << l * 3, ++l) {
      //         let b = t + (beg >> s), e = t + (end >> s), i;
      //         for (i = b; i <= e; ++i) bins[n++] = i;
      //     }
      //     return bins;
      // }


      bin_limit() {
        return ((1 << (this.depth + 1) * 3) - 1) / 7;
      }

    }

    function optimizeChunks$1(chunks, lowest) {
      const mergedChunks = [];
      let lastChunk = null;
      if (chunks.length === 0) return chunks;
      chunks.sort(function (c0, c1) {
        const dif = c0.minv.block - c1.minv.block;

        if (dif !== 0) {
          return dif;
        } else {
          return c0.minv.offset - c1.minv.offset;
        }
      });
      chunks.forEach(function (chunk) {
        if (!lowest || chunk.maxv.isGreaterThan(lowest)) {
          if (lastChunk === null) {
            mergedChunks.push(chunk);
            lastChunk = chunk;
          } else {
            if (canMerge$1(lastChunk, chunk)) {
              if (chunk.maxv.isGreaterThan(lastChunk.maxv)) {
                lastChunk.maxv = chunk.maxv;
              }
            } else {
              mergedChunks.push(chunk);
              lastChunk = chunk;
            }
          }
        } else {
          console.log(`skipping chunk ${chunk.minv.block} - ${chunk.maxv.block}`);
        }
      });
      return mergedChunks;
    }

    function canMerge$1(chunk1, chunk2) {
      return chunk2.minv.block - chunk1.maxv.block < 65000 && chunk2.maxv.block - chunk1.minv.block < 5000000; // lastChunk.minv.block === lastChunk.maxv.block &&
      // lastChunk.maxv.block === chunk.minv.block &&
      // chunk.minv.block === chunk.maxv.block
    }

    const BAI_MAGIC$1 = 21578050;
    const TABIX_MAGIC$1 = 21578324;

    async function parseBamIndex(arrayBuffer, genome) {
      return parseIndex(arrayBuffer, false, genome);
    }

    async function parseTabixIndex(arrayBuffer, genome) {
      return parseIndex(arrayBuffer, true, genome);
    }

    async function parseIndex(arrayBuffer, tabix, genome) {
      const indices = [];
      let blockMin = Number.MAX_SAFE_INTEGER;
      let blockMax = 0;
      const parser = new BinaryParser$1(new DataView(arrayBuffer));
      const magic = parser.getInt();
      const sequenceIndexMap = {};

      if (magic === BAI_MAGIC$1 || tabix && magic === TABIX_MAGIC$1) {
        const nref = parser.getInt();

        if (tabix) {
          // Tabix header parameters aren't used, but they must be read to advance the pointer
          parser.getInt();
          parser.getInt();
          parser.getInt();
          parser.getInt();
          parser.getInt();
          parser.getInt();
          parser.getInt();

          for (let i = 0; i < nref; i++) {
            let seq_name = parser.getString(); // Translate to "official" chr name.

            if (genome) {
              seq_name = genome.getChromosomeName(seq_name);
            }

            sequenceIndexMap[seq_name] = i;
          }
        }

        for (let ref = 0; ref < nref; ref++) {
          const binIndex = {};
          const linearIndex = [];
          const nbin = parser.getInt();

          for (let b = 0; b < nbin; b++) {
            const binNumber = parser.getInt();

            if (binNumber === 37450) {
              // This is a psuedo bin, not used but we have to consume the bytes
              parser.getInt(); // # of chunks for this bin

              parser.getVPointer(); // unmapped beg

              parser.getVPointer(); // unmapped end

              parser.getLong();
              parser.getLong();
            } else {
              binIndex[binNumber] = [];
              const nchnk = parser.getInt(); // # of chunks for this bin

              for (let i = 0; i < nchnk; i++) {
                const cs = parser.getVPointer(); //chunk_beg

                const ce = parser.getVPointer(); //chunk_end

                if (cs && ce) {
                  if (cs.block < blockMin) {
                    blockMin = cs.block; // Block containing first alignment
                  }

                  if (ce.block > blockMax) {
                    blockMax = ce.block;
                  }

                  binIndex[binNumber].push([cs, ce]);
                }
              }
            }
          }

          const nintv = parser.getInt();

          for (let i = 0; i < nintv; i++) {
            const cs = parser.getVPointer();
            linearIndex.push(cs); // Might be null
          }

          if (nbin > 0) {
            indices[ref] = {
              binIndex: binIndex,
              linearIndex: linearIndex
            };
          }
        }
      } else {
        throw new Error(indexURL + " is not a " + (tabix ? "tabix" : "bai") + " file");
      }

      return new BamIndex(indices, blockMin, blockMax, sequenceIndexMap, tabix);
    }

    class BamIndex {
      constructor(indices, blockMin, blockMax, sequenceIndexMap, tabix) {
        this.firstAlignmentBlock = blockMin;
        this.lastAlignmentBlock = blockMax;
        this.indices = indices;
        this.sequenceIndexMap = sequenceIndexMap;
        this.tabix = tabix;
      }
      /**
       * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.
       *
       * @param refId  the sequence dictionary index of the chromosome
       * @param min  genomic start position
       * @param max  genomic end position
       * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}
       */


      blocksForRange(refId, min, max) {
        const bam = this;
        const ba = bam.indices[refId];

        if (!ba) {
          return [];
        } else {
          const overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max

          const chunks = []; // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned

          for (let binRange of overlappingBins) {
            for (let bin = binRange[0]; bin <= binRange[1]; bin++) {
              if (ba.binIndex[bin]) {
                const binChunks = ba.binIndex[bin],
                      nchnk = binChunks.length;

                for (let c = 0; c < nchnk; ++c) {
                  const cs = binChunks[c][0];
                  const ce = binChunks[c][1];
                  chunks.push({
                    minv: cs,
                    maxv: ce,
                    bin: bin
                  });
                }
              }
            }
          } // Use the linear index to find minimum file position of chunks that could contain alignments in the region


          const nintv = ba.linearIndex.length;
          let lowest = null;
          const minLin = Math.min(min >> 14, nintv - 1);
          const maxLin = Math.min(max >> 14, nintv - 1);

          for (let i = minLin; i <= maxLin; ++i) {
            const vp = ba.linearIndex[i];

            if (vp) {
              // todo -- I think, but am not sure, that the values in the linear index have to be in increasing order.  So the first non-null should be minimum
              if (!lowest || vp.isLessThan(lowest)) {
                lowest = vp;
              }
            }
          }

          return optimizeChunks(chunks, lowest);
        }
      }

    }

    function optimizeChunks(chunks, lowest) {
      const mergedChunks = [];
      let lastChunk = null;
      if (chunks.length === 0) return chunks;
      chunks.sort(function (c0, c1) {
        const dif = c0.minv.block - c1.minv.block;

        if (dif !== 0) {
          return dif;
        } else {
          return c0.minv.offset - c1.minv.offset;
        }
      });
      chunks.forEach(function (chunk) {
        if (!lowest || chunk.maxv.isGreaterThan(lowest)) {
          if (lastChunk === null) {
            mergedChunks.push(chunk);
            lastChunk = chunk;
          } else {
            if (canMerge(lastChunk, chunk)) {
              if (chunk.maxv.isGreaterThan(lastChunk.maxv)) {
                lastChunk.maxv = chunk.maxv;
              }
            } else {
              mergedChunks.push(chunk);
              lastChunk = chunk;
            }
          }
        } else {
          console.log(`skipping chunk ${chunk.minv.block} - ${chunk.maxv.block}`);
        }
      });
      return mergedChunks;
    }

    function canMerge(chunk1, chunk2) {
      return chunk2.minv.block - chunk1.maxv.block < 65000 && chunk2.maxv.block - chunk1.minv.block < 5000000; // lastChunk.minv.block === lastChunk.maxv.block &&
      // lastChunk.maxv.block === chunk.minv.block &&
      // chunk.minv.block === chunk.maxv.block
    }
    /**
     * Calculate the list of bins that overlap with region [beg, end]
     *
     */


    function reg2bins(beg, end) {
      const list = [];
      if (end >= 1 << 29) end = 1 << 29;
      --end;
      list.push(0);
      list.push([1 + (beg >> 26), 1 + (end >> 26)]);
      list.push([9 + (beg >> 23), 9 + (end >> 23)]);
      list.push([73 + (beg >> 20), 73 + (end >> 20)]);
      list.push([585 + (beg >> 17), 585 + (end >> 17)]);
      list.push([4681 + (beg >> 14), 4681 + (end >> 14)]); // for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) list.push(k);
      // for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) list.push(k);
      // for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) list.push(k);
      // for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) list.push(k);
      // for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) list.push(k);

      return list;
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    async function parseTribbleIndex(arrayBuffer, genome) {
      const index = {};
      const parser = new BinaryParser$1(new DataView(arrayBuffer));
      readHeader(parser);
      let nChrs = parser.getInt();

      while (nChrs-- > 0) {
        // todo -- support interval tree index, we're assuming its a linear index
        const chrIdx = readLinear(parser);
        index[chrIdx.chr] = chrIdx;
      }

      return new TribbleIndex(index);
      /**
       * Read the header file.   Data here is not used in igv.js but we need to read it to advance the pointer.
       * @param parser
       */

      function readHeader(parser) {
        parser.getInt(); //   view._getInt32(offset += 32, true);

        parser.getInt();
        const version = parser.getInt();
        parser.getString();
        parser.getLong();
        parser.getLong();
        parser.getString();
        parser.getInt();

        if (version >= 3) {
          let nProperties = parser.getInt();

          while (nProperties-- > 0) {
            parser.getString();
            parser.getString();
          }
        }
      }

      function readLinear(parser) {
        let chr = parser.getString();

        if (genome) chr = genome.getChromosomeName(chr);
        const binWidth = parser.getInt();
        const nBins = parser.getInt();
        const longestFeature = parser.getInt();
        parser.getInt() > 0;
        parser.getInt(); // note the code below accounts for > 60% of the total time to read an index

        let pos = parser.getLong();
        const blocks = new Array();

        for (let binNumber = 0; binNumber < nBins; binNumber++) {
          const nextPos = parser.getLong();
          blocks.push({
            min: pos,
            max: nextPos
          }); //        {position: pos, size: size});

          pos = nextPos;
        }

        return {
          chr: chr,
          blocks: blocks,
          longestFeature: longestFeature,
          binWidth: binWidth
        };
      }
    }

    class TribbleIndex {
      constructor(chrIndexTable) {
        this.chrIndex = chrIndexTable; // Dictionary of chr -> tribble index
      }
      /**
       * Fetch blocks for a particular genomic range.
       *
       * @param queryChr the sequence dictionary index of the chromosome
       * @param min  genomic start position
       * @param max  genomic end position
       */


      blocksForRange(queryChr, min, max) {
        const chrIdx = this.chrIndex[queryChr];

        if (chrIdx) {
          const blocks = chrIdx.blocks;
          const longestFeature = chrIdx.longestFeature;
          const binWidth = chrIdx.binWidth;
          const adjustedPosition = Math.max(min - longestFeature, 0);
          const startBinNumber = Math.floor(adjustedPosition / binWidth);
          if (startBinNumber >= blocks.length) // are we off the end of the bin list, so return nothing
            return [];else {
            const endBinNumber = Math.min(Math.floor((max - 1) / binWidth), blocks.length - 1); // By definition blocks are adjacent in the file for the liner index.  Combine them into one merged block

            const startPos = blocks[startBinNumber].min;
            const endPos = blocks[endBinNumber].max;
            const size = endPos - startPos;

            if (size === 0) {
              return [];
            } else {
              const mergedBlock = {
                minv: {
                  block: startPos,
                  offset: 0
                },
                maxv: {
                  block: endPos,
                  offset: 0
                }
              };
              return [mergedBlock];
            }
          }
        } else {
          return undefined;
        }
      }

    }

    const CSI1_MAGIC = 21582659; // CSI\1

    const CSI2_MAGIC = 38359875; // CSI\2

    const BAI_MAGIC = 21578050;
    const TABIX_MAGIC = 21578324;
    const TRIBBLE_MAGIC = 1480870228; //  byte[]{'T', 'I', 'D', 'X'};

    /**
     * @param indexURL
     * @param config
     * @param tabix
     *
     */

    async function loadIndex(indexURL, config, genome) {
      let arrayBuffer = await igvxhr.loadArrayBuffer(indexURL, buildOptions$1(config));
      let dv = new DataView(arrayBuffer); // Some indexs are gzipped, specifically tabix, and csi.  Bam (bai) are not.  Tribble is usually not.
      // Check first 2 bytes of file for gzip magic number, and inflate if neccessary

      if (dv.getUint8(0) === 0x1f && dv.getUint8(1) === 0x8b) {
        // gzipped
        const inflate = new Zlib$2.Gunzip(new Uint8Array(arrayBuffer));
        arrayBuffer = inflate.decompress().buffer;
        dv = new DataView(arrayBuffer);
      }

      const magic = dv.getInt32(0, true);

      switch (magic) {
        case BAI_MAGIC:
          return parseBamIndex(arrayBuffer, genome);

        case TABIX_MAGIC:
          return parseTabixIndex(arrayBuffer, genome);

        case CSI1_MAGIC:
          return parseCsiIndex(arrayBuffer, genome);

        case TRIBBLE_MAGIC:
          return parseTribbleIndex(arrayBuffer, genome);

        case CSI2_MAGIC:
          throw Error("CSI version 2 is not supported.");

        default:
          throw Error(`Unrecognized index type: ${indexURL}`);
      }
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     * Author: Jim Robinson
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    function getDataWrapper(data) {
      if (typeof data == 'string' || data instanceof String) {
        return new StringDataWrapper(data);
      } else {
        return new ByteArrayDataWrapper(data);
      }
    } // Data might be a string, or an UInt8Array


    class StringDataWrapper {
      constructor(string) {
        this.data = string;
        this.ptr = 0;
      }

      nextLine() {
        var start = this.ptr,
            idx = this.data.indexOf('\n', start),
            data = this.data;

        if (idx > 0) {
          this.ptr = idx + 1; // Advance pointer for next line

          if (idx > start && data.charAt(idx - 1) === '\r') {
            // Trim CR manually in CR/LF sequence
            return data.substring(start, idx - 1);
          }

          return data.substring(start, idx);
        } else {
          var length = data.length;
          this.ptr = length; // Return undefined only at the very end of the data

          return start >= length ? undefined : data.substring(start);
        }
      }

    }

    class ByteArrayDataWrapper {
      constructor(array) {
        this.data = array;
        this.length = this.data.length;
        this.ptr = 0;
      }

      nextLine() {
        var c, result;
        result = "";
        if (this.ptr >= this.length) return undefined;

        for (var i = this.ptr; i < this.length; i++) {
          c = String.fromCharCode(this.data[i]);
          if (c === '\r') continue;
          if (c === '\n') break;
          result = result + c;
        }

        this.ptr = i + 1;
        return result;
      }

    }

    class BGZipLineReader {
      constructor(config) {
        this.config = config;
        this.filePtr = 0;
        this.bufferPtr = 0;
        this.buffer;
      }

      async nextLine() {
        let result = undefined;

        try {
          while (true) {
            const length = this.buffer ? this.buffer.length : 0;

            while (this.bufferPtr < length) {
              const c = String.fromCharCode(this.buffer[this.bufferPtr++]);
              if (c === '\r') continue;

              if (c === '\n') {
                return result;
              }

              result = result ? result + c : c;
            }

            if (this.eof) {
              return result;
            } else {
              await this.readNextBlock();
            }
          }
        } catch (e) {
          console.warn(e);
          this.eof = true;
          return result;
        }
      }

      async readNextBlock() {
        const bsizeOptions = buildOptions$1(this.config, {
          range: {
            start: this.filePtr,
            size: 26
          }
        });
        const abuffer = await igvxhr.loadArrayBuffer(this.config.url, bsizeOptions);
        const bufferSize = bgzBlockSize(abuffer); //console.log(`next block ${this.filePtr}  ${bufferSize}`);

        if (bufferSize === 0) {
          this.eof = true;
          this.buffer = undefined;
        } else {
          const options = buildOptions$1(this.config, {
            range: {
              start: this.filePtr,
              size: bufferSize
            }
          });
          const data = await igvxhr.loadArrayBuffer(this.config.url, options);

          if (data.byteLength < bufferSize) {
            this.eof = true; // Assumption
          }

          this.buffer = unbgzf(data);
          this.bufferPtr = 0;
          this.filePtr += data.byteLength; //data.byteLength;
        }
      }

    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    const isString$1 = isString$2;
    /**
     * Reader for "bed like" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)
     *
     * @param config
     * @constructor
     */

    class FeatureFileReader {
      constructor(config, genome) {
        var uriParts;
        this.config = config || {};
        this.genome = genome;
        this.indexURL = config.indexURL;
        this.indexed = config.indexed;

        if (isFilePath(this.config.url)) {
          this.filename = this.config.url.name;
        } else if (isString$1(this.config.url) && this.config.url.startsWith('data:')) {
          this.indexed = false; // by definition

          this.dataURI = config.url;
        } else {
          uriParts = parseUri(this.config.url);
          this.filename = config.filename || uriParts.file;
        }

        this.parser = this.getParser(this.config);

        if (this.config.format === "vcf" && !this.config.indexURL) {
          console.warn("Warning: index file not specified.  The entire vcf file will be loaded.");
        }
      }
      /**
       * Return a promise to load features for the genomic interval
       * @param chr
       * @param start
       * @param end
       */


      async readFeatures(chr, start, end) {
        const index = await this.getIndex();

        if (index) {
          this.indexed = true;
          return this.loadFeaturesWithIndex(chr, start, end);
        } else if (this.dataURI) {
          this.indexed = false;
          return this.loadFeaturesFromDataURI();
        } else {
          this.indexed = false;
          return this.loadFeaturesNoIndex();
        }
      }

      async readHeader() {
        if (this.dataURI) {
          this.loadFeaturesFromDataURI(this.dataURI);
          return this.header;
        } else {
          if (this.config.indexURL) {
            const index = await this.getIndex();

            if (!index) {
              // Note - it should be impossible to get here
              throw new Error("Unable to load index: " + this.config.indexURL);
            }

            let dataWrapper;

            if (index.tabix) {
              dataWrapper = new BGZipLineReader(this.config);
            } else {
              // Tribble
              const maxSize = Object.values(index.chrIndex).flatMap(chr => chr.blocks).map(block => block.max).reduce((previous, current) => Math.min(previous, current), Number.MAX_SAFE_INTEGER);
              const options = buildOptions$1(this.config, {
                bgz: index.tabix,
                range: {
                  start: 0,
                  size: maxSize
                }
              });
              const data = await igvxhr.loadString(this.config.url, options);
              dataWrapper = getDataWrapper(data);
            }

            this.header = await this.parser.parseHeader(dataWrapper); // Cache header, might be needed to parse features

            return this.header;
          } else {
            // If this is a non-indexed file we will load all features in advance
            const options = buildOptions$1(this.config);
            const data = await igvxhr.loadString(this.config.url, options);
            let dataWrapper = getDataWrapper(data);
            this.header = await this.parser.parseHeader(dataWrapper); // Reset data wrapper and parse features

            dataWrapper = getDataWrapper(data);
            this.features = await this.parser.parseFeatures(dataWrapper); // cache features

            return this.header;
          }
        }
      }

      getParser(config) {
        switch (config.format) {
          case "vcf":
            return new VcfParser(config);

          case "seg":
            return new SegParser();

          case "gwas":
            return new GWASParser(config);

          case "aed":
            return new AEDParser(config);

          default:
            return new FeatureParser(config);
        }
      }

      async loadFeaturesNoIndex() {
        if (this.features) {
          // An optimization hack for non-indexed files, features are temporarily cached when header is read.
          const tmp = this.features;
          delete this.features;
          return tmp;
        } else {
          const options = buildOptions$1(this.config); // Add oauth token, if any

          const data = await igvxhr.loadString(this.config.url, options);

          if (!this.header) {
            const dataWrapper = getDataWrapper(data);
            this.header = await this.parser.parseHeader(dataWrapper);
          }

          const dataWrapper = getDataWrapper(data);
          const features = await this.parser.parseFeatures(dataWrapper); // <= PARSING DONE HERE

          return features;
        }
      }

      async loadFeaturesWithIndex(chr, start, end) {
        //console.log("Using index"
        const config = this.config;
        const parser = this.parser;
        const tabix = this.index.tabix;
        const refId = tabix ? this.index.sequenceIndexMap[chr] : chr;

        if (refId === undefined) {
          return [];
        }

        const genome = this.genome;
        const blocks = this.index.blocksForRange(refId, start, end);

        if (!blocks || blocks.length === 0) {
          return [];
        } else {
          const allFeatures = [];

          for (let block of blocks) {
            const startPos = block.minv.block;
            const startOffset = block.minv.offset;
            const endOffset = block.maxv.offset;
            let endPos;

            if (tabix) {
              let lastBlockSize = 0;

              if (endOffset > 0) {
                const bsizeOptions = buildOptions$1(config, {
                  range: {
                    start: block.maxv.block,
                    size: 26
                  }
                });
                const abuffer = await igvxhr.loadArrayBuffer(config.url, bsizeOptions);
                lastBlockSize = bgzBlockSize(abuffer);
              }

              endPos = block.maxv.block + lastBlockSize;
            } else {
              endPos = block.maxv.block;
            }

            const options = buildOptions$1(config, {
              range: {
                start: startPos,
                size: endPos - startPos + 1
              }
            });
            let inflated;

            if (tabix) {
              const data = await igvxhr.loadArrayBuffer(config.url, options);
              inflated = unbgzf(data);
            } else {
              inflated = await igvxhr.loadString(config.url, options);
            }

            const slicedData = startOffset ? inflated.slice(startOffset) : inflated;
            const dataWrapper = getDataWrapper(slicedData);
            const slicedFeatures = await parser.parseFeatures(dataWrapper); // Filter features not in requested range.

            let inInterval = false;

            for (let i = 0; i < slicedFeatures.length; i++) {
              const f = slicedFeatures[i];
              const canonicalChromosome = genome ? genome.getChromosomeName(f.chr) : f.chr;

              if (canonicalChromosome !== chr) {
                if (allFeatures.length === 0) {
                  continue; //adjacent chr to the left
                } else {
                  break; //adjacent chr to the right
                }
              }

              if (f.start > end) {
                allFeatures.push(f); // First feature beyond interval

                break;
              }

              if (f.end >= start && f.start <= end) {
                if (!inInterval) {
                  inInterval = true;

                  if (i > 0) {
                    allFeatures.push(slicedFeatures[i - 1]);
                  }
                }

                allFeatures.push(f);
              }
            }
          }

          allFeatures.sort(function (a, b) {
            return a.start - b.start;
          });
          return allFeatures;
        }
      }

      async getIndex() {
        if (this.index || !this.config.indexURL) {
          return this.index;
        } else {
          this.index = await this.loadIndex();
          return this.index;
        }
      }
      /**
       * Return a Promise for the async loaded index
       */


      async loadIndex() {
        const indexURL = this.config.indexURL;
        return loadIndex(indexURL, this.config, this.genome);
      }

      async loadFeaturesFromDataURI() {
        if (this.features) {
          // An optimization hack for non-indexed files, features are temporarily cached when header is read.
          const tmp = this.features;
          delete this.features;
          return tmp;
        } else {
          const plain = decodeDataURI(this.dataURI);
          let dataWrapper = getDataWrapper(plain);
          this.header = await this.parser.parseHeader(dataWrapper);

          if (this.header instanceof String && this.header.startsWith("##gff-version 3")) {
            this.format = 'gff3';
          }

          dataWrapper = getDataWrapper(plain);
          this.features = await this.parser.parseFeatures(dataWrapper);
          return this.features;
        }
      }

    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2016 University of California San Diego
     * Author: Jim Robinson
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Created by jrobinson on 4/7/16.
     */

    const transcriptTypes = new Set(['transcript', 'primary_transcript', 'processed_transcript', 'mRNA', 'mrna']);
    const cdsTypes = new Set(['CDS', 'cds']);
    const codonTypes = new Set(['start_codon', 'stop_codon']);
    const utrTypes = new Set(['5UTR', '3UTR', 'UTR', 'five_prime_UTR', 'three_prime_UTR', "3'-UTR", "5'-UTR"]);
    const exonTypes = new Set(['exon', 'coding-exon']);
    const intronType = 'intron';

    const transcriptModelTypes = new Set();

    for (let cltn of [transcriptTypes, cdsTypes, codonTypes, utrTypes, exonTypes]) {
      for (let t of cltn) {
        transcriptModelTypes.add(t);
      }
    }

    class GFFHelper {
      constructor(options) {
        this.format = options.format;
        this.filterTypes = options.filterTypes === undefined ? new Set(['chromosome']) : new Set(options.filterTypes);
      }

      combineFeatures(features) {
        let combinedFeatures;

        if ("gff3" === this.format) {
          const tmp = this.combineFeaturesById(features);
          combinedFeatures = this.combineFeaturesGFF(tmp);
        } else {
          combinedFeatures = this.combineFeaturesGTF(features);
        }

        combinedFeatures.sort(function (a, b) {
          return a.start - b.start;
        });
        return combinedFeatures;
      }

      combineFeaturesById(features) {
        const combinedFeatures = [];
        const chrIdHash = {};

        for (let f of features) {
          if (f.id === undefined) {
            combinedFeatures.push(f);
          } else {
            let idHash = chrIdHash[f.chr];

            if (!idHash) {
              idHash = {};
              chrIdHash[f.chr] = idHash;
            }

            if (idHash.hasOwnProperty(f.id)) {
              const sf = idHash[f.id];

              if (sf.hasOwnProperty("exons")) {
                sf.start = Math.min(sf.start, f.start);
                sf.end = Math.max(sf.end, f.end);
                sf.exons.push(f);
              } else {
                const cf = {
                  id: f.id,
                  type: f.type,
                  chr: f.chr,
                  strand: f.strand,
                  start: Math.min(f.start, sf.start),
                  end: Math.max(f.end, sf.end),
                  exons: [sf, f]
                };

                if (f.parent && f.parent.trim() !== "") {
                  cf.parent = f.parent;
                }

                idHash[f.id] = cf;
              }
            } else {
              idHash[f.id] = f;
            }
          }
        }

        for (let key of Object.keys(chrIdHash)) {
          const idHash = chrIdHash[key];

          for (let id of Object.keys(idHash)) {
            combinedFeatures.push(idHash[id]);
          }
        }

        return combinedFeatures;
      }

      combineFeaturesGTF(features) {
        const transcripts = Object.create(null);
        const combinedFeatures = [];
        const consumedFeatures = new Set();
        const filterTypes = this.filterTypes;
        features = features.filter(f => filterTypes === undefined || !filterTypes.has(f.type)); // 1. Build dictionary of transcripts

        for (let f of features) {
          if (transcriptTypes.has(f.type)) {
            const transcriptId = f.id;

            if (undefined !== transcriptId) {
              const gffTranscript = new GFFTranscript(f);
              transcripts[transcriptId] = gffTranscript;
              combinedFeatures.push(gffTranscript);
              consumedFeatures.add(f);
            }
          }
        } // Add exons


        for (let f of features) {
          if (exonTypes.has(f.type)) {
            const id = f.id; // transcript_id,  GTF groups all features with the same ID, does not have a parent/child hierarchy

            if (id) {
              let transcript = transcripts[id];

              if (transcript === undefined) {
                transcript = new GFFTranscript(f); // GTF does not require an explicit transcript record

                transcripts[id] = transcript;
                combinedFeatures.push(transcript);
              }

              transcript.addExon(f);
              consumedFeatures.add(f);
            }
          }
        } // Apply CDS and UTR


        for (let f of features) {
          if (cdsTypes.has(f.type) || utrTypes.has(f.type) || codonTypes.has(f.type)) {
            const id = f.id;

            if (id) {
              let transcript = transcripts[id];

              if (transcript === undefined) {
                transcript = new GFFTranscript(f);
                transcripts[id] = transcript;
                combinedFeatures.push(transcript);
              }

              if (utrTypes.has(f.type)) {
                transcript.addUTR(f);
              } else if (cdsTypes.has(f.type)) {
                transcript.addCDS(f);
              } else if (codonTypes.has(f.type)) ;

              consumedFeatures.add(f);
            }
          }
        } // Finish transcripts


        for (let f of combinedFeatures) {
          if (typeof f.finish === "function") {
            f.finish();
          }
        } // Add other features


        const others = features.filter(f => !consumedFeatures.has(f));

        for (let f of others) {
          combinedFeatures.push(f);
        }

        return combinedFeatures;
      }

      combineFeaturesGFF(features) {
        // Build dictionary of genes (optional)
        const genes = features.filter(f => "gene" === f.type);
        const geneMap = Object.create(null);

        for (let g of genes) {
          geneMap[g.id] = g;
        } // 1. Build dictionary of transcripts


        const transcripts = Object.create(null);
        const combinedFeatures = [];
        const consumedFeatures = new Set();
        const filterTypes = this.filterTypes;
        features = features.filter(f => filterTypes === undefined || !filterTypes.has(f.type));

        for (let f of features) {
          if (transcriptTypes.has(f.type)) {
            const transcriptId = f.id; // getAttribute(f.attributeString, "transcript_id", /\s+/);

            if (undefined !== transcriptId) {
              const gffTranscript = new GFFTranscript(f);
              transcripts[transcriptId] = gffTranscript;
              combinedFeatures.push(gffTranscript);
              consumedFeatures.add(f);
              const g = geneMap[f.parent];

              if (g) {
                gffTranscript.gene = geneMap[f.parent];
                consumedFeatures.add(g);
              }
            }
          }
        } // Remove assigned genes
        // Add exons


        for (let f of features) {
          if (exonTypes.has(f.type)) {
            const parents = getParents(f);

            if (parents) {
              for (let id of parents) {
                let transcript = transcripts[id];

                if (transcript !== undefined) {
                  transcript.addExon(f);
                  consumedFeatures.add(f);
                }
              }
            }
          }
        } // Apply CDS and UTR


        for (let f of features) {
          if (cdsTypes.has(f.type) || utrTypes.has(f.type) || codonTypes.has(f.type)) {
            const parents = getParents(f);

            if (parents) {
              for (let id of parents) {
                let transcript = transcripts[id];

                if (transcript !== undefined) {
                  if (utrTypes.has(f.type)) {
                    transcript.addUTR(f);
                  } else if (cdsTypes.has(f.type)) {
                    transcript.addCDS(f);
                  } else if (codonTypes.has(f.type)) ;

                  consumedFeatures.add(f);
                }
              }
            }
          }
        } // Introns are ignored, but are consumed


        const introns = features.filter(f => intronType === f.type);

        for (let i of introns) {
          const parents = getParents(i);

          for (let id of parents) {
            if (transcripts[id]) {
              consumedFeatures.add(i);
              break;
            }
          }
        } // Finish transcripts


        combinedFeatures.forEach(function (f) {
          if (typeof f.finish === "function") {
            f.finish();
          }
        }); // Add other features

        const others = features.filter(f => !consumedFeatures.has(f));

        for (let f of others) {
          combinedFeatures.push(f);
        }

        return combinedFeatures;

        function getParents(f) {
          if (f.parent && f.parent.trim() !== "") {
            return f.parent.trim().split(",");
          } else {
            return null;
          }
        }
      }

    }

    var GFFTranscript = function (feature) {
      Object.assign(this, feature);
      this.exons = [];
    };

    GFFTranscript.prototype.addExon = function (feature) {
      this.exons.push(feature); // Expand feature --  for transcripts not explicitly represented in the file

      this.start = Math.min(this.start, feature.start);
      this.end = Math.max(this.end, feature.end);
    };

    GFFTranscript.prototype.addCDS = function (cds) {
      let exon;
      const exons = this.exons; // Find exon containing CDS

      for (let i = 0; i < exons.length; i++) {
        if (exons[i].start <= cds.start && exons[i].end >= cds.end) {
          exon = exons[i];
          break;
        }
      }

      if (exon) {
        exon.cdStart = exon.cdStart ? Math.min(cds.start, exon.cdStart) : cds.start;
        exon.cdEnd = exon.cdEnd ? Math.max(cds.end, exon.cdEnd) : cds.end;

        if (!exon.children) {
          exon.children = [];
        }

        exon.children.push(cds);
      } else {
        cds.cdStart = cds.start;
        cds.cdEnd = cds.end;
        exons.push(cds);
      } // Expand feature --  for transcripts not explicitly represented in the file (gtf files)


      this.start = Math.min(this.start, cds.start);
      this.end = Math.max(this.end, cds.end);
      this.cdStart = this.cdStart ? Math.min(cds.start, this.cdStart) : cds.start;
      this.cdEnd = this.cdEnd ? Math.max(cds.end, this.cdEnd) : cds.end;
    };

    GFFTranscript.prototype.addUTR = function (utr) {
      let exon;
      const exons = this.exons; // Find exon containing CDS

      for (let i = 0; i < exons.length; i++) {
        if (exons[i].start <= utr.start && exons[i].end >= utr.end) {
          exon = exons[i];
          break;
        }
      }

      if (exon) {
        if (utr.start === exon.start && utr.end === exon.end) {
          exon.utr = true;
        } else {
          if (utr.end < exon.end) {
            exon.cdStart = utr.end;
          }

          if (utr.start > exon.start) {
            exon.cdEnd = utr.start;
          }
        }

        if (!exon.children) {
          exon.children = [];
        }

        exon.children.push(utr);
      } else {
        utr.utr = true;
        exons.push(utr);
      } // Expand feature --  for transcripts not explicitly represented in the file


      this.start = Math.min(this.start, utr.start);
      this.end = Math.max(this.end, utr.end);
    };

    GFFTranscript.prototype.finish = function () {
      var cdStart = this.cdStart;
      var cdEnd = this.cdEnd;
      this.exons.sort(function (a, b) {
        return a.start - b.start;
      }); // Search for UTR exons that were not explicitly tagged

      if (cdStart) {
        this.exons.forEach(function (exon) {
          if (exon.end < cdStart || exon.start > cdEnd) exon.utr = true;
        });
      }
    };

    GFFTranscript.prototype.popupData = function (genomicLocation) {
      const kvs = this.attributeString.split(';');
      const pd = []; // If feature has an associated gene list its attributes first

      if (this.gene && typeof this.gene.popupData === 'function') {
        const gd = this.gene.popupData(genomicLocation);

        for (let e of gd) {
          pd.push(e);
        }

        pd.push("<hr>");
      }

      if (this.name) {
        pd.push({
          name: 'name',
          value: this.name
        });
      }

      pd.push({
        name: 'type',
        value: this.type
      });

      for (let kv of kvs) {
        var t = kv.trim().split(this.delim, 2);

        if (t.length === 2 && t[1] !== undefined) {
          const key = t[0].trim();
          if ('name' === key.toLowerCase()) continue;
          let value = t[1].trim(); //Strip off quotes, if any

          if (value.startsWith('"') && value.endsWith('"')) {
            value = value.substr(1, value.length - 2);
          }

          pd.push({
            name: key,
            value: value
          });
        }
      }

      pd.push({
        name: 'position',
        value: `${this.chr}:${numberFormatter(this.start + 1)}-${numberFormatter(this.end)}`
      }); // If clicked over an exon add its attributes

      for (let exon of this.exons) {
        if (genomicLocation >= exon.start && genomicLocation < exon.end && typeof exon.popupData === 'function') {
          pd.push("<hr>");
          const exonData = exon.popupData(genomicLocation);

          for (let att of exonData) {
            pd.push(att);
          }

          if (exon.children) {
            for (let c of exon.children) {
              pd.push("<hr>");
              const exonData = c.popupData(genomicLocation);

              for (let att of exonData) {
                pd.push(att);
              }
            }
          }
        }
      }

      return pd;
    };

    const GenomicInterval = function (chr, start, end, features) {
      this.chr = chr;
      this.start = start;
      this.end = end;
      this.features = features;
    };

    GenomicInterval.prototype.contains = function (chr, start, end) {
      return this.chr === chr && this.start <= start && this.end >= end;
    };

    GenomicInterval.prototype.containsRange = function (range) {
      return this.chr === range.chr && this.start <= range.start && this.end >= range.end;
    };

    // Assigns a row # to each feature.  If the feature does not fit in any row and #rows == maxRows no
    // row number is assigned.
    function pack(featureList, maxRows) {
      maxRows = maxRows || Number.MAX_SAFE_INTEGER;
      const rows = [];
      featureList.sort(function (a, b) {
        return a.start - b.start;
      });
      rows.push(-1000);

      for (let feature of featureList) {
        let r = 0;
        const len = Math.min(rows.length, maxRows);

        for (r = 0; r < len; r++) {
          if (feature.start > rows[r]) {
            feature.row = r;
            rows[r] = feature.end;
            break;
          }
        }

        feature.row = r;
        rows[r] = feature.end;
      }
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014-2015 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * feature source for "bed like" files (tab or whitespace delimited files with 1 feature per line: bed, gff, vcf, etc)
     *
     * @param config
     * @constructor
     */

    class TextFeatureSource {
      constructor(config, genome) {
        this.config = config || {};
        this.genome = genome;
        this.sourceType = config.sourceType === undefined ? "file" : config.sourceType;
        this.visibilityWindow = config.visibilityWindow;
        const queryableFormats = new Set(["bigwig", "bw", "bigbed", "bb", "tdf"]);

        if (config.features && Array.isArray(config.features)) {
          let features = fixFeatures(config.features);
          packFeatures(features);

          if (config.mappings) {
            mapProperties(features, config.mappings);
          }

          this.queryable = false;
          this.featureCache = new FeatureCache(features, genome);
        } else if (config.reader) {
          this.reader = config.reader;
          this.queryable = config.queryable !== undefined ? config.queryable : true;
          this.expandQuery = config.expandQuery ? true : false;
        } else if (config.sourceType === "ga4gh") {
          this.reader = new Ga4ghVariantReader(config, genome);
          this.queryable = true;
        } else if (config.sourceType === "immvar") {
          this.reader = new ImmVarReader(config);
          this.queryable = true;
        } else if (config.type === "eqtl" && config.sourceType === "gtex-ws") {
          this.reader = new GtexReader(config);
          this.queryable = true;
          this.expandQuery = config.expandQuery ? true : false;
        } else if (config.sourceType === 'ucscservice') {
          this.reader = new UCSCServiceReader(config.source);
          this.queryable = true;
        } else if (config.sourceType === 'custom' || config.source !== undefined) {
          // Second test for backward compatibility
          this.reader = new CustomServiceReader(config.source);
          this.queryable = config.source.queryable !== undefined ? config.source.queryable : true;
          this.expandQuery = config.expandQuery ? true : false;
        } else if ("civic-ws" === config.sourceType) {
          this.reader = new CivicReader(config);
          this.queryable = false;
          this.expandQuery = config.expandQuery ? true : false;
        } else {
          this.reader = new FeatureFileReader(config, genome);

          if (config.queryable !== undefined) {
            this.queryable = config.queryable;
          } else if (queryableFormats.has(config.format)) {
            this.queryable = queryableFormats.has(config.format) || this.reader.indexed;
          } else ;
        }
      }

      supportsWholeGenome() {
        return !this.queryable && (this.visibilityWindow === undefined || this.visibilityWindow <= 0);
      }

      async trackType() {
        const header = await this.getHeader();

        if (header) {
          return header.type;
        } else {
          return undefined; // Convention for unknown or unspecified
        }
      }

      async getHeader() {
        if (!this.header) {
          if (this.reader && typeof this.reader.readHeader === "function") {
            const header = await this.reader.readHeader();

            if (header) {
              this.header = header;

              if (header.format) {
                this.config.format = header.format;
              }
            } else {
              this.header = {};
            }
          } else {
            this.header = {};
          }
        }

        return this.header;
      }
      /**
       * Required function for all data source objects.  Fetches features for the
       * range requested.
       *
       * This function is quite complex due to the variety of reader types backing it, some indexed, some queryable,
       * some not.  The whole scheme could use a refactoring.
       *
       * @param chr
       * @param start
       * @param end
       * @param bpPerPixel
       */


      async getFeatures(_ref) {
        let {
          chr,
          start,
          end,
          bpPerPixel,
          visibilityWindow
        } = _ref;
        const genome = this.genome;
        const queryChr = genome ? genome.getChromosomeName(chr) : chr;
        const isWholeGenome = "all" === queryChr.toLowerCase(); // Various conditions that can create a feature load
        // * view is "whole genome" but no features are loaded
        // * cache is disabled
        // * cache does not contain requested range

        if (isWholeGenome && !this.getWGFeatures || this.config.disableCache || !this.featureCache || !this.featureCache.containsRange(new GenomicInterval(queryChr, start, end))) {
          await this.loadFeatures(start, end, visibilityWindow, queryChr);
        }

        if (isWholeGenome) {
          if (!this.wgFeatures) {
            if (this.queryable) {
              // queryable sources don't support whole genome view
              this.wgFeatures = [];
            } else {
              this.wgFeatures = this.getWGFeatures(this.featureCache.getAllFeatures());
            }
          }

          return this.wgFeatures;
        } else {
          return this.featureCache.queryFeatures(queryChr, start, end);
        }
      }

      async loadFeatures(start, end, visibilityWindow, queryChr) {
        const reader = this.reader;
        let intervalStart = start;
        let intervalEnd = end; // Use visibility window to potentially expand query interval.
        // This can save re-queries as we zoom out.  Visibility window <= 0 is a special case
        // indicating whole chromosome should be read at once.

        if ((!visibilityWindow || visibilityWindow <= 0) && this.expandQuery !== false) {
          // Whole chromosome
          const chromosome = this.genome ? this.genome.getChromosome(queryChr) : undefined;
          intervalStart = 0;
          intervalEnd = chromosome ? chromosome.bpLength : Number.MAX_SAFE_INTEGER;
        } else if (visibilityWindow > end - start && this.expandQuery !== false) {
          const expansionWindow = Math.min(4.1 * (end - start), visibilityWindow);
          intervalStart = Math.max(0, (start + end - expansionWindow) / 2);
          intervalEnd = start + expansionWindow;
        }

        let features = await reader.readFeatures(queryChr, intervalStart, intervalEnd);

        if (this.queryable === undefined) {
          this.queryable = reader.indexed;
        }

        const genomicInterval = this.queryable ? new GenomicInterval(queryChr, intervalStart, intervalEnd) : undefined;

        if (features) {
          if ("gtf" === this.config.format || "gff3" === this.config.format || "gff" === this.config.format) {
            features = new GFFHelper(this.config).combineFeatures(features);
          } // Assign overlapping features to rows


          if (this.config.format !== "wig" && this.config.type !== "junctions") {
            const maxRows = this.config.maxRows || Number.MAX_SAFE_INTEGER;
            packFeatures(features, maxRows);
          } // Note - replacing previous cache with new one.  genomicInterval is optional (might be undefined => includes all features)


          this.featureCache = new FeatureCache(features, this.genome, genomicInterval); // If track is marked "searchable"< cache features by name -- use this with caution, memory intensive

          if (this.config.searchable) {
            this.addFeaturesToDB(features);
          }
        } else {
          this.featureCache = new FeatureCache([], genomicInterval); // Empty cache
        }
      }

      addFeaturesToDB(featureList) {
        for (let feature of featureList) {
          if (feature.name) {
            this.genome.featureDB[feature.name.toUpperCase()] = feature;
          }

          if (feature.gene && feature.gene.name) {
            this.genome.featureDB[feature.gene.name.toUpperCase()] = feature;
          }
        }
      } // TODO -- filter by pixel size


      getWGFeatures(allFeatures) {
        const genome = this.genome;
        const wgChromosomeNames = new Set(genome.wgChromosomeNames);
        const wgFeatures = [];

        for (let c of genome.wgChromosomeNames) {
          const features = allFeatures[c];

          if (features) {
            for (let f of features) {
              let queryChr = genome.getChromosomeName(f.chr);

              if (wgChromosomeNames.has(queryChr)) {
                const wg = Object.assign({}, f);
                wg.chr = "all";
                wg.start = genome.getGenomeCoordinate(f.chr, f.start);
                wg.end = genome.getGenomeCoordinate(f.chr, f.end);
                wg._f = f; // Don't draw exons in whole genome view

                if (wg["exons"]) delete wg["exons"];

                wg.popupData = function (genomeLocation) {
                  if (typeof this._f.popupData === 'function') {
                    return this._f.popupData();
                  } else {
                    return TrackBase.extractPopupData(this._f, genome.id);
                  }
                };

                wgFeatures.push(wg);
              }
            }
          }
        }

        wgFeatures.sort(function (a, b) {
          return a.start - b.start;
        });
        return wgFeatures;
      }

    }

    function packFeatures(features, maxRows) {
      maxRows = maxRows || 1000;

      if (features == null || features.length === 0) {
        return;
      } // Segregate by chromosome


      const chrFeatureMap = {};
      const chrs = [];

      for (let feature of features) {
        const chr = feature.chr;
        let flist = chrFeatureMap[chr];

        if (!flist) {
          flist = [];
          chrFeatureMap[chr] = flist;
          chrs.push(chr);
        }

        flist.push(feature);
      } // Loop through chrosomosomes and pack features;


      for (let chr of chrs) {
        pack(chrFeatureMap[chr], maxRows);
      }
    }
    /**
     * This function is used to apply properties normally added during parsing to  features supplied directly in the
     * config as an array of objects.   At the moment the only application is bedpe type features.
     * @param features
     */


    function fixFeatures(features) {
      if (!features || features.length === 0) return;
      const isBedPE = features[0].chr === undefined && features[0].chr1 !== undefined;

      if (isBedPE) {
        const interChrFeatures = [];

        for (let feature of features) {
          // Set total extent of feature
          if (feature.chr1 === feature.chr2) {
            feature.chr = feature.chr1;
            feature.start = Math.min(feature.start1, feature.start2);
            feature.end = Math.max(feature.end1, feature.end2);
          } else {
            interChrFeatures.push(feature);
          }
        } // Make copies of inter-chr features, one for each chromosome


        for (let f1 of interChrFeatures) {
          const f2 = Object.assign({
            dup: true
          }, f1);
          features.push(f2);
          f1.chr = f1.chr1;
          f1.start = f1.start1;
          f1.end = f1.end1;
          f2.chr = f2.chr2;
          f2.start = f2.start2;
          f2.end = f2.end2;
        }
      }

      return features;
    }

    function mapProperties(features, mappings) {
      let mappingKeys = Object.keys(mappings);
      features.forEach(function (f) {
        mappingKeys.forEach(function (key) {
          f[key] = f[mappings[key]];
        });
      });
    }

    class BufferedReader {
      constructor(config, contentLength, bufferSize) {
        this.path = config.url;
        this.bufferSize = bufferSize ? bufferSize : 512000;
        this.range = {
          start: -1,
          size: -1
        };
        this.config = config;
      }
      /**
       *
       * @param requestedRange - byte rangeas {start, size}
       * @param fulfill - function to receive result
       * @param asUint8 - optional flag to return result as an UInt8Array
       */


      async dataViewForRange(requestedRange, asUint8) {
        const hasData = this.data && this.range.start <= requestedRange.start && this.range.start + this.range.size >= requestedRange.start + requestedRange.size;

        if (!hasData) {
          let bufferSize; // If requested range size is specified, potentially expand buffer size

          if (requestedRange.size) {
            bufferSize = Math.max(this.bufferSize, requestedRange.size);
          } else {
            bufferSize = this.bufferSize;
          }

          const loadRange = {
            start: requestedRange.start,
            size: bufferSize
          };
          const arrayBuffer = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
            range: loadRange
          }));
          this.data = arrayBuffer;
          this.range = loadRange;
        }

        const len = this.data.byteLength;
        const bufferStart = requestedRange.start - this.range.start;
        return asUint8 ? new Uint8Array(this.data, bufferStart, len - bufferStart) : new DataView(this.data, bufferStart, len - bufferStart);
      }

    }

    //table chromatinInteract

    function getDecoder(definedFieldCount, fieldCount, autoSql) {
      if (autoSql && 'chromatinInteract' === autoSql.table) {
        return decodeInteract;
      } else {
        const standardFieldCount = definedFieldCount - 3;
        return function (feature, tokens) {
          if (standardFieldCount > 0) {
            feature.name = tokens[0];
          }

          if (standardFieldCount > 1) {
            feature.score = parseFloat(tokens[1]);
          }

          if (standardFieldCount > 2) {
            feature.strand = tokens[2];
          }

          if (standardFieldCount > 3) {
            feature.cdStart = parseInt(tokens[3]);
          }

          if (standardFieldCount > 4) {
            feature.cdEnd = parseInt(tokens[4]);
          }

          if (standardFieldCount > 5) {
            if (tokens[5] !== "." && tokens[5] !== "0" && tokens[5] !== "-1") {
              const c = IGVColor.createColorString(tokens[5]);
              feature.color = c.startsWith("rgb") ? c : undefined;
            }
          }

          if (standardFieldCount > 8) {
            const exonCount = parseInt(tokens[6]);
            const exonSizes = tokens[7].split(',');
            const exonStarts = tokens[8].split(',');
            const exons = [];

            for (let i = 0; i < exonCount; i++) {
              const eStart = feature.start + parseInt(exonStarts[i]);
              const eEnd = eStart + parseInt(exonSizes[i]);
              exons.push({
                start: eStart,
                end: eEnd
              });
            }

            feature.exons = exons;
          }

          if (autoSql) {
            // TODO -- these should be equal, validate?  fieldCount-definedFieldCount, as.fields.length, tokens.length-3
            const extraStart = definedFieldCount;

            for (let i = extraStart; i < fieldCount; i++) {
              if (i < autoSql.fields.length) {
                const name = autoSql.fields[i].name;
                const value = tokens[i - 3];
                feature[name] = value;
              }
            }
          }
        };
      }

      function decodeInteract(feature, tokens) {
        feature.chr1 = tokens[5];
        feature.start1 = Number.parseInt(tokens[6]);
        feature.end1 = Number.parseInt(tokens[7]);
        feature.chr2 = tokens[10];
        feature.start2 = Number.parseInt(tokens[11]);
        feature.end2 = Number.parseInt(tokens[12]);
        feature.name = tokens[0];
        feature.score = Number.parseFloat(tokens[1]);
        feature.value = Number.parseFloat(tokens[2]);
        feature.color = tokens[4] === '.' ? undefined : tokens[4] === "0" ? "rgb(0,0,0)" : tokens[4];
        return feature;
      }
    }

    function parseAutoSQL(str) {
      let table;
      const fields = [];
      let startDecoding = false;
      const lines = str.trim().split(/\s*[\r\n]+\s*/g);

      for (let line of lines) {
        if (line.startsWith('table')) {
          table = line.split(/\s+/)[1].trim();
        } else if (line.startsWith('(')) {
          startDecoding = true;
        } else if (line.startsWith(')')) ; else if (startDecoding) {
          if (line.length > 0) {
            const idx = line.indexOf(';');
            const tokens = line.substr(0, idx).split(/\s+/);
            const description = line.substr(idx + 1).replace(/"/g, '').trim();
            fields.push({
              type: tokens[0],
              name: tokens[1],
              description: description
            });
          }
        }
      }

      return {
        table: table,
        fields: fields
      };
    }

    let BIGWIG_MAGIC_LTH = 0x888FFC26; // BigWig Magic Low to High

    let BIGWIG_MAGIC_HTL = 0x26FC8F66; // BigWig Magic High to Low

    let BIGBED_MAGIC_LTH = 0x8789F2EB; // BigBed Magic Low to High

    let BIGBED_MAGIC_HTL = 0xEBF28987; // BigBed Magic High to Low

    let BBFILE_HEADER_SIZE = 64;
    let RPTREE_HEADER_SIZE = 48;
    let RPTREE_NODE_LEAF_ITEM_SIZE = 32; // leaf item size

    let RPTREE_NODE_CHILD_ITEM_SIZE = 24; // child item size

    let BUFFER_SIZE = 512000; //  buffer

    class BWReader {
      constructor(config, genome) {
        this.path = config.url;
        this.genome = genome;
        this.rpTreeCache = {};
        this.config = config;
      }

      async readWGFeatures(bpPerPixel, windowFunction) {
        await this.loadHeader();
        const chrIdx1 = 0;
        const chrIdx2 = this.chromTree.idToChrom.length - 1;
        const chr1 = this.chromTree.idToChrom[chrIdx1];
        const chr2 = this.chromTree.idToChrom[chrIdx2];
        return this.readFeatures(chr1, 0, chr2, Number.MAX_VALUE, bpPerPixel, windowFunction);
      }

      async readFeatures(chr1, bpStart, chr2, bpEnd, bpPerPixel, windowFunction) {
        await this.loadHeader();
        const chrIdx1 = this.chromTree.chromToID[chr1];
        const chrIdx2 = this.chromTree.chromToID[chr2];

        if (chrIdx1 === undefined || chrIdx2 === undefined) {
          return [];
        }

        let treeOffset;
        let decodeFunction;

        if (this.type === "bigwig") {
          // Select a biwig "zoom level" appropriate for the current resolution.
          const zoomLevelHeaders = await this.getZoomHeaders();
          let zoomLevelHeader = bpPerPixel ? zoomLevelForScale$1(bpPerPixel, zoomLevelHeaders) : undefined;

          if (zoomLevelHeader) {
            treeOffset = zoomLevelHeader.indexOffset;
            decodeFunction = decodeZoomData;
          } else {
            treeOffset = this.header.fullIndexOffset;
            decodeFunction = decodeWigData;
          }
        } else {
          // bigbed, zoom data is not currently used in igv for bed type features
          treeOffset = this.header.fullIndexOffset;
          decodeFunction = getBedDataDecoder.call(this);
        } // Load the R Tree and fine leaf items


        const rpTree = await this.loadRPTree(treeOffset);
        const leafItems = await rpTree.findLeafItemsOverlapping(chrIdx1, bpStart, chrIdx2, bpEnd);

        if (!leafItems || leafItems.length === 0) {
          return [];
        } else {
          // Consolidate leaf items and get all data at once
          let start = Number.MAX_VALUE;
          let end = 0;

          for (let item of leafItems) {
            start = Math.min(start, item.dataOffset);
            end = Math.max(end, item.dataOffset + item.dataSize);
          }

          const size = end - start;
          const arrayBuffer = await igvxhr.loadArrayBuffer(this.config.url, buildOptions$1(this.config, {
            range: {
              start: start,
              size: size
            }
          })); // Parse data and return features

          const allFeatures = [];
          const buffer = new Uint8Array(arrayBuffer);

          for (let item of leafItems) {
            const uint8Array = buffer.subarray(item.dataOffset - start, item.dataOffset + item.dataSize);
            let plain;
            const isCompressed = this.header.uncompressBuffSize > 0;

            if (isCompressed) {
              const inflate = new Zlib$2.Inflate(uint8Array);
              plain = inflate.decompress();
            } else {
              plain = uint8Array;
            }

            decodeFunction.call(this, new DataView(plain.buffer), chrIdx1, bpStart, chrIdx2, bpEnd, allFeatures, this.chromTree.idToChrom, windowFunction);
          }

          allFeatures.sort(function (a, b) {
            return a.start - b.start;
          });
          return allFeatures;
        }
      }

      async getZoomHeaders() {
        if (this.zoomLevelHeaders) {
          return this.zoomLevelHeaders;
        } else {
          await this.loadHeader();
          return this.zoomLevelHeaders;
        }
      }

      async loadHeader() {
        if (this.header) {
          return this.header;
        } else {
          let data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
            range: {
              start: 0,
              size: BBFILE_HEADER_SIZE
            }
          }));
          let header; // Assume low-to-high unless proven otherwise

          this.littleEndian = true;
          let binaryParser = new BinaryParser$1(new DataView(data));
          let magic = binaryParser.getUInt();

          if (magic === BIGWIG_MAGIC_LTH) {
            this.type = "bigwig";
          } else if (magic === BIGBED_MAGIC_LTH) {
            this.type = "bigbed";
          } else {
            //Try big endian order
            this.littleEndian = false;
            binaryParser.littleEndian = false;
            binaryParser.position = 0;
            let magic = binaryParser.getUInt();

            if (magic === BIGWIG_MAGIC_HTL) {
              this.type = "bigwig";
            } else if (magic === BIGBED_MAGIC_HTL) {
              this.type = "bigbed";
            } else ;
          } // Table 5  "Common header for bigwig and bigbed files"


          header = {
            bwVersion: binaryParser.getUShort(),
            nZoomLevels: binaryParser.getUShort(),
            chromTreeOffset: binaryParser.getLong(),
            fullDataOffset: binaryParser.getLong(),
            fullIndexOffset: binaryParser.getLong(),
            fieldCount: binaryParser.getUShort(),
            definedFieldCount: binaryParser.getUShort(),
            autoSqlOffset: binaryParser.getLong(),
            totalSummaryOffset: binaryParser.getLong(),
            uncompressBuffSize: binaryParser.getInt(),
            extensionOffset: binaryParser.getLong()
          }; ///////////

          const startOffset = BBFILE_HEADER_SIZE;
          let range = {
            start: startOffset,
            size: header.fullDataOffset - startOffset + 5
          };
          data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
            range: range
          }));
          const nZooms = header.nZoomLevels;
          binaryParser = new BinaryParser$1(new DataView(data));
          this.zoomLevelHeaders = [];
          this.firstZoomDataOffset = Number.MAX_SAFE_INTEGER;

          for (let i = 1; i <= nZooms; i++) {
            const zoomNumber = nZooms - i;
            const zlh = new ZoomLevelHeader(zoomNumber, binaryParser);
            this.firstZoomDataOffset = Math.min(zlh.dataOffset, this.firstZoomDataOffset);
            this.zoomLevelHeaders[zoomNumber] = zlh;
          } // Autosql


          if (header.autoSqlOffset > 0) {
            binaryParser.position = header.autoSqlOffset - startOffset;
            const autoSqlString = binaryParser.getString();

            if (autoSqlString) {
              this.autoSql = parseAutoSQL(autoSqlString);
            }
          } // Total summary


          if (header.totalSummaryOffset > 0) {
            binaryParser.position = header.totalSummaryOffset - startOffset;
            this.totalSummary = new BWTotalSummary(binaryParser);
          } // Chrom data index


          if (header.chromTreeOffset > 0) {
            binaryParser.position = header.chromTreeOffset - startOffset;
            this.chromTree = new BPTree(binaryParser, startOffset, this.genome);
          } else {
            // TODO -- this is an error, not expected
            throw "BigWig chromosome tree offset <= 0";
          } //Finally total data count


          binaryParser.position = header.fullDataOffset - startOffset;
          header.dataCount = binaryParser.getInt(); ///////////

          this.setDefaultVisibilityWindow(header);
          this.header = header;
          return this.header;
        }
      }

      async loadRPTree(offset) {
        let rpTree = this.rpTreeCache[offset];

        if (rpTree) {
          return rpTree;
        } else {
          rpTree = new RPTree(offset, this.config, this.littleEndian);
          await rpTree.load();
          this.rpTreeCache[offset] = rpTree;
          return rpTree;
        }
      }

      async getType() {
        await this.loadHeader();
        return this.type;
      }

      async getTrackType() {
        await this.loadHeader();

        if (this.type === "bigwig") {
          return "wig";
        } else {
          return this.autoSql && this.autoSql.table === "chromatinInteract" ? "interact" : "annotation";
        }
      }

      setDefaultVisibilityWindow(header) {
        if (this.type === "bigwig") {
          this.visibilityWindow = -1;
        } else {
          // bigbed
          let genomeSize = this.genome ? this.genome.getGenomeLength() : 3088286401; // Estimate window size to return ~ 1,000 features, assuming even distribution across the genome

          this.visibilityWindow = header.dataCount < 1000 ? -1 : 1000 * (genomeSize / header.dataCount);
        }
      }

    }

    class ZoomLevelHeader {
      constructor(index, byteBuffer) {
        this.index = index;
        this.reductionLevel = byteBuffer.getInt();
        this.reserved = byteBuffer.getInt();
        this.dataOffset = byteBuffer.getLong();
        this.indexOffset = byteBuffer.getLong();
      }

    }

    class RPTree {
      constructor(fileOffset, config, littleEndian) {
        this.config = config;
        this.fileOffset = fileOffset; // File offset to beginning of tree

        this.path = config.url;
        this.littleEndian = littleEndian;
      }

      async load() {
        const rootNodeOffset = this.fileOffset + RPTREE_HEADER_SIZE;
        const bufferedReader = new BufferedReader(this.config, BUFFER_SIZE);
        this.rootNode = await this.readNode(rootNodeOffset, bufferedReader);
        return this;
      }

      async readNode(filePosition, bufferedReader) {
        let dataView = await bufferedReader.dataViewForRange({
          start: filePosition,
          size: 4
        }, false);
        let binaryParser = new BinaryParser$1(dataView, this.littleEndian);
        const type = binaryParser.getByte();
        const isLeaf = type === 1;
        binaryParser.getByte();
        const count = binaryParser.getUShort();
        filePosition += 4;
        let bytesRequired = count * (isLeaf ? RPTREE_NODE_LEAF_ITEM_SIZE : RPTREE_NODE_CHILD_ITEM_SIZE);
        let range2 = {
          start: filePosition,
          size: bytesRequired
        };
        dataView = await bufferedReader.dataViewForRange(range2, false);
        const items = new Array(count);
        binaryParser = new BinaryParser$1(dataView);

        if (isLeaf) {
          for (let i = 0; i < count; i++) {
            let item = {
              isLeaf: true,
              startChrom: binaryParser.getInt(),
              startBase: binaryParser.getInt(),
              endChrom: binaryParser.getInt(),
              endBase: binaryParser.getInt(),
              dataOffset: binaryParser.getLong(),
              dataSize: binaryParser.getLong()
            };
            items[i] = item;
          }

          return new RPTreeNode(items);
        } else {
          // non-leaf
          for (let i = 0; i < count; i++) {
            let item = {
              isLeaf: false,
              startChrom: binaryParser.getInt(),
              startBase: binaryParser.getInt(),
              endChrom: binaryParser.getInt(),
              endBase: binaryParser.getInt(),
              childOffset: binaryParser.getLong()
            };
            items[i] = item;
          }

          return new RPTreeNode(items);
        }
      }

      async findLeafItemsOverlapping(chrIdx1, startBase, chrIdx2, endBase) {
        let self = this;
        return new Promise(function (fulfill, reject) {
          let leafItems = [],
              processing = new Set(),
              bufferedReader = new BufferedReader(self.config, BUFFER_SIZE);
          processing.add(0); // Zero represents the root node

          findLeafItems(self.rootNode, 0);

          function findLeafItems(node, nodeId) {
            if (overlaps(node, chrIdx1, startBase, chrIdx2, endBase)) {
              let items = node.items;
              items.forEach(function (item) {
                if (overlaps(item, chrIdx1, startBase, chrIdx2, endBase)) {
                  if (item.isLeaf) {
                    leafItems.push(item);
                  } else {
                    if (item.childNode) {
                      findLeafItems(item.childNode);
                    } else {
                      processing.add(item.childOffset); // Represent node to-be-loaded by its file position

                      self.readNode(item.childOffset, bufferedReader).then(function (node) {
                        item.childNode = node;
                        findLeafItems(node, item.childOffset);
                      }).catch(reject);
                    }
                  }
                }
              });
            }

            if (nodeId !== undefined) processing.delete(nodeId); // Wait until all nodes are processed

            if (processing.size === 0) {
              fulfill(leafItems);
            }
          }
        });
      }

    }

    class RPTreeNode {
      constructor(items) {
        this.items = items;
        let minChromId = Number.MAX_SAFE_INTEGER,
            maxChromId = 0,
            minStartBase = Number.MAX_SAFE_INTEGER,
            maxEndBase = 0,
            i,
            item;

        for (i = 0; i < items.length; i++) {
          item = items[i];
          minChromId = Math.min(minChromId, item.startChrom);
          maxChromId = Math.max(maxChromId, item.endChrom);
          minStartBase = Math.min(minStartBase, item.startBase);
          maxEndBase = Math.max(maxEndBase, item.endBase);
        }

        this.startChrom = minChromId;
        this.endChrom = maxChromId;
        this.startBase = minStartBase;
        this.endBase = maxEndBase;
      }

    }

    class BPTree {
      constructor(binaryParser, startOffset, genome) {
        let magic = binaryParser.getInt();
        let blockSize = binaryParser.getInt();
        let keySize = binaryParser.getInt();
        let valSize = binaryParser.getInt();
        let itemCount = binaryParser.getLong();
        let reserved = binaryParser.getLong();
        let chromToId = {};
        let idToChrom = [];
        this.header = {
          magic: magic,
          blockSize: blockSize,
          keySize: keySize,
          valSize: valSize,
          itemCount: itemCount,
          reserved: reserved
        };
        this.chromToID = chromToId;
        this.idToChrom = idToChrom; // Recursively walk tree to populate dictionary

        readTreeNode(binaryParser, -1);

        function readTreeNode(byteBuffer, offset) {
          if (offset >= 0) byteBuffer.position = offset;
          let type = byteBuffer.getByte();
              byteBuffer.getByte();
              let count = byteBuffer.getUShort(),
              i,
              key,
              chromId,
              childOffset,
              bufferOffset,
              currOffset;

          if (type === 1) {
            for (i = 0; i < count; i++) {
              key = byteBuffer.getFixedLengthTrimmedString(keySize);
              chromId = byteBuffer.getInt();
              byteBuffer.getInt();
              if (genome) key = genome.getChromosomeName(key); // Translate to canonical chr name

              chromToId[key] = chromId;
              idToChrom[chromId] = key;
            }
          } else {
            // non-leaf
            for (i = 0; i < count; i++) {
              key = byteBuffer.getFixedLengthTrimmedString(keySize);
              childOffset = byteBuffer.getLong();
              bufferOffset = childOffset - startOffset;
              currOffset = byteBuffer.position;
              readTreeNode(byteBuffer, bufferOffset);
              byteBuffer.position = currOffset;
            }
          }
        }
      }

    }
    /**
     * Return true if {chrIdx1:startBase-chrIdx2:endBase} overlaps item's interval
     * @returns {boolean}
     */


    function overlaps(item, chrIdx1, startBase, chrIdx2, endBase) {
      if (!item) {
        console.log("null item for " + chrIdx1 + " " + startBase + " " + endBase);
        return false;
      }

      return (chrIdx2 > item.startChrom || chrIdx2 === item.startChrom && endBase >= item.startBase) && (chrIdx1 < item.endChrom || chrIdx1 === item.endChrom && startBase <= item.endBase);
    }

    class BWTotalSummary {
      constructor(byteBuffer) {
        if (byteBuffer) {
          this.basesCovered = byteBuffer.getLong();
          this.minVal = byteBuffer.getDouble();
          this.maxVal = byteBuffer.getDouble();
          this.sumData = byteBuffer.getDouble();
          this.sumSquares = byteBuffer.getDouble();
          computeStats.call(this);
        } else {
          this.basesCovered = 0;
          this.minVal = 0;
          this.maxVal = 0;
          this.sumData = 0;
          this.sumSquares = 0;
          this.mean = 0;
          this.stddev = 0;
        }
      }

    }

    function computeStats() {
      let n = this.basesCovered;

      if (n > 0) {
        this.mean = this.sumData / n;
        this.stddev = Math.sqrt(this.sumSquares / (n - 1));
        let min = this.minVal < 0 ? this.mean - 2 * this.stddev : 0,
            max = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;
        this.defaultRange = {
          min: min,
          max: max
        };
      }
    }

    function zoomLevelForScale$1(bpPerPixel, zoomLevelHeaders) {
      let level;

      for (let i = 0; i < zoomLevelHeaders.length; i++) {
        const zl = zoomLevelHeaders[i];

        if (zl.reductionLevel < bpPerPixel) {
          level = zl;
          break;
        }
      }

      return level;
    }

    function decodeWigData(data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict) {
      const binaryParser = new BinaryParser$1(data);
      const chromId = binaryParser.getInt();
      let chromStart = binaryParser.getInt();
      let chromEnd = binaryParser.getInt();
      const itemStep = binaryParser.getInt();
      const itemSpan = binaryParser.getInt();
      const type = binaryParser.getByte();
      binaryParser.getByte();
      let itemCount = binaryParser.getUShort();

      if (chromId >= chrIdx1 && chromId <= chrIdx2) {
        while (itemCount-- > 0) {
          let value;

          switch (type) {
            case 1:
              chromStart = binaryParser.getInt();
              chromEnd = binaryParser.getInt();
              value = binaryParser.getFloat();
              break;

            case 2:
              chromStart = binaryParser.getInt();
              value = binaryParser.getFloat();
              chromEnd = chromStart + itemSpan;
              break;

            case 3:
              // Fixed step
              value = binaryParser.getFloat();
              chromEnd = chromStart + itemSpan;
              chromStart += itemStep;
              break;
          }

          if (chromId < chrIdx1 || chromId === chrIdx1 && chromEnd < bpStart) continue;else if (chromId > chrIdx2 || chromId === chrIdx2 && chromStart >= bpEnd) break;

          if (Number.isFinite(value)) {
            const chr = chrDict[chromId];
            featureArray.push({
              chr: chr,
              start: chromStart,
              end: chromEnd,
              value: value
            });
          }
        }
      }
    }

    function getBedDataDecoder() {
      const minSize = 3 * 4 + 1; // Minimum # of bytes required for a bed record

      const decoder = getDecoder(this.header.definedFieldCount, this.header.fieldCount, this.autoSql);
      return function (data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict) {
        const binaryParser = new BinaryParser$1(data);

        while (binaryParser.remLength() >= minSize) {
          const chromId = binaryParser.getInt();
          const chr = chrDict[chromId];
          const chromStart = binaryParser.getInt();
          const chromEnd = binaryParser.getInt();
          const rest = binaryParser.getString();
          if (chromId < chrIdx1 || chromId === chrIdx1 && chromEnd < bpStart) continue;else if (chromId > chrIdx2 || chromId === chrIdx2 && chromStart >= bpEnd) break;

          if (chromEnd > 0) {
            const feature = {
              chr: chr,
              start: chromStart,
              end: chromEnd
            };
            featureArray.push(feature);
            const tokens = rest.split("\t");
            decoder(feature, tokens);
          }
        }
      };
    }

    function decodeZoomData(data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict, windowFunction) {
      const binaryParser = new BinaryParser$1(data);
      const minSize = 8 * 4; // Minimum # of bytes required for a zoom record

      while (binaryParser.remLength() >= minSize) {
        const chromId = binaryParser.getInt();
        const chr = chrDict[chromId];
        const chromStart = binaryParser.getInt();
        const chromEnd = binaryParser.getInt();
        const validCount = binaryParser.getInt();
        const minVal = binaryParser.getFloat();
        const maxVal = binaryParser.getFloat();
        const sumData = binaryParser.getFloat();
        binaryParser.getFloat();
        let value;

        switch (windowFunction) {
          case "min":
            value = minVal;
            break;

          case "max":
            value = maxVal;
            break;

          default:
            value = validCount === 0 ? 0 : sumData / validCount;
        }

        if (chromId < chrIdx1 || chromId === chrIdx1 && chromEnd < bpStart) continue;else if (chromId > chrIdx2 || chromId === chrIdx2 && chromStart >= bpEnd) break;

        if (Number.isFinite(value)) {
          featureArray.push({
            chr: chr,
            start: chromStart,
            end: chromEnd,
            value: value
          });
        }
      }
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    class BWSource {
      constructor(config, genome) {
        this.reader = new BWReader(config, genome);
        this.genome = genome;
        this.format = config.format || "bigwig";
        this.wgValues = {};
      }

      async getFeatures(_ref) {
        let {
          chr,
          start,
          end,
          bpPerPixel,
          windowFunction
        } = _ref;
        const features = chr.toLowerCase() === "all" ? await this.getWGValues(windowFunction) : await this.reader.readFeatures(chr, start, chr, end, bpPerPixel, windowFunction);
        const isBigWig = this.reader.type === "bigwig";

        if (!isBigWig) {
          pack(features);
        }

        return features;
      }

      async getHeader() {
        return this.reader.loadHeader();
      }

      getDefaultRange() {
        if (this.reader.totalSummary !== undefined) {
          return this.reader.totalSummary.defaultRange;
        } else {
          return undefined;
        }
      }

      async defaultVisibilityWindow() {
        return this.reader.defaultVisibilityWindow;
      }

      async getWGValues(windowFunction) {
        const nominalScreenWidth = 1000; // This doesn't need to be precise

        const genome = this.genome;

        if (this.wgValues[windowFunction]) {
          return this.wgValues[windowFunction];
        } else {
          const bpPerPixel = genome.getGenomeLength() / nominalScreenWidth;
          const features = await this.reader.readWGFeatures(bpPerPixel, windowFunction);
          let wgValues = [];

          for (let f of features) {
            const chr = f.chr;
            const offset = genome.getCumulativeOffset(chr);
            const wgFeature = Object.assign({}, f);
            wgFeature.chr = "all";
            wgFeature.start = offset + f.start;
            wgFeature.end = offset + f.end;
            wgValues.push(wgFeature);
          }

          this.wgValues[windowFunction] = wgValues;
          return wgValues;
        }
      }

      supportsWholeGenome() {
        return this.reader.type === "bigwig" || this.defaultVisibilityWindow() <= 0;
      }

      async trackType() {
        return this.reader.getTrackType();
      }

    }

    const GZIP_FLAG = 0x1;

    class TDFReader {
      constructor(config, genome) {
        this.config = config;
        this.genome = genome;
        this.path = config.url;
        this.groupCache = {};
        this.datasetCache = {};
      }

      async readHeader() {
        if (this.magic !== undefined) {
          return this; // Already read
        }

        let data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
          range: {
            start: 0,
            size: 64000
          }
        }));
        let binaryParser = new BinaryParser$1(new DataView(data));
        this.magic = binaryParser.getInt();
        this.version = binaryParser.getInt();
        this.indexPos = binaryParser.getLong();
        this.indexSize = binaryParser.getInt();
        binaryParser.getInt();

        if (this.version >= 2) {
          let nWindowFunctions = binaryParser.getInt();
          this.windowFunctions = [];

          while (nWindowFunctions-- > 0) {
            this.windowFunctions.push(binaryParser.getString());
          }
        }

        this.trackType = binaryParser.getString();
        this.trackLine = binaryParser.getString();
        let nTracks = binaryParser.getInt();
        this.trackNames = [];

        while (nTracks-- > 0) {
          this.trackNames.push(binaryParser.getString());
        }

        this.genomeID = binaryParser.getString();
        this.flags = binaryParser.getInt();
        this.compressed = (this.flags & GZIP_FLAG) !== 0; // Now read index

        data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
          range: {
            start: this.indexPos,
            size: this.indexSize
          }
        }));
        binaryParser = new BinaryParser$1(new DataView(data));
        this.datasetIndex = {};
        let nEntries = binaryParser.getInt();

        while (nEntries-- > 0) {
          const name = binaryParser.getString();
          const pos = binaryParser.getLong();
          const size = binaryParser.getInt();
          this.datasetIndex[name] = {
            position: pos,
            size: size
          };
        }

        this.groupIndex = {};
        nEntries = binaryParser.getInt();

        while (nEntries-- > 0) {
          const name = binaryParser.getString();
          const pos = binaryParser.getLong();
          const size = binaryParser.getInt();
          this.groupIndex[name] = {
            position: pos,
            size: size
          };
        }

        return this;
      }

      async readDataset(chr, windowFunction, zoom) {
        const key = chr + "_" + windowFunction + "_" + zoom;

        if (this.datasetCache[key]) {
          return this.datasetCache[key];
        } else {
          await this.readHeader();
          const wf = this.version < 2 ? "" : "/" + windowFunction;
          const zoomString = chr.toLowerCase() === "all" || zoom === undefined ? "0" : zoom.toString();
          let dsName;

          if (windowFunction === "raw") {
            dsName = "/" + chr + "/raw";
          } else {
            dsName = "/" + chr + "/z" + zoomString + wf;
          }

          const indexEntry = this.datasetIndex[dsName];

          if (indexEntry === undefined) {
            return undefined;
          }

          const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
            range: {
              start: indexEntry.position,
              size: indexEntry.size
            }
          }));

          if (!data) {
            return undefined;
          }

          const binaryParser = new BinaryParser$1(new DataView(data));
          let nAttributes = binaryParser.getInt();
          const attributes = {};

          while (nAttributes-- > 0) {
            attributes[binaryParser.getString()] = binaryParser.getString();
          }

          const dataType = binaryParser.getString();
          const tileWidth = binaryParser.getFloat();
          let nTiles = binaryParser.getInt();
          const tiles = [];

          while (nTiles-- > 0) {
            tiles.push({
              position: binaryParser.getLong(),
              size: binaryParser.getInt()
            });
          }

          const dataset = {
            name: dsName,
            attributes: attributes,
            dataType: dataType,
            tileWidth: tileWidth,
            tiles: tiles
          };
          this.datasetCache[key] = dataset;
          return dataset;
        }
      }

      async readRootGroup() {
        const genome = this.genome;
        const rootGroup = this.groupCache["/"];

        if (rootGroup) {
          return rootGroup;
        } else {
          const group = await this.readGroup("/");
          const names = group["chromosomes"];
          const maxZoomString = group["maxZoom"]; // Now parse out interesting attributes.

          if (maxZoomString) {
            this.maxZoom = Number(maxZoomString);
          }

          const totalCountString = group["totalCount"];

          if (totalCountString) {
            group.totalCount = Number.parseFloat(totalCountString);
          } // Chromosome names


          const chrAliasTable = {};

          if (names) {
            names.split(",").forEach(function (chr) {
              const canonicalName = genome.getChromosomeName(chr);
              chrAliasTable[canonicalName] = chr;
            });
          }

          this.chrAliasTable = chrAliasTable;
          this.groupCache["/"] = group;
          return group;
        }
      }

      async readGroup(name) {
        const group = this.groupCache[name];

        if (group) {
          return group;
        } else {
          await this.readHeader();
          const indexEntry = this.groupIndex[name];

          if (indexEntry === undefined) {
            return undefined;
          }

          const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
            range: {
              start: indexEntry.position,
              size: indexEntry.size
            }
          }));

          if (!data) {
            return undefined;
          }

          const binaryParser = new BinaryParser$1(new DataView(data));
          const group = {
            name: name
          };
          let nAttributes = binaryParser.getInt();

          while (nAttributes-- > 0) {
            const key = binaryParser.getString();
            const value = binaryParser.getString();
            group[key] = value;
          }

          this.groupCache[name] = group;
          return group;
        }
      }

      async readTiles(tileIndeces, nTracks) {
        tileIndeces.sort(function (a, b) {
          return a.position - b.position;
        });
        tileIndeces = tileIndeces.filter(function (idx) {
          return idx.size > 0;
        });

        if (tileIndeces.length === 0) {
          return Promise.resolve([]);
        }

        const firstEntry = tileIndeces[0];
        const lastEntry = tileIndeces[tileIndeces.length - 1];
        const position = firstEntry.position;
        const size = lastEntry.position + lastEntry.size - position;
        const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
          range: {
            start: position,
            size: size
          }
        }));
        const tiles = []; // Loop through and decode tiles

        for (let indexEntry of tileIndeces) {
          const start = indexEntry.position - position;
          const size = indexEntry.size;

          if (size > 0) {
            let tileData;

            if (this.compressed) {
              const inflate = new Zlib$2.Inflate(new Uint8Array(data, start, size));
              const plain = inflate.decompress();
              tileData = plain.buffer;
            } else {
              tileData = data.slice(start, start + size);
            }

            const binaryParser = new BinaryParser$1(new DataView(tileData));
            const type = binaryParser.getString();
            let tile;

            switch (type) {
              case "fixedStep":
                tile = createFixedStep(binaryParser, nTracks);
                break;

              case "variableStep":
                tile = createVariableStep(binaryParser, nTracks);
                break;

              case "bed":
              case "bedWithName":
                tile = createBed(binaryParser, nTracks, type);
                break;

              default:
                throw "Unknown tile type: " + type;
            }

            tiles.push(tile);
          }
        }

        return tiles;
      }

      async readTile(indexEntry, nTracks) {
        let data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
          range: {
            start: indexEntry.position,
            size: indexEntry.size
          }
        }));

        if (this.compressed) {
          const inflate = new Zlib$2.Inflate(new Uint8Array(data));
          const plain = inflate.decompress();
          data = plain.buffer;
        }

        const binaryParser = new BinaryParser$1(new DataView(data));
        const type = binaryParser.getString();

        switch (type) {
          case "fixedStep":
            return createFixedStep(binaryParser, nTracks);

          case "variableStep":
            return createVariableStep(binaryParser, nTracks);

          case "bed":
          case "bedWithName":
            return createBed(binaryParser, nTracks, type);

          default:
            throw "Unknown tile type: " + type;
        }
      }

    }

    function createFixedStep(binaryParser, nTracks) {
      const nPositions = binaryParser.getInt();
      const start = binaryParser.getInt();
      const span = binaryParser.getFloat();
      const data = [];
      let nt = nTracks;

      while (nt-- > 0) {
        let np = nPositions;
        const dtrack = [];

        while (np-- > 0) {
          dtrack.push(binaryParser.getFloat());
        }

        data.push(dtrack);
      }

      return {
        type: "fixedStep",
        start: start,
        span: span,
        data: data,
        nTracks: nTracks,
        nPositions: nPositions
      };
    }

    function createVariableStep(binaryParser, nTracks) {
      const tileStart = binaryParser.getInt();
      const span = binaryParser.getFloat();
      const nPositions = binaryParser.getInt();
      const start = [];
      let np = nPositions;

      while (np-- > 0) {
        start.push(binaryParser.getInt());
      }

      binaryParser.getInt(); // # of samples, ignored but should === nTracks

      const data = [];
      let nt = nTracks;

      while (nt-- > 0) {
        np = nPositions;
        const dtrack = [];

        while (np-- > 0) {
          dtrack.push(binaryParser.getFloat());
        }

        data.push(dtrack);
      }

      return {
        type: "variableStep",
        tileStart: tileStart,
        span: span,
        start: start,
        data: data,
        nTracks: nTracks,
        nPositions: nPositions
      };
    }

    function createBed(binaryParser, nTracks, type) {
      const nPositions = binaryParser.getInt();
      let n = nPositions;
      const start = [];

      while (n-- > 0) {
        start.push(binaryParser.getInt());
      }

      n = nPositions;
      const end = [];

      while (n-- > 0) {
        end.push(binaryParser.getInt());
      }

      binaryParser.getInt(); // # of samples, ignored but should === nTracks

      const data = [];
      let nt = nTracks;

      while (nt-- > 0) {
        let np = nPositions;
        const dtrack = [];

        while (np-- > 0) {
          dtrack.push(binaryParser.getFloat());
        }

        data.push(dtrack);
      }

      if (type === "bedWithName") {
        n = nPositions;
        const name = [];

        while (n-- > 0) {
          name.push(binaryParser.getString());
        }
      }

      return {
        type: type,
        start: start,
        end: end,
        data: data,
        nTracks: nTracks,
        nPositions: nPositions
      };
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2016 University of California San Diego
     * Author: Jim Robinson
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    class TDFSource {
      constructor(config, genome) {
        this.genome = genome;
        this.windowFunction = config.windowFunction || "mean";
        this.reader = new TDFReader(config, genome);
      }

      async getFeatures(_ref) {
        let {
          chr,
          start,
          end,
          bpPerPixel
        } = _ref;
        const genomicInterval = new GenomicInterval(chr, start, end);
        const genome = this.genome;

        if (!this.rootGroup) {
          this.rootGroup = await this.reader.readRootGroup();

          if (!this.normalizationFactor) {
            const totalCount = this.rootGroup.totalCount;

            if (totalCount) {
              this.normalizationFactor = 1.0e6 / totalCount;
            }
          }
        }

        if (chr.toLowerCase() === "all") {
          return []; // Whole genome view not yet supported
        }

        genomicInterval.bpPerPixel = bpPerPixel;
        const zoom = zoomLevelForScale(chr, bpPerPixel, genome);
        let queryChr = this.reader.chrAliasTable[chr];
        let maxZoom = this.reader.maxZoom;
        if (queryChr === undefined) queryChr = chr;
        if (maxZoom === undefined) maxZoom = -1;
        const wf = zoom > maxZoom ? "raw" : this.windowFunction;
        const dataset = await this.reader.readDataset(queryChr, wf, zoom);

        if (dataset == null) {
          return [];
        }

        const tileWidth = dataset.tileWidth;
        const startTile = Math.floor(start / tileWidth);
        const endTile = Math.floor(end / tileWidth);
        const NTRACKS = 1; // TODO read this

        const tiles = await this.reader.readTiles(dataset.tiles.slice(startTile, endTile + 1), NTRACKS);
        const features = [];

        for (let tile of tiles) {
          switch (tile.type) {
            case "bed":
              decodeBedTile(tile, chr, start, end, bpPerPixel, features);
              break;

            case "variableStep":
              decodeVaryTile(tile, chr, start, end, bpPerPixel, features);
              break;

            case "fixedStep":
              decodeFixedTile(tile, chr, start, end, bpPerPixel, features);
              break;

            default:
              throw "Unknown tile type: " + tile.type;
          }
        }

        features.sort(function (a, b) {
          return a.start - b.start;
        });
        return features;
      }

      supportsWholeGenome() {
        return false;
      }

    }

    function decodeBedTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {
      const nPositions = tile.nPositions;
      const starts = tile.start;
      const ends = tile.end;
      const data = tile.data[0]; // Single track for now

      for (let i = 0; i < nPositions; i++) {
        const s = starts[i];
        const e = ends[i];
        if (e < bpStart) continue;
        if (s > bpEnd) break;
        features.push({
          chr: chr,
          start: s,
          end: e,
          value: data[i]
        });
      }
    }

    function decodeVaryTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {
      const nPositions = tile.nPositions;
      const starts = tile.start;
      const span = tile.span;
      const data = tile.data[0]; // Single track for now

      for (let i = 0; i < nPositions; i++) {
        const s = starts[i];
        const e = s + span;
        if (e < bpStart) continue;
        if (s > bpEnd) break;
        features.push({
          chr: chr,
          start: s,
          end: e,
          value: data[i]
        });
      }
    }

    function decodeFixedTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {
      const nPositions = tile.nPositions;
      let s = tile.start;
      const span = tile.span;
      const data = tile.data[0]; // Single track for now

      for (let i = 0; i < nPositions; i++) {
        const e = s + span;
        if (s > bpEnd) break;

        if (e >= bpStart) {
          if (!Number.isNaN(data[i])) {
            features.push({
              chr: chr,
              start: s,
              end: e,
              value: data[i]
            });
          }
        }

        s = e;
      }
    }

    var log2 = Math.log(2);

    function zoomLevelForScale(chr, bpPerPixel, genome) {
      // Convert bpPerPixel to IGV "zoom" level.   This is a bit convoluted,  IGV computes zoom levels assuming
      // display in a 700 pixel window.  The fully zoomed out view of a chromosome is zoom level "0".
      // Zoom level 1 is magnified 2X,  and so forth
      var chrSize = genome.getChromosome(chr).bpLength;
      return Math.ceil(Math.log(Math.max(0, chrSize / (bpPerPixel * 700))) / log2);
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014-2015 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    function FeatureSource(config, genome) {
      const format = config.format ? config.format.toLowerCase() : undefined;

      if ('bigwig' === format || 'bigbed' === format || 'bb' === format) {
        return new BWSource(config, genome);
      } else if ("tdf" === format) {
        return new TDFSource(config, genome);
      } else {
        return new TextFeatureSource(config, genome);
      }
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of ctx software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and ctx permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    const IGVGraphics = {
      setProperties: function (ctx, properties) {
        for (var key in properties) {
          if (properties.hasOwnProperty(key)) {
            var value = properties[key];
            ctx[key] = value;
          }
        }
      },
      strokeLine: function (ctx, x1, y1, x2, y2, properties) {
        x1 = Math.floor(x1) + 0.5;
        y1 = Math.floor(y1) + 0.5;
        x2 = Math.floor(x2) + 0.5;
        y2 = Math.floor(y2) + 0.5;

        if (properties) {
          ctx.save();
          IGVGraphics.setProperties(ctx, properties);
        }

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        if (properties) ctx.restore();
      },
      fillRect: function (ctx, x, y, w, h, properties) {
        x = Math.round(x);
        y = Math.round(y);

        if (properties) {
          ctx.save();
          IGVGraphics.setProperties(ctx, properties);
        }

        ctx.fillRect(x, y, w, h);
        if (properties) ctx.restore();
      },
      fillPolygon: function (ctx, x, y, properties) {
        if (properties) {
          ctx.save();
          IGVGraphics.setProperties(ctx, properties);
        }

        doPath(ctx, x, y);
        ctx.fill();
        if (properties) ctx.restore();
      },
      strokePolygon: function (ctx, x, y, properties) {
        if (properties) {
          ctx.save();
          IGVGraphics.setProperties(ctx, properties);
        }

        doPath(ctx, x, y);
        ctx.stroke();
        if (properties) ctx.restore();
      },
      fillText: function (ctx, text, x, y, properties, transforms) {
        if (properties || transforms) {
          ctx.save();
        }

        if (properties) {
          IGVGraphics.setProperties(ctx, properties);
        }

        if (transforms) {
          // Slow path with context saving and extra translate
          ctx.translate(x, y);

          for (var transform in transforms) {
            var value = transforms[transform]; // TODO: Add error checking for robustness

            if (transform === 'translate') {
              ctx.translate(value['x'], value['y']);
            }

            if (transform === 'rotate') {
              ctx.rotate(value['angle'] * Math.PI / 180);
            }
          }

          ctx.fillText(text, 0, 0);
        } else {
          ctx.fillText(text, x, y);
        }

        if (properties || transforms) ctx.restore();
      },
      strokeText: function (ctx, text, x, y, properties, transforms) {
        if (properties || transforms) {
          ctx.save();
        }

        if (properties) {
          IGVGraphics.setProperties(ctx, properties);
        }

        if (transforms) {
          ctx.translate(x, y);

          for (var transform in transforms) {
            var value = transforms[transform]; // TODO: Add error checking for robustness

            if (transform === 'translate') {
              ctx.translate(value['x'], value['y']);
            }

            if (transform === 'rotate') {
              ctx.rotate(value['angle'] * Math.PI / 180);
            }
          }

          ctx.strokeText(text, 0, 0);
        } else {
          ctx.strokeText(text, x, y);
        }

        if (properties || transforms) ctx.restore();
      },
      strokeCircle: function (ctx, x, y, radius, properties) {
        if (properties) {
          ctx.save();
          IGVGraphics.setProperties(ctx, properties);
        }

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.stroke();
        if (properties) ctx.restore();
      },
      fillCircle: function (ctx, x, y, radius, properties) {
        if (properties) {
          ctx.save();
          IGVGraphics.setProperties(ctx, properties);
        }

        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        if (properties) ctx.restore();
      },
      drawArrowhead: function (ctx, x, y, size, lineWidth) {
        ctx.save();

        if (!size) {
          size = 5;
        }

        if (lineWidth) {
          ctx.lineWidth = lineWidth;
        }

        ctx.beginPath();
        ctx.moveTo(x, y - size / 2);
        ctx.lineTo(x, y + size / 2);
        ctx.lineTo(x + size, y);
        ctx.lineTo(x, y - size / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      },
      dashedLine: function (ctx, x1, y1, x2, y2, dashLen) {
        let properties = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
        if (dashLen === undefined) dashLen = 2;
        ctx.setLineDash([dashLen, dashLen]);
        IGVGraphics.strokeLine(ctx, x1, y1, x2, y2, properties);
        ctx.setLineDash([]);
      },
      roundRect: function (ctx, x, y, width, height, radius, fill, stroke) {
        if (typeof stroke == "undefined") {
          stroke = true;
        }

        if (typeof radius === "undefined") {
          radius = 5;
        }

        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();

        if (stroke) {
          ctx.stroke();
        }

        if (fill) {
          ctx.fill();
        }
      },
      polygon: function (ctx, x, y, fill, stroke) {
        if (typeof stroke == "undefined") {
          stroke = true;
        }

        ctx.beginPath();
        var len = x.length;
        ctx.moveTo(x[0], y[0]);

        for (var i = 1; i < len; i++) {
          ctx.lineTo(x[i], y[i]); // this.moveTo(x[i], y[i]);
        }

        ctx.closePath();

        if (stroke) {
          ctx.stroke();
        }

        if (fill) {
          ctx.fill();
        }
      }
    };

    function doPath(ctx, x, y) {
      var i,
          len = x.length;

      for (i = 0; i < len; i++) {
        x[i] = Math.round(x[i]);
        y[i] = Math.round(y[i]);
      }

      ctx.beginPath();
      ctx.moveTo(x[0], y[0]);

      for (i = 1; i < len; i++) {
        ctx.lineTo(x[i], y[i]);
      }

      ctx.closePath();
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    let JUNCTION_MOTIF_PALETTE = new PaletteColorTable("Dark2"); // Lock in color-to-motif mapping so it's independent of data loading order. This list may not include all possible
    // motif values as this varies depending on the RNA-seq pipeline. The current list is based on STAR v2.4 docs.

    const someMotifValues = ['GT/AG', 'CT/AC', 'GC/AG', 'CT/GC', 'AT/AC', 'GT/AT', 'non-canonical'];
    someMotifValues.forEach(motif => {
      JUNCTION_MOTIF_PALETTE.getColor(motif);
    }); // rendering context with values that only need to be computed once per render, rather than for each splice junction

    const junctionRenderingContext = {};

    class FeatureTrack extends TrackBase {
      constructor(config, browser) {
        super(config, browser); // Set maxRows -- protects against pathological feature packing cases (# of rows of overlapping feaures)

        this.maxRows = config.maxRows === undefined ? 1000 : config.maxRows;
        this.displayMode = config.displayMode || "COLLAPSED"; // COLLAPSED | EXPANDED | SQUISHED

        this.labelDisplayMode = config.labelDisplayMode;

        if (config._featureSource) {
          this.featureSource = config._featureSource;
          delete config._featureSource;
        } else {
          this.featureSource = config.featureSource ? config.featureSource : FeatureSource(config, browser.genome);
        } // Set default heights


        this.autoHeight = config.autoHeight;
        this.margin = config.margin === undefined ? 10 : config.margin;
        this.featureHeight = config.featureHeight || 14;

        if ("FusionJuncSpan" === config.type) {
          this.squishedRowHeight = config.squishedRowHeight || 50;
          this.expandedRowHeight = config.expandedRowHeight || 50;
          this.height = config.height || this.margin + 2 * this.expandedRowHeight;
        } else if ('snp' === config.type) {
          this.expandedRowHeight = config.expandedRowHeight || 10;
          this.squishedRowHeight = config.squishedRowHeight || 5;
          this.height = config.height || 30;
        } else {
          this.squishedRowHeight = config.squishedRowHeight || 15;
          this.expandedRowHeight = config.expandedRowHeight || 30;
          this.height = config.height || this.margin + 2 * this.expandedRowHeight;
        }

        if (this.height === undefined || !this.height) {
          this.height = 100;
        } //set defaults


        if ('spliceJunctions' === config.type && config.colorByNumReadsThreshold === undefined) {
          config.colorByNumReadsThreshold = 5;
        } // Set the render function.  This can optionally be passed in the config


        if (config.render) {
          this.render = config.render;
        } else if ("FusionJuncSpan" === config.type) {
          this.render = renderFusionJuncSpan;
        } else if ('spliceJunctions' === config.type) {
          this.render = renderJunctions;
          this.displayMode = "COLLAPSED"; // needed for this.clickedFeatures(..) to work
        } else if ('snp' === config.type) {
          this.render = renderSnp; // colors ordered based on priority least to greatest

          this.snpColors = ['rgb(0,0,0)', 'rgb(0,0,255)', 'rgb(0,255,0)', 'rgb(255,0,0)'];
          this.colorBy = 'function';
        } else {
          this.render = renderFeature;
          this.arrowSpacing = 30; // adjust label positions to make sure they're always visible

          monitorTrackDrag(this);
        } //UCSC useScore option


        this.useScore = config.useScore;
      }

      async postInit() {
        if (typeof this.featureSource.getHeader === "function") {
          this.header = await this.featureSource.getHeader();
        } // Set properties from track line


        if (this.header) {
          this.setTrackProperties(this.header);
        }

        if (this.visibilityWindow === undefined && typeof this.featureSource.defaultVisibilityWindow === 'function') {
          this.visibilityWindow = await this.featureSource.defaultVisibilityWindow();
          this.featureSource.visibilityWindow = this.visibilityWindow; // <- this looks odd
        }

        return this;
      }

      supportsWholeGenome() {
        return (this.config.indexed === false || !this.config.indexURL) && this.config.supportsWholeGenome !== false;
      }

      async getFeatures(chr, start, end, bpPerPixel) {
        const visibilityWindow = this.visibilityWindow;
        return this.featureSource.getFeatures({
          chr,
          start,
          end,
          bpPerPixel,
          visibilityWindow
        });
      }

      /**
       * The required height in pixels required for the track content.   This is not the visible track height, which
       * can be smaller (with a scrollbar) or larger.
       *
       * @param features
       * @returns {*}
       */
      computePixelHeight(features) {
        if (this.type === 'spliceJunctions') {
          return this.height;
        } else if (this.displayMode === "COLLAPSED") {
          return this.margin + this.expandedRowHeight;
        } else {
          let maxRow = 0;

          if (features && typeof features.forEach === "function") {
            for (let feature of features) {
              if (feature.row && feature.row > maxRow) {
                maxRow = feature.row;
              }
            }
          }

          const height = this.margin + (maxRow + 1) * ("SQUISHED" === this.displayMode ? this.squishedRowHeight : this.expandedRowHeight);
          return height;
        }
      }

      draw(options) {
        const featureList = options.features;
        const ctx = options.context;
        const bpPerPixel = options.bpPerPixel;
        const bpStart = options.bpStart;
        const pixelWidth = options.pixelWidth;
        const pixelHeight = options.pixelHeight;
        const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;

        if (!this.config.isMergedTrack) {
          IGVGraphics.fillRect(ctx, 0, options.pixelTop, pixelWidth, pixelHeight, {
            'fillStyle': "rgb(255, 255, 255)"
          });
        }

        if (featureList) {
          const rowFeatureCount = [];
          options.rowLastX = [];

          for (let feature of featureList) {
            const row = feature.row || 0;

            if (rowFeatureCount[row] === undefined) {
              rowFeatureCount[row] = 1;
            } else {
              rowFeatureCount[row]++;
            }

            options.rowLastX[row] = -Number.MAX_SAFE_INTEGER;
          }

          if (this.config.type == 'spliceJunctions') {
            junctionRenderingContext.referenceFrame = options.viewport.referenceFrame;
            junctionRenderingContext.referenceFrameStart = junctionRenderingContext.referenceFrame.start;
            junctionRenderingContext.referenceFrameEnd = junctionRenderingContext.referenceFrameStart + junctionRenderingContext.referenceFrame.toBP($(options.viewport.contentDiv).width()); // For a given viewport, records where features that are < 2px in width have been rendered already.
            // This prevents wasteful rendering of multiple such features onto the same pixels.

            junctionRenderingContext.featureZoomOutTracker = {};
          }

          let lastPxEnd = [];

          for (let feature of featureList) {
            if (feature.end < bpStart) continue;
            if (feature.start > bpEnd) break;
            const row = this.displayMode === 'COLLAPSED' ? 0 : feature.row;
            const featureDensity = pixelWidth / rowFeatureCount[row];
            options.drawLabel = options.labelAllFeatures || featureDensity > 10;
            const pxEnd = Math.ceil((feature.end - bpStart) / bpPerPixel);
            const last = lastPxEnd[row];

            if (!last || pxEnd > last || this.config.type === 'spliceJunctions') {
              this.render.call(this, feature, bpStart, bpPerPixel, pixelHeight, ctx, options);

              if (this.config.type !== 'spliceJunctions') {
                // Ensure a visible gap between features
                const pxStart = Math.floor((feature.start - bpStart) / bpPerPixel);

                if (last && pxStart - last <= 0) {
                  ctx.globalAlpha = 0.5;
                  IGVGraphics.strokeLine(ctx, pxStart, 0, pxStart, pixelHeight, {
                    'strokeStyle': "rgb(255, 255, 255)"
                  });
                  ctx.globalAlpha = 1.0;
                }

                lastPxEnd[row] = pxEnd;
              }
            }
          }
        } else {
          console.log("No feature list");
        }
      }

      clickedFeatures(clickState) {
        const y = clickState.y - this.margin;
        const allFeatures = super.clickedFeatures(clickState);
        let row;

        switch (this.displayMode) {
          case 'SQUISHED':
            row = Math.floor(y / this.squishedRowHeight);
            break;

          case 'EXPANDED':
            row = Math.floor(y / this.expandedRowHeight);
            break;

          default:
            row = undefined;
        }

        return allFeatures.filter(function (feature) {
          return row === undefined || feature.row === undefined || row === feature.row;
        });
      }
      /**
       * Return "popup data" for feature @ genomic location.  Data is an array of key-value pairs
       */


      popupData(clickState, features) {
        if (!features) features = this.clickedFeatures(clickState);
        const genomicLocation = clickState.genomicLocation;
        const data = [];

        for (let feature of features) {
          if (this.config.type === 'spliceJunctions') {
            if (!feature.isVisible || !feature.attributes) {
              continue;
            }
          }

          const featureData = typeof feature.popupData === "function" ? feature.popupData(genomicLocation) : TrackBase.extractPopupData(feature, this.getGenomeId());

          if (featureData) {
            if (data.length > 0) {
              data.push("<HR>");
            }

            Array.prototype.push.apply(data, featureData);
          }
        }

        return data;
      }

      menuItemList() {
        const self = this;
        const menuItems = [];

        if (this.render === renderSnp) {
          ["function", "class"].forEach(function (colorScheme) {
            menuItems.push({
              object: $(createCheckbox$1('Color by ' + colorScheme, colorScheme === self.colorBy)),
              click: function () {
                self.colorBy = colorScheme;
                self.trackView.repaintViews();
              }
            });
          });
          menuItems.push({
            object: $('<div class="igv-track-menu-border-top">')
          });
        }

        return menuItems;
      }

      description() {
        // if('snp' === this.type) {
        if (renderSnp === this.render) {
          let desc = "<html>" + this.name + "<hr>";
          desc += '<em>Color By Function:</em><br>';
          desc += '<span style="color:red">Red</span>: Coding-Non-Synonymous, Splice Site<br>';
          desc += '<span style="color:green">Green</span>: Coding-Synonymous<br>';
          desc += '<span style="color:blue">Blue</span>: Untranslated<br>';
          desc += '<span style="color:black">Black</span>: Intron, Locus, Unknown<br><br>';
          desc += '<em>Color By Class:</em><br>';
          desc += '<span style="color:red">Red</span>: Deletion<br>';
          desc += '<span style="color:green">Green</span>: MNP<br>';
          desc += '<span style="color:blue">Blue</span>: Microsatellite, Named<br>';
          desc += '<span style="color:black">Black</span>: Indel, Insertion, SNP';
          desc += "</html>";
          return desc;
        } else {
          return this.name;
        }
      }

      /**
       * Called when the track is removed.  Do any needed cleanup here
       */
      dispose() {
        this.trackView = undefined;
      }

    }
    /**
     * Monitors track drag events, updates label position to ensure that they're always visible.
     * @param track
     */


    function monitorTrackDrag(track) {
      if (track.browser.on) {
        track.browser.on('trackdragend', onDragEnd);
        track.browser.on('trackremoved', unSubscribe);
      }

      function onDragEnd() {
        if (!track.trackView || !track.trackView.tile || track.displayMode === "SQUISHED") {
          return;
        }
      }

      function unSubscribe(removedTrack) {
        if (track.browser.un && track === removedTrack) {
          track.browser.un('trackdrag', onDragEnd);
          track.browser.un('trackremoved', unSubscribe);
        }
      }
    }
    /**
     * @param feature
     * @param bpStart  genomic location of the left edge of the current canvas
     * @param xScale  scale in base-pairs per pixel
     * @returns {{px: number, px1: number, pw: number, h: number, py: number}}
     */


    function calculateFeatureCoordinates(feature, bpStart, xScale) {
      let px = (feature.start - bpStart) / xScale;
      let px1 = (feature.end - bpStart) / xScale; //px = Math.round((feature.start - bpStart) / xScale),
      //px1 = Math.round((feature.end - bpStart) / xScale),

      let pw = px1 - px;

      if (pw < 3) {
        pw = 3;
        px -= 1.5;
      }

      return {
        px: px,
        px1: px1,
        pw: pw
      };
    }
    /**
     * Return color for feature.  Called in the context of a FeatureTrack instance.
     * @param feature
     * @returns {string}
     */


    function getColorForFeature(feature) {
      let color;

      if (this.altColor && "-" === feature.strand) {
        color = this.altColor;
      } else if (this.color) {
        color = this.color; // Explicit setting via menu, or possibly track line if !config.color
      } else if (this.config.colorBy) {
        const colorByValue = feature[this.config.colorBy.field];

        if (colorByValue) {
          color = this.config.colorBy.pallete[colorByValue]; // This is an undocumented option, and its not clear if its used
        }
      } else if (feature.color) {
        color = feature.color; // Explicit color for feature
      } else {
        color = this.defaultColor; // Track default
      }

      if (feature.alpha && feature.alpha !== 1) {
        color = IGVColor.addAlpha(color, feature.alpha);
      } else if (this.useScore && feature.score && !Number.isNaN(feature.score)) {
        // UCSC useScore option, for scores between 0-1000.  See https://genome.ucsc.edu/goldenPath/help/customTrack.html#TRACK
        const min = this.config.min ? this.config.min : 0; //getViewLimitMin(track);

        const max = this.config.max ? this.config.max : 1000; //getViewLimitMax(track);

        const alpha = getAlpha(min, max, feature.score);
        feature.alpha = alpha; // Avoid computing again

        color = IGVColor.addAlpha(color, alpha);
      }

      function getAlpha(min, max, score) {
        const binWidth = (max - min) / 9;
        const binNumber = Math.floor((score - min) / binWidth);
        return Math.min(1.0, 0.2 + binNumber * 0.8 / 9);
      }

      return color;
    }
    /**
     *
     * @param feature
     * @param bpStart  genomic location of the left edge of the current canvas
     * @param xScale  scale in base-pairs per pixel
     * @param pixelHeight  pixel height of the current canvas
     * @param ctx  the canvas 2d context
     * @param options  genomic state
     */


    function renderFeature(feature, bpStart, xScale, pixelHeight, ctx, options) {
      this.browser;
      let color = getColorForFeature.call(this, feature);
      ctx.fillStyle = color;
      ctx.strokeStyle = color;
      let h;
      let py;

      if (this.displayMode === "SQUISHED" && feature.row !== undefined) {
        h = this.featureHeight / 2;
        py = this.margin + this.squishedRowHeight * feature.row;
      } else if (this.displayMode === "EXPANDED" && feature.row !== undefined) {
        h = this.featureHeight;
        py = this.margin + this.expandedRowHeight * feature.row;
      } else {
        // collapsed
        h = this.featureHeight;
        py = this.margin;
      }

      const cy = py + h / 2;
      const h2 = h / 2;
      const py2 = cy - h2 / 2;
      const exonCount = feature.exons ? feature.exons.length : 0;
      const coord = calculateFeatureCoordinates(feature, bpStart, xScale);
      const step = this.arrowSpacing;
      const direction = feature.strand === '+' ? 1 : feature.strand === '-' ? -1 : 0;

      if (exonCount === 0) {
        // single-exon transcript
        ctx.fillRect(coord.px, py, coord.pw, h); // Arrows
        // Do not draw if strand is not +/-

        if (direction !== 0) {
          ctx.fillStyle = "white";
          ctx.strokeStyle = "white";

          for (let x = coord.px + step / 2; x < coord.px1; x += step) {
            // draw arrowheads along central line indicating transcribed orientation
            IGVGraphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);
            IGVGraphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);
          }

          ctx.fillStyle = color;
          ctx.strokeStyle = color;
        }
      } else {
        // multi-exon transcript
        IGVGraphics.strokeLine(ctx, coord.px + 1, cy, coord.px1 - 1, cy); // center line for introns

        const pixelWidth = options.pixelWidth;
        const xLeft = Math.max(0, coord.px) + step / 2;
        const xRight = Math.min(pixelWidth, coord.px1);

        for (let x = xLeft; x < xRight; x += step) {
          // draw arrowheads along central line indicating transcribed orientation
          IGVGraphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);
          IGVGraphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);
        }

        for (let e = 0; e < exonCount; e++) {
          // draw the exons
          const exon = feature.exons[e];
          let ePx = Math.round((exon.start - bpStart) / xScale);
          let ePx1 = Math.round((exon.end - bpStart) / xScale);
          let ePw = Math.max(1, ePx1 - ePx);
          let ePxU;

          if (ePx + ePw < 0) {
            continue; // Off the left edge
          }

          if (ePx > pixelWidth) {
            break; // Off the right edge
          }

          if (exon.utr) {
            ctx.fillRect(ePx, py2, ePw, h2); // Entire exon is UTR
          } else {
            if (exon.cdStart) {
              ePxU = Math.round((exon.cdStart - bpStart) / xScale);
              ctx.fillRect(ePx, py2, ePxU - ePx, h2); // start is UTR

              ePw -= ePxU - ePx;
              ePx = ePxU;
            }

            if (exon.cdEnd) {
              ePxU = Math.round((exon.cdEnd - bpStart) / xScale);
              ctx.fillRect(ePxU, py2, ePx1 - ePxU, h2); // start is UTR

              ePw -= ePx1 - ePxU;
              ePx1 = ePxU;
            }

            ctx.fillRect(ePx, py, ePw, h); // Arrows

            if (ePw > step + 5 && direction !== 0) {
              ctx.fillStyle = "white";
              ctx.strokeStyle = "white";

              for (let x = ePx + step / 2; x < ePx1; x += step) {
                // draw arrowheads along central line indicating transcribed orientation
                IGVGraphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);
                IGVGraphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);
              }

              ctx.fillStyle = color;
              ctx.strokeStyle = color;
            }
          }
        }
      }

      const windowX = Math.round(options.viewportContainerX); // const nLoci = browser.referenceFrameList ? browser.referenceFrameList.length : 1
      // const windowX1 = windowX + options.viewportContainerWidth / nLoci;

      const windowX1 = windowX + options.viewportWidth;

      if (options.drawLabel) {
        renderFeatureLabel.call(this, ctx, feature, coord.px, coord.px1, py, windowX, windowX1, options.referenceFrame, options);
      }
    }
    /**
     * @param ctx       the canvas 2d context
     * @param feature
     * @param featureX  feature start x-coordinate
     * @param featureX1 feature end x-coordinate
     * @param featureY  feature y-coordinate
     * @param windowX   visible window start x-coordinate
     * @param windowX1  visible window end x-coordinate
     * @param referenceFrame  genomic state
     * @param options  options
     */


    function renderFeatureLabel(ctx, feature, featureX, featureX1, featureY, windowX, windowX1, referenceFrame, options) {
      let name = feature.name;
      if (name === undefined && feature.gene) name = feature.gene.name;
      if (name === undefined) name = feature.id || feature.ID;
      if (!name || name === '.') return; // feature outside of viewable window

      let boxX;
      let boxX1;

      if (featureX1 < windowX || featureX > windowX1) {
        boxX = featureX;
        boxX1 = featureX1;
      } else {
        // center label within visible portion of the feature
        boxX = Math.max(featureX, windowX);
        boxX1 = Math.min(featureX1, windowX1);
      }

      let color = getColorForFeature.call(this, feature);
      let geneColor;
      let gtexSelection = false;

      if (referenceFrame.selection && GtexUtils.gtexLoaded) {
        // TODO -- for gtex, figure out a better way to do this
        gtexSelection = true;
        geneColor = referenceFrame.selection.colorForGene(name);
      }

      if (this.displayMode !== "SQUISHED") {
        const geneFontStyle = {
          textAlign: "SLANT" === this.labelDisplayMode ? undefined : 'center',
          fillStyle: geneColor || color,
          strokeStyle: geneColor || color
        };
        let transform;

        if (this.displayMode === "COLLAPSED" && this.labelDisplayMode === "SLANT") {
          transform = {
            rotate: {
              angle: 45
            }
          };
        }

        const labelX = boxX + (boxX1 - boxX) / 2;
        const labelY = getFeatureLabelY(featureY, transform);
        const textBox = ctx.measureText(name);
        const xleft = labelX - textBox.width / 2;
        const xright = labelX + textBox.width / 2;

        if (options.labelAllFeatures || xleft > options.rowLastX[feature.row] || gtexSelection) {
          options.rowLastX[feature.row] = xright; // This is for compatibility with JuiceboxJS.

          if (options.labelTransform) {
            ctx.save();
            options.labelTransform(ctx, labelX);
            IGVGraphics.fillText(ctx, name, labelX, labelY, geneFontStyle, undefined);
            ctx.restore();
          } else {
            IGVGraphics.fillText(ctx, name, labelX, labelY, geneFontStyle, transform);
          }
        }
      }
    }

    function getFeatureLabelY(featureY, transform) {
      return transform ? featureY + 20 : featureY + 25;
    }
    /**
     *
     * @param feature
     * @param bpStart  genomic location of the left edge of the current canvas
     * @param xScale  scale in base-pairs per pixel
     * @param pixelHeight  pixel height of the current canvas
     * @param ctx  the canvas 2d context
     */


    function renderFusionJuncSpan(feature, bpStart, xScale, pixelHeight, ctx) {
      var py;
      var rowHeight = this.displayMode === "EXPANDED" ? this.expandedRowHeight : this.squishedRowHeight;

      if (this.display === "COLLAPSED") {
        py = this.margin;
      }

      if (this.displayMode === "SQUISHED" && feature.row !== undefined) {
        py = this.margin + rowHeight * feature.row;
      } else if (this.displayMode === "EXPANDED" && feature.row !== undefined) {
        py = this.margin + rowHeight * feature.row;
      }

      var cy = py + 0.5 * rowHeight;
      var topY = cy - 0.5 * rowHeight;
      var bottomY = cy + 0.5 * rowHeight; // draw the junction arc

      var junctionLeftPx = Math.round((feature.junction_left - bpStart) / xScale);
      var junctionRightPx = Math.round((feature.junction_right - bpStart) / xScale);
      ctx.beginPath();
      ctx.moveTo(junctionLeftPx, cy);
      ctx.bezierCurveTo(junctionLeftPx, topY, junctionRightPx, topY, junctionRightPx, cy);
      ctx.lineWidth = 1 + Math.log(feature.num_junction_reads) / Math.log(2);
      ctx.strokeStyle = 'blue';
      ctx.stroke(); // draw the spanning arcs

      var spanningCoords = feature.spanning_frag_coords;

      for (var i = 0; i < spanningCoords.length; i++) {
        var spanningInfo = spanningCoords[i];
        var spanLeftPx = Math.round((spanningInfo.left - bpStart) / xScale);
        var spanRightPx = Math.round((spanningInfo.right - bpStart) / xScale);
        ctx.beginPath();
        ctx.moveTo(spanLeftPx, cy);
        ctx.bezierCurveTo(spanLeftPx, bottomY, spanRightPx, bottomY, spanRightPx, cy);
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'purple';
        ctx.stroke();
      }
    }
    /**
     *
     * @param feature
     * @param bpStart  genomic location of the left edge of the current canvas
     * @param xScale  scale in base-pairs per pixel
     * @param pixelHeight  pixel height of the current canvas
     * @param ctx  the canvas 2d context
     */


    function renderJunctions(feature, bpStart, xScale, pixelHeight, ctx) {
      // cache whether this junction is rendered or filtered out. Use later to exclude non-rendered junctions from click detection.
      feature.isVisible = false;
      const junctionLeftPx = Math.round((feature.start - bpStart) / xScale);
      const junctionRightPx = Math.round((feature.end - bpStart) / xScale);
      const junctionMiddlePx = (junctionLeftPx + junctionRightPx) / 2;

      if (junctionRightPx - junctionLeftPx <= 3) {
        if (junctionMiddlePx in junctionRenderingContext.featureZoomOutTracker) {
          return;
        }

        junctionRenderingContext.featureZoomOutTracker[junctionMiddlePx] = true;
      } // TODO: cache filter and pixel calculations by doing them earlier when features are initially parsed?


      if (this.config.hideAnnotatedJunctions && feature.attributes.annotated_junction === "true") {
        return;
      }

      if (this.config.hideUnannotatedJunctions && feature.attributes.annotated_junction === "false") {
        return;
      }

      if (this.config.hideMotifs && this.config.hideMotifs.includes(feature.attributes.motif)) {
        return;
      }

      if (this.config.hideStrand === feature.strand) {
        return;
      } // check if splice junction is inside viewport


      if (this.config.minJunctionEndsVisible) {
        let numJunctionEndsVisible = 0;

        if (feature.start >= junctionRenderingContext.referenceFrameStart && feature.start <= junctionRenderingContext.referenceFrameEnd) {
          numJunctionEndsVisible += 1;
        }

        if (feature.end >= junctionRenderingContext.referenceFrameStart && feature.end <= junctionRenderingContext.referenceFrameEnd) {
          numJunctionEndsVisible += 1;
        }

        if (numJunctionEndsVisible < this.config.minJunctionEndsVisible) {
          return;
        }
      }

      let uniquelyMappedReadCount;
      let multiMappedReadCount;
      let totalReadCount;

      if (feature.attributes.uniquely_mapped) {
        uniquelyMappedReadCount = parseInt(feature.attributes.uniquely_mapped);

        if (uniquelyMappedReadCount < this.config.minUniquelyMappedReads) {
          return;
        }

        multiMappedReadCount = parseInt(feature.attributes.multi_mapped);
        totalReadCount = uniquelyMappedReadCount + multiMappedReadCount;

        if (totalReadCount < this.config.minTotalReads) {
          return;
        }

        if (totalReadCount > 0 && multiMappedReadCount / totalReadCount > this.config.maxFractionMultiMappedReads) {
          return;
        }

        if (feature.attributes.maximum_spliced_alignment_overhang && parseInt(feature.attributes.maximum_spliced_alignment_overhang) < this.config.minSplicedAlignmentOverhang) {
          return;
        }
      }

      let numSamplesWithThisJunction;

      if (feature.attributes.num_samples_with_this_junction) {
        numSamplesWithThisJunction = parseInt(feature.attributes.num_samples_with_this_junction);

        if (this.config.minSamplesWithThisJunction && numSamplesWithThisJunction < this.config.minSamplesWithThisJunction) {
          return;
        }

        if (this.config.maxSamplesWithThisJunction && numSamplesWithThisJunction > this.config.maxSamplesWithThisJunction) {
          return;
        }

        if (feature.attributes.num_samples_total) {
          feature.attributes.percent_samples_with_this_junction = 100 * numSamplesWithThisJunction / parseFloat(feature.attributes.num_samples_total);

          if (this.config.minPercentSamplesWithThisJunction) {
            if (feature.attributes.percent_samples_with_this_junction < this.config.minPercentSamplesWithThisJunction || feature.attributes.percent_samples_with_this_junction > this.config.maxPercentSamplesWithThisJunction) {
              return;
            }
          }
        }
      }

      const py = this.margin;
      const rowHeight = this.height;
      const cy = py + 0.5 * rowHeight;
      let topY = py;
      const bottomY = py + rowHeight;
      const bezierBottomY = bottomY - 10; // draw the junction arc

      const bezierControlLeftPx = (junctionLeftPx + junctionMiddlePx) / 2;
      const bezierControlRightPx = (junctionMiddlePx + junctionRightPx) / 2;
      let lineWidth = 1;

      if (feature.attributes.line_width) {
        lineWidth = parseFloat(feature.attributes.line_width);
      } else {
        if (this.config.thicknessBasedOn === undefined || this.config.thicknessBasedOn === 'numUniqueReads') {
          lineWidth = uniquelyMappedReadCount;
        } else if (this.config.thicknessBasedOn === 'numReads') {
          lineWidth = totalReadCount;
        } else if (this.config.thicknessBasedOn === 'numSamplesWithThisJunction') {
          if (numSamplesWithThisJunction !== undefined) {
            lineWidth = numSamplesWithThisJunction;
          }
        }

        lineWidth = 1 + Math.log(lineWidth + 1) / Math.log(12);
      }

      let bounceHeight;

      if (this.config.bounceHeightBasedOn === undefined || this.config.bounceHeightBasedOn === 'random') {
        // randomly but deterministically stagger topY coordinates to reduce overlap
        bounceHeight = (feature.start + feature.end) % 7;
      } else if (this.config.bounceHeightBasedOn === 'distance') {
        bounceHeight = 6 * (feature.end - feature.start) / (junctionRenderingContext.referenceFrameEnd - junctionRenderingContext.referenceFrameStart);
      } else if (this.config.bounceHeightBasedOn === 'thickness') {
        bounceHeight = 2 * lineWidth;
      }

      topY += rowHeight * Math.max(7 - bounceHeight, 0) / 10;
      let color;

      if (feature.attributes.color) {
        color = feature.attributes.color; // Explicit setting
      } else if (this.config.colorBy === undefined || this.config.colorBy === 'numUniqueReads') {
        color = uniquelyMappedReadCount > this.config.colorByNumReadsThreshold ? 'blue' : '#AAAAAA'; // color gradient?
      } else if (this.config.colorBy === 'numReads') {
        color = totalReadCount > this.config.colorByNumReadsThreshold ? 'blue' : '#AAAAAA';
      } else if (this.config.colorBy === 'isAnnotatedJunction') {
        color = feature.attributes.annotated_junction === "true" ? '#b0b0ec' : 'orange';
      } else if (this.config.colorBy === 'strand') {
        color = feature.strand === "+" ? '#b0b0ec' : '#ecb0b0';
      } else if (this.config.colorBy === 'motif') {
        color = JUNCTION_MOTIF_PALETTE.getColor(feature.attributes.motif);
      } else {
        color = '#AAAAAA';
      }

      let label = "";

      if (feature.attributes.label) {
        label = feature.attributes.label.replace(/_/g, " ");
      } else if (this.config.labelWith === undefined || this.config.labelWith === 'uniqueReadCount') {
        //default label
        label = uniquelyMappedReadCount;
      } else if (this.config.labelWith === 'totalReadCount') {
        label = totalReadCount;
      } else if (this.config.labelWith === 'numSamplesWithThisJunction') {
        if (numSamplesWithThisJunction !== undefined) {
          label = numSamplesWithThisJunction;
        }
      } else if (this.config.labelWith === 'percentSamplesWithThisJunction') {
        if (feature.attributes.percent_samples_with_this_junction !== undefined) {
          label = feature.attributes.percent_samples_with_this_junction.toFixed(0) + '%';
        }
      } else if (this.config.labelWith === 'motif') {
        if (feature.attributes.motif !== undefined) {
          label += feature.attributes.motif;
        }
      }

      if (this.config.labelWithInParen === 'uniqueReadCount') {
        label += ' (' + uniquelyMappedReadCount + ')';
      } else if (this.config.labelWithInParen === 'totalReadCount') {
        label += ' (' + totalReadCount + ')';
      } else if (this.config.labelWithInParen === 'multiMappedReadCount') {
        if (multiMappedReadCount > 0) {
          label += ' (+' + multiMappedReadCount + ')';
        }
      } else if (this.config.labelWithInParen === 'numSamplesWithThisJunction') {
        if (numSamplesWithThisJunction !== undefined) {
          label += ' (' + numSamplesWithThisJunction + ')';
        }
      } else if (this.config.labelWithInParen === 'percentSamplesWithThisJunction') {
        if (feature.attributes.percent_samples_with_this_junction !== undefined) {
          label += ' (' + feature.attributes.percent_samples_with_this_junction.toFixed(0) + '%)';
        }
      } else if (this.config.labelWithInParen === 'motif') {
        if (feature.attributes.motif !== undefined) {
          label += ` ${feature.attributes.motif}`;
        }
      } // data source: STAR splice junctions (eg. SJ.out.tab file converted to bed).
      // .bed "name" field used to store unique + multi-mapped read counts, so:
      // feature.score:  unique spanning read counts
      // feature.name:   unique + multi-mapped spanning read counts
      //example feature:  { chr: "chr17", start: 39662344, end: 39662803, name: "59", row: 0, score: 38, strand: "+"}


      feature.isVisible = true;
      ctx.beginPath();
      ctx.moveTo(junctionLeftPx, bezierBottomY);
      ctx.bezierCurveTo(bezierControlLeftPx, topY, bezierControlRightPx, topY, junctionRightPx, bezierBottomY);
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = color;
      ctx.stroke();

      const drawArrowhead = (ctx, x, y, size) => {
        //TODO draw better arrow heads: https://stackoverflow.com/questions/21052972/curved-thick-arrows-on-canvas
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - size / 2, y - size);
        ctx.lineTo(x + size / 2, y - size);
        ctx.lineTo(x, y);
        ctx.closePath();
        ctx.fill();
      };

      if (feature.attributes.left_shape || feature.attributes.right_shape) {
        ctx.fillStyle = color;
        const arrowSize = ctx.lineWidth > 2 ? 10 : 7;

        if (feature.attributes.left_shape) {
          drawArrowhead(ctx, junctionLeftPx, bezierBottomY, arrowSize);
        }

        if (feature.attributes.right_shape) {
          drawArrowhead(ctx, junctionRightPx, bezierBottomY, arrowSize);
        }
      }

      ctx.fillText(label, junctionMiddlePx - ctx.measureText(label).width / 2, (7 * topY + cy) / 8);
    } // SNP constants


    const codingNonSynonSet = new Set(['nonsense', 'missense', 'stop-loss', 'frameshift', 'cds-indel']);
    const codingSynonSet = new Set(['coding-synon']);
    const spliceSiteSet = new Set(['splice-3', 'splice-5']);
    const untranslatedSet = new Set(['untranslated-5', 'untranslated-3']);
    /**
     * Renderer for a UCSC snp track
     *
     * @param snp
     * @param bpStart  genomic location of the left edge of the current canvas
     * @param xScale  scale in base-pairs per pixel
     * @param pixelHeight  pixel height of the current canvas
     * @param ctx  the canvas 2d context
     */

    function renderSnp(snp, bpStart, xScale, pixelHeight, ctx) {
      var coord = calculateFeatureCoordinates(snp, bpStart, xScale),
          py = this.margin,
          h,
          colorArrLength = this.snpColors.length,
          colorPriority;
      h = this.displayMode === "squished" ? this.squishedRowHeight : this.expandedRowHeight;

      switch (this.colorBy) {
        case 'function':
          colorPriority = colorByFunc(snp.func);
          break;

        case 'class':
          colorPriority = colorByClass(snp['class']);
      }

      ctx.fillStyle = this.snpColors[colorPriority];
      ctx.fillRect(coord.px, py, coord.pw, h); // Coloring functions, convert a value to a priority

      function colorByFunc(theFunc) {
        var priorities;
        var funcArray = theFunc.split(','); // possible func values

        priorities = funcArray.map(function (func) {
          if (codingNonSynonSet.has(func) || spliceSiteSet.has(func)) {
            return colorArrLength - 1;
          } else if (codingSynonSet.has(func)) {
            return colorArrLength - 2;
          } else if (untranslatedSet.has(func)) {
            return colorArrLength - 3;
          } else {
            // locusSet.has(func) || intronSet.has(func)
            return 0;
          }
        });
        return priorities.reduce(function (a, b) {
          return Math.max(a, b);
        });
      }

      function colorByClass(cls) {
        if (cls === 'deletion') {
          return colorArrLength - 1;
        } else if (cls === 'mnp') {
          return colorArrLength - 2;
        } else if (cls === 'microsatellite' || cls === 'named') {
          return colorArrLength - 3;
        } else {
          // cls === 'single' || cls === 'in-del' || cls === 'insertion'
          return 0;
        }
      }
    }

    function paintAxis(ctx, pixelWidth, pixelHeight) {
      var x1,
          x2,
          y1,
          y2,
          a,
          b,
          reference,
          shim,
          font = {
        'font': 'normal 10px Arial',
        'textAlign': 'right',
        'strokeStyle': "black"
      };

      if (undefined === this.dataRange || undefined === this.dataRange.max || undefined === this.dataRange.min) {
        return;
      }

      IGVGraphics.fillRect(ctx, 0, 0, pixelWidth, pixelHeight, {
        'fillStyle': "rgb(255, 255, 255)"
      });
      reference = 0.95 * pixelWidth;
      x1 = reference - 8;
      x2 = reference; //shim = 0.5 * 0.125;

      shim = .01;
      y1 = y2 = shim * pixelHeight;
      a = {
        x: x2,
        y: y1
      }; // tick

      IGVGraphics.strokeLine(ctx, x1, y1, x2, y2, font);
      IGVGraphics.fillText(ctx, prettyPrint(this.dataRange.max), x1 + 4, y1 + 12, font); //shim = 0.25 * 0.125;

      y1 = y2 = (1.0 - shim) * pixelHeight;
      b = {
        x: x2,
        y: y1
      }; // tick

      IGVGraphics.strokeLine(ctx, x1, y1, x2, y2, font);
      IGVGraphics.fillText(ctx, prettyPrint(this.dataRange.min), x1 + 4, y1 - 4, font);
      IGVGraphics.strokeLine(ctx, a.x, a.y, b.x, b.y, font);

      function prettyPrint(number) {
        // if number >= 100, show whole number
        // if >= 1 show 1 significant digits
        // if <  1 show 2 significant digits
        if (number === 0) {
          return "0";
        } else if (Math.abs(number) >= 10) {
          return number.toFixed();
        } else if (Math.abs(number) >= 1) {
          return number.toFixed(1);
        } else {
          return number.toFixed(2);
        }
      }
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     * Author: Jim Robinson
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     *
     * This class uses icons from Font Awesome
     * Font Awesome Free 5.0.8 by @fontawesome - https://fontawesome.com
     * License - https://fontawesome.com/license (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
     */

    function createCheckbox(name, initialState) {
      let $container = $('<div>', {
        class: 'igv-menu-popup-check-container'
      });
      let $div = $('<div>');
      $container.append($div);
      let $svg = iconMarkup('check', true === initialState ? '#444' : 'transparent');
      $div.append($svg);
      let $label = $('<div>'
      /*, { class: 'igv-some-label-class' }*/
      );
      $label.text(name);
      $container.append($label);
      return $container;
    }

    function createIcon(name, color) {
      return $(iconMarkup(name, color));
    }

    function iconMarkup(name, color) {
      color = color || "currentColor";
      let icon = icons[name];

      if (!icon) {
        console.error(`No icon named: ${name}`);
        icon = icons["question"];
      }

      let svg = '<svg ' + 'viewBox="0 0 ' + icon[0] + ' ' + icon[1] + '">';
      svg += '<path fill="' + color + '" ' + 'd="' + icon[4] + '">' + '</path>';
      svg += '</svg>';
      return svg;
    }

    const icons = {
      "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
      "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
      "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
      "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
      "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
      "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
      "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
      "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
      "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
      "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
      "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
      "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
      "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
      "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
      "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
      "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
      "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
      "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
      "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
      "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
      "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"]
    };

    /**
     * Configure item list for track "gear" menu.
     * @param trackRenderer
     */

    const MenuUtils = {
      trackMenuItemList: function (trackPair) {
        let menuItems = [];
        menuItems.push(trackRenameMenuItem(trackPair));
        menuItems.push("<hr/>");
        menuItems.push(colorPickerMenuItem({
          trackRenderer: trackPair,
          label: "Set color",
          option: "color"
        }));
        menuItems.push(unsetColorMenuItem({
          trackRenderer: trackPair,
          label: "Unset color"
        }));
        const trackMenuItems = trackPair.track.menuItemList();

        if (trackMenuItems && trackMenuItems.length > 0) {
          menuItems.push('<hr/>');
          menuItems.push.apply(menuItems, trackMenuItems);
        } // const vizWindowTypes = new Set(['alignment', 'annotation', 'variant', 'eqtl', 'snp']);
        // const hasVizWindow = trackRenderer.track.config && trackRenderer.track.config.visibilityWindow !== undefined;
        // if (hasVizWindow || vizWindowTypes.has(trackRenderer.track.config.type)) {
        //     menuItems.push('<hr/>');
        //     menuItems.push(visibilityWindowMenuItem(trackRenderer));
        // }


        if (trackPair.track.removable !== false) {
          menuItems.push('<hr/>');
          menuItems.push(trackRemovalMenuItem(trackPair));
        }

        return menuItems;
      },
      numericDataMenuItems: function (trackPair) {
        const menuItems = []; // Data range

        const $e = $('<div>');
        $e.text('Set data range');

        const clickHandler = function () {
          const currentDataRange = trackPair.track.dataRange;
          trackPair.dataRangeDialog.show({
            min: currentDataRange.min || 0,
            max: currentDataRange.max
          });
        };

        menuItems.push({
          object: $e,
          click: clickHandler
        });

        if (trackPair.track.logScale !== undefined) {
          menuItems.push({
            object: createCheckbox("Log scale", trackPair.track.logScale),
            click: () => {
              trackPair.track.logScale = !trackPair.track.logScale;
              trackPair.repaintViews();
            }
          });
        }

        menuItems.push({
          object: createCheckbox("Autoscale", trackPair.track.autoscale),
          click: () => {
            trackPair.track.autoscale = !trackPair.track.autoscale;
            trackPair.repaintViews();
          }
        });
        return menuItems;
      }
    };

    function trackRemovalMenuItem(trackRenderer) {
      var $e, menuClickHandler;
      $e = $('<div>');
      $e.text('Remove track');

      menuClickHandler = function menuClickHandler() {
        var browser = trackRenderer.browser;
        browser.layoutController.removeTrackXYPair(trackRenderer);
      };

      return {
        object: $e,
        click: menuClickHandler
      };
    }

    function colorPickerMenuItem(_ref) {
      let {
        trackRenderer,
        label,
        option
      } = _ref;
      var $e, clickHandler;
      $e = $('<div>');
      $e.text(label);

      clickHandler = function () {
        trackRenderer.colorPicker.show();
      };

      return {
        object: $e,
        click: clickHandler
      };
    }

    function unsetColorMenuItem(_ref2) {
      let {
        trackRenderer,
        label
      } = _ref2;
      const $e = $('<div>');
      $e.text(label);
      return {
        object: $e,
        click: () => {
          trackRenderer.track.color = undefined;
          trackRenderer.repaintViews();
        }
      };
    }

    function trackRenameMenuItem(trackRenderer) {
      const click = e => {
        const callback = value => {
          value = value.trim();
          value = '' === value || undefined === value ? 'untitled' : value;
          trackRenderer.setTrackName(value);
        };

        trackRenderer.browser.inputDialog.present({
          label: 'Track Name',
          value: trackRenderer.track.name,
          callback
        }, e);
      };

      const object = $('<div>');
      object.text('Set track name');
      return {
        object,
        click
      };
    } // function visibilityWindowMenuItem(trackRenderer) {

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    const DEFAULT_COLOR = "rgb(150,150,150)";

    class WigTrack extends TrackBase {
      constructor(config, browser) {
        super(config, browser);
        this.type = "wig";
        this.height = config.height || 50;
        this.featureType = 'numeric';
        const format = config.format ? config.format.toLowerCase() : config.format;

        if ("bigwig" === format) {
          this.featureSource = new BWSource(config, browser.genome);
        } else if ("tdf" === format) {
          this.featureSource = new TDFSource(config, browser.genome);
        } else {
          this.featureSource = FeatureSource(config, browser.genome);
        }

        this.autoscale = config.autoscale || config.max === undefined;

        if (!this.autoscale) {
          this.dataRange = {
            min: config.min || 0,
            max: config.max
          };
        }

        this.windowFunction = config.windowFunction || "mean";
        this.paintAxis = paintAxis;
        this.graphType = config.graphType || "bar";
        this.normalize = config.normalize; // boolean, for use with "TDF" files

        this.scaleFactor = config.scaleFactor; // optional scale factor, ignored if normalize === true;
      }

      async postInit() {
        const header = await this.getHeader();
        if (header) this.setTrackProperties(header);
      }

      async getFeatures(chr, start, end, bpPerPixel) {
        const features = await this.featureSource.getFeatures({
          chr,
          start,
          end,
          bpPerPixel,
          windowFunction: this.windowFunction
        });

        if (this.normalize && this.featureSource.normalizationFactor) {
          const scaleFactor = this.featureSource.normalizationFactor;

          for (let f of features) {
            f.value *= scaleFactor;
          }
        }

        if (this.scaleFactor) {
          const scaleFactor = this.scaleFactor;

          for (let f of features) {
            f.value *= scaleFactor;
          }
        }

        return features;
      }

      menuItemList() {
        return MenuUtils.numericDataMenuItems(this.trackView);
      }

      async getHeader() {
        if (typeof this.featureSource.getHeader === "function") {
          this.header = await this.featureSource.getHeader();
        }

        return this.header;
      }

      draw(options) {
        const features = options.features;
        const ctx = options.context;
        const bpPerPixel = options.bpPerPixel;
        const bpStart = options.bpStart;
        const pixelWidth = options.pixelWidth;
        const pixelHeight = options.pixelHeight;
        const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
        let lastPixelEnd = -1;
        let lastValue = -1;
        let lastNegValue = 1;
        const posColor = this.color || DEFAULT_COLOR;
        let baselineColor;

        if (typeof posColor === "string" && posColor.startsWith("rgb(")) {
          baselineColor = IGVColor.addAlpha(posColor, 0.1);
        }

        const yScale = yValue => {
          return (this.dataRange.max - yValue) / (this.dataRange.max - this.dataRange.min) * pixelHeight;
        };

        if (features && features.length > 0) {
          if (this.dataRange.min === undefined) this.dataRange.min = 0; // Max can be less than min if config.min is set but max left to autoscale.   If that's the case there is
          // nothing to paint.

          if (this.dataRange.max > this.dataRange.min) {
            const y0 = this.dataRange.min == 0 ? pixelHeight : yScale(0);

            for (let f of features) {
              if (f.end < bpStart) continue;
              if (f.start > bpEnd) break;
              const x = Math.floor((f.start - bpStart) / bpPerPixel);
              if (isNaN(x)) continue;
              let y = yScale(f.value);
              const rectEnd = Math.ceil((f.end - bpStart) / bpPerPixel);
              const width = Math.max(1, rectEnd - x);
              let c = f.value < 0 && this.altColor ? this.altColor : posColor;
              const color = typeof c === "function" ? c(f.value) : c;

              if (this.graphType === "points") {
                const pointSize = this.config.pointSize || 3;
                const px = x + width / 2;
                IGVGraphics.fillCircle(ctx, px, y, pointSize / 2, {
                  "fillStyle": color,
                  "strokeStyle": color
                });
              } else {
                let height = y - y0;

                if (Math.abs(height) < 1) {
                  height = height < 0 ? -1 : 1;
                }

                const pixelEnd = x + width;

                if (pixelEnd > lastPixelEnd || f.value >= 0 && f.value > lastValue || f.value < 0 && f.value < lastNegValue) {
                  IGVGraphics.fillRect(ctx, x, y0, width, height, {
                    fillStyle: color
                  });
                }

                lastValue = f.value;
                lastPixelEnd = pixelEnd;
              }
            } // If the track includes negative values draw a baseline


            if (this.dataRange.min < 0) {
              const basepx = this.dataRange.max / (this.dataRange.max - this.dataRange.min) * options.pixelHeight;
              IGVGraphics.strokeLine(ctx, 0, basepx, options.pixelWidth, basepx, {
                strokeStyle: baselineColor
              });
            }
          }
        } // Draw guidelines


        if (this.config.hasOwnProperty('guideLines')) {
          for (let line of this.config.guideLines) {
            if (line.hasOwnProperty('color') && line.hasOwnProperty('y') && line.hasOwnProperty('dotted')) {
              let y = yScale(line.y);
              let props = {
                'strokeStyle': line['color'],
                'strokeWidth': 2
              };
              if (line['dotted']) IGVGraphics.dashedLine(options.context, 0, y, options.pixelWidth, y, 5, props);else IGVGraphics.strokeLine(options.context, 0, y, options.pixelWidth, y, props);
            }
          }
        }
      }

      popupData(clickState, features) {
        // We use the featureCache property rather than method to avoid async load.  If the
        // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.
        if (!features) features = this.clickedFeatures(clickState);

        if (features && features.length > 0) {
          let genomicLocation = clickState.genomicLocation;
          let referenceFrame = clickState.viewport.referenceFrame;
          let popupData = []; // We need some tolerance around genomicLocation, start with +/- 2 pixels

          let tolerance = 2 * referenceFrame.bpPerPixel;
          let selectedFeature = binarySearch(features, genomicLocation, tolerance);

          if (selectedFeature) {
            let posString = selectedFeature.end - selectedFeature.start === 1 ? numberFormatter(selectedFeature.start + 1) : numberFormatter(selectedFeature.start + 1) + "-" + numberFormatter(selectedFeature.end);
            popupData.push({
              name: "Position:",
              value: posString
            });
            popupData.push({
              name: "Value:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",
              value: numberFormatter(selectedFeature.value)
            });
          }

          return popupData;
        } else {
          return [];
        }
      }

      supportsWholeGenome() {
        if (typeof this.featureSource.supportsWholeGenome === 'function') {
          return this.featureSource.supportsWholeGenome();
        } else {
          return false;
        }
      }
      /**
       * Called when the track is removed.  Do any needed cleanup here
       */


      dispose() {
        this.trackView = undefined;
      }

    }
    /**
     * Return the closest feature to the genomic position +/- the specified tolerance.  Closest is defined
     * by the minimum of the distance between position and start or end of the feature.
     *
     * @param features
     * @param position
     * @returns {*}
     */


    function binarySearch(features, position, tolerance) {
      var startIndex = 0,
          stopIndex = features.length - 1,
          index = startIndex + stopIndex >> 1,
          candidateFeature,
          tmp; // Use binary search to get the index of at least 1 feature in the click tolerance bounds

      while (!test(features[index], position, tolerance) && startIndex < stopIndex) {
        if (position < features[index].start) {
          stopIndex = index - 1;
        } else if (position > features[index].end) {
          startIndex = index + 1;
        }

        index = startIndex + stopIndex >> 1;
      }

      if (test(features[index], position, tolerance)) {
        candidateFeature = features[index];
        if (test(candidateFeature, position, 0)) return candidateFeature; // Else, find closest feature to click

        tmp = index;

        while (tmp-- >= 0) {
          if (!test(features[tmp]), tolerance) {
            break;
          }

          if (test(features[tmp], position, 0)) {
            return features[tmp];
          }

          if (delta(features[tmp], position) < delta(candidateFeature, position)) {
            candidateFeature = features[tmp];
          }

          tmp = index;

          while (tmp++ < features.length) {
            if (!test(features[tmp]), tolerance) {
              break;
            }

            if (test(features[tmp], position, 0)) {
              return features[tmp];
            }

            if (delta(features[tmp], position) < delta(candidateFeature, position)) {
              candidateFeature = features[tmp];
            }
          }
        }

        return candidateFeature;
      } else {
        console.log(position + ' not found!');
        return undefined;
      }

      function test(feature, position, tolerance) {
        return position >= feature.start - tolerance && position <= feature.end + tolerance;
      }

      function delta(feature, position) {
        return Math.min(Math.abs(feature.start - position), Math.abs(feature.end - position));
      }
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2016 University of California San Diego
     * Author: Jim Robinson
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    const isString = isString$2;
    const DEFAULT_VISIBILITY_WINDOW = 1000000;
    const topMargin = 10;

    class VariantTrack extends TrackBase {
      constructor(config, browser) {
        super(config, browser);
        this.visibilityWindow = config.visibilityWindow;
        this.displayMode = config.displayMode || "EXPANDED"; // COLLAPSED | EXPANDED | SQUISHED

        this.labelDisplayMode = config.labelDisplayMode;
        this.variantHeight = config.variantHeight || 10;
        this.squishedCallHeight = config.squishedCallHeight || 1;
        this.expandedCallHeight = config.expandedCallHeight || 10;
        this.expandedVGap = config.expandedVGap !== undefined ? config.expandedVGap : 2;
        this.squishedVGap = config.squishedVGap !== undefined ? config.squishedVGap : 1;
        this.expandedGroupGap = config.expandedGroupGap || 10;
        this.squishedGroupGap = config.squishedGroupGap || 5;
        this.featureHeight = config.featureHeight || 14;
        this.visibilityWindow = config.visibilityWindow;
        this.featureSource = FeatureSource(config, browser.genome);
        this.noCallColor = config.noCallColor || "rgb(245, 245, 245)";
        this.nonRefColor = config.nonRefColor || "rgb(200, 200, 215)";
        this.mixedColor = config.mixedColor || "rgb(200, 220, 200)";
        this.homrefColor = config.homrefColor || "rgb(200, 200, 200)";
        this.homvarColor = config.homvarColor || "rgb(17,248,254)";
        this.hetvarColor = config.hetvarColor || "rgb(34,12,253)";
        this.sortDirection = "ASC";
        this.type = config.type || "variant";
        this.nRows = 1; // Computed dynamically
      }

      async postInit() {
        await this.getHeader(); // cricital, don't remove'

        if (undefined === this.visibilityWindow && this.config.indexed !== false) {
          const fn = this.config.url instanceof File ? this.config.url.name : this.config.url;

          if (isString(fn) && fn.toLowerCase().includes("gnomad")) {
            this.visibilityWindow = 1000; // these are known to be very dense
          } else if (this.callSets) {
            const length = this.callSets.length;
            this.visibilityWindow = Math.max(1000, DEFAULT_VISIBILITY_WINDOW - length * (DEFAULT_VISIBILITY_WINDOW / 100));
          } else {
            this.visibilityWindow = DEFAULT_VISIBILITY_WINDOW;
          }
        }

        return this;
      }

      supportsWholeGenome() {
        return this.config.indexed === false && this.config.supportsWholeGenome !== false;
      }

      async getHeader() {
        if (this.header) {
          return this.header;
        } else if (typeof this.featureSource.getHeader === "function") {
          const header = await this.featureSource.getHeader();

          if (header) {
            this.callSets = header.callSets || [];
          }

          this.header = header;
          return header;
        } else {
          this.callSets = [];
          return undefined;
        }
      }

      getCallsetsLength() {
        return this.callSets.length;
      }

      async getFeatures(chr, start, end, bpPerPixel) {
        if (this.header === undefined) {
          this.header = await this.getHeader();
        }

        return this.featureSource.getFeatures({
          chr,
          start,
          end,
          bpPerPixel,
          visibilityWindow: this.visibilityWindow
        });
      }
      /**
       * The required height in pixels required for the track content.   This is not the visible track height, which
       * can be smaller (with a scrollbar) or larger.
       *
       * @param features
       * @returns {*}
       */


      computePixelHeight(features) {
        if (this.displayMode === "COLLAPSED") {
          this.nRows = 1;
          return topMargin + this.variantHeight;
        } else {
          var maxRow = 0;

          if (features) {
            for (let feature of features) {
              if (feature.row && feature.row > maxRow) maxRow = feature.row;
            }
          }

          const vGap = this.displayMode === 'EXPANDED' ? this.expandedVGap : this.squishedVGap;
          this.nRows = maxRow + 1;
          const h = topMargin + this.nRows * (this.variantHeight + vGap);
          this.variantBandHeight = h;
          const callHeight = this.displayMode === "EXPANDED" ? this.expandedCallHeight : this.squishedCallHeight;
          const nCalls = this.getCallsetsLength() * this.nRows;
          return h + vGap + (nCalls + 1) * (callHeight + vGap);
        }
      }

      draw(options) {
        const ctx = options.context;
        const callSets = this.callSets;
        const nCalls = this.getCallsetsLength();
        const pixelWidth = options.pixelWidth;
        const pixelHeight = options.pixelHeight;
        const callHeight = "EXPANDED" === this.displayMode ? this.expandedCallHeight : this.squishedCallHeight;
        const bpPerPixel = options.bpPerPixel;
        const bpStart = options.bpStart;
        const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
        IGVGraphics.fillRect(ctx, 0, options.pixelTop, pixelWidth, pixelHeight, {
          'fillStyle': "rgb(255, 255, 255)"
        });
        const vGap = this.displayMode === 'EXPANDED' ? this.expandedVGap : this.squishedVGap;

        if (callSets && nCalls > 0 && "COLLAPSED" !== this.displayMode) {
          IGVGraphics.strokeLine(ctx, 0, this.variantBandHeight, pixelWidth, this.variantBandHeight, {
            strokeStyle: 'rgb(224,224,224) '
          });
        }

        const featureList = options.features;

        if (featureList) {
          for (let variant of featureList) {
            if (variant.end < bpStart) continue;
            if (variant.start > bpEnd) break;
            const py = topMargin + ("COLLAPSED" === this.displayMode ? 0 : variant.row * (this.variantHeight + vGap));
            const vh = this.variantHeight; // Compute pixel width.   Minimum width is 3 pixels,  if > 5 pixels create gap between variants

            let px = Math.round((variant.start - bpStart) / bpPerPixel);
            let px1 = Math.round((variant.end - bpStart) / bpPerPixel);
            let pw = Math.max(1, px1 - px);

            if (pw < 3) {
              pw = 3;
              px -= 1;
            } else if (pw > 5) {
              px += 1;
              pw -= 2;
            }

            if ("NONVARIANT" === variant.type) {
              ctx.fillStyle = this.nonRefColor;
            } else if ("MIXED" === variant.type) {
              ctx.fillStyle = this.mixedColor;
            } else {
              ctx.fillStyle = this.color || this.defaultColor;
            }

            ctx.fillRect(px, py, pw, vh);

            if (nCalls > 0 && variant.calls && "COLLAPSED" !== this.displayMode) {
              let callsDrawn = 0;

              for (let callSet of callSets) {
                const call = variant.calls[callSet.id];

                if (call) {
                  const py = this.variantBandHeight + vGap + (callsDrawn + variant.row) * (callHeight + vGap);
                  let allVar = true; // until proven otherwise

                  let allRef = true;
                  let noCall = false;

                  for (let g of call.genotype) {
                    if ('.' === g) {
                      noCall = true;
                      break;
                    } else {
                      if (g !== 0) allRef = false;
                      if (g === 0) allVar = false;
                    }
                  }

                  if (noCall) {
                    ctx.fillStyle = this.noCallColor;
                  } else if (allRef) {
                    ctx.fillStyle = this.homrefColor;
                  } else if (allVar) {
                    ctx.fillStyle = this.homvarColor;
                  } else {
                    ctx.fillStyle = this.hetvarColor;
                  }

                  ctx.fillRect(px, py, pw, callHeight);
                }

                callsDrawn++;
              }
            }
          }
        } else {
          console.log("No feature list");
        }
      }

      /**
       * Return "popup data" for feature @ genomic location.  Data is an array of key-value pairs
       */
      popupData(clickState, featureList) {
        if (!featureList) featureList = this.clickedFeatures(clickState);
        const genomicLocation = clickState.genomicLocation;
        const genomeID = this.browser.genome.id;
        const popupData = [];
        const sampleInformation = this.browser.sampleInformation;

        for (let variant of featureList) {
          if (popupData.length > 0) {
            popupData.push('<HR>');
          }

          if ("COLLAPSED" === this.displayMode) {
            Array.prototype.push.apply(popupData, variant.popupData(genomicLocation, this.type));
          } else {
            const yOffset = clickState.y;
            const vGap = this.displayMode === 'EXPANDED' ? this.expandedVGap : this.squishedVGap;

            if (yOffset <= this.variantBandHeight) {
              // Variant
              const row = Math.floor((yOffset - topMargin) / (this.variantHeight + vGap));

              if (variant.row === row) {
                Array.prototype.push.apply(popupData, variant.popupData(genomicLocation, genomeID), this.type);
              }
            } else {
              // Genotype
              const callSets = this.callSets;

              if (callSets && variant.calls) {
                const callHeight = this.nRows * ("SQUISHED" === this.displayMode ? this.squishedCallHeight : this.expandedCallHeight);
                const row = Math.floor((yOffset - this.variantBandHeight) / (callHeight + vGap));

                if (row >= 0 && row < callSets.length) {
                  const cs = callSets[row];
                  const call = variant.calls[cs.id];
                  Array.prototype.push.apply(popupData, extractGenotypePopupData(call, variant, genomeID, sampleInformation));
                }
              }
            }
          }
        }

        return popupData;
        /**
         * Genotype popup text.
         * @param call
         * @param variant
         * @returns {Array}
         */

        function extractGenotypePopupData(call, variant, genomeId, sampleInformation) {
          let gt = '';
          const altArray = variant.alternateBases.split(",");

          for (let allele of call.genotype) {
            if ('.' === allele) {
              gt += 'No Call';
              break;
            } else if (allele === 0) {
              gt += variant.referenceBases;
            } else {
              let alt = altArray[allele - 1].replace("<", "&lt;");
              gt += alt;
            }
          }

          let popupData = [];

          if (call.callSetName !== undefined) {
            popupData.push({
              name: 'Name',
              value: call.callSetName
            });
          }

          popupData.push({
            name: 'Genotype',
            value: gt
          });

          if (call.phaseset !== undefined) {
            popupData.push({
              name: 'Phase set',
              value: call.phaseset
            });
          }

          if (call.genotypeLikelihood !== undefined) {
            popupData.push({
              name: 'genotypeLikelihood',
              value: call.genotypeLikelihood.toString()
            });
          }

          if (sampleInformation) {
            var attr = sampleInformation.getAttributes(call.callSetName);

            if (attr) {
              Object.keys(attr).forEach(function (attrName) {
                var displayText = attrName.replace(/([A-Z])/g, " $1");
                displayText = displayText.charAt(0).toUpperCase() + displayText.slice(1);
                popupData.push({
                  name: displayText,
                  value: attr[attrName]
                });
              });
            }
          }

          var infoKeys = Object.keys(call.info);

          if (infoKeys.length) {
            popupData.push("<hr>");
          }

          infoKeys.forEach(function (key) {
            popupData.push({
              name: key,
              value: call.info[key]
            });
          });
          let cravatLinks = []; // TODO -- where do these get calculated?

          if (cravatLinks.length > 0) {
            popupData.push("<HR/>");
            popupData = popupData.concat(cravatLinks);
          }

          return popupData;
        }
      } // VariantTrack.prototype.contextMenuItemList = function (clickState) {
      //
      //     const self = this;
      //     const menuItems = [];
      //
      //     const featureList = this.clickedFeatures(clickState);
      //
      //     if (this.callSets && featureList && featureList.length > 0) {
      //
      //         featureList.forEach(function (variant) {
      //
      //             if ('str' === variant.type) {
      //
      //                 menuItems.push({
      //                     label: 'Sort by allele length',
      //                     click: function () {
      //                         sortCallSetsByAlleleLength(self.callSets, variant, self.sortDirection);
      //                         self.sortDirection = (self.sortDirection === "ASC") ? "DESC" : "ASC";
      //                         self.trackView.repaintViews();
      //                     }
      //                 });
      //
      //             }
      //
      //         });
      //     }
      //
      //
      //     function sortCallSetsByAlleleLength(callSets, variant, direction) {
      //         var d = (direction === "DESC") ? 1 : -1;
      //         Object.keys(callSets).forEach(function (property) {
      //             callSets[property].sort(function (a, b) {
      //                 var aNan = isNaN(variant.calls[a.id].genotype[0]);
      //                 var bNan = isNaN(variant.calls[b.id].genotype[0]);
      //                 if (aNan && bNan) {
      //                     return 0;
      //                 } else if (aNan) {
      //                     return 1;
      //                 } else if (bNan) {
      //                     return -1;
      //                 } else {
      //                     var a0 = getAlleleString(variant.calls[a.id], variant, 0);
      //                     var a1 = getAlleleString(variant.calls[a.id], variant, 1);
      //                     var b0 = getAlleleString(variant.calls[b.id], variant, 0);
      //                     var b1 = getAlleleString(variant.calls[b.id], variant, 1);
      //                     var result = Math.max(b0.length, b1.length) - Math.max(a0.length, a1.length);
      //                     if (result === 0) {
      //                         result = Math.min(b0.length, b1.length) - Math.min(a0.length, a1.length);
      //                     }
      //                     return d * result;
      //                 }
      //             });
      //         });
      //     }
      //
      //
      //     return menuItems;
      //
      // };


      menuItemList() {
        var self = this,
            menuItems = [];
        menuItems.push({
          object: $('<div class="igv-track-menu-border-top">')
        });
        ["COLLAPSED", "SQUISHED", "EXPANDED"].forEach(function (displayMode) {
          var lut = {
            "COLLAPSED": "Collapse",
            "SQUISHED": "Squish",
            "EXPANDED": "Expand"
          };
          menuItems.push({
            object: createCheckbox(lut[displayMode], displayMode === self.displayMode),
            click: function () {
              self.displayMode = displayMode;
              self.trackView.checkContentHeight();
              self.trackView.repaint();
            }
          });
        });
        return menuItems;
      }

    }

    const tracks = {
      'feature': (config, browser) => {
        return new FeatureTrack(config, browser);
      },
      'wig': (config, browser) => {
        return new WigTrack(config, browser);
      },
      'variant': (config, browser) => {
        return new VariantTrack(config, browser);
      }
    };

    const addTrack = function (name, track) {
      this.tracks[name] = track;
    };

    const getTrack = function (name) {
      return this.tracks[name];
    };

    var TrackFactory = {
      tracks,
      addTrack,
      getTrack
    };

    /*
     * @author Jim Robinson Dec-2020
     */
    const igv = {
      async createTrack(config, browser) {
        // Resolve function and promise urls
        let url = await resolveURL(config.url);

        if (isString$2(url)) {
          url = url.trim();
        }

        if (url) {
          if (config.format) {
            config.format = config.format.toLowerCase();
          } else {
            let filename = config.filename;

            if (!filename) {
              filename = await getFilename(url);
            }

            config.format = inferFileFormat(filename);
          }
        }

        let type = config.type;

        if (type && "bedtype" !== type) {
          type = type.toLowerCase();
        } else {
          type = inferTrackType(config);

          if ("bedtype" === type) {
            // Bed files must be read to determine track type
            const featureSource = FeatureSource(config, browser.genome);
            config._featureSource = featureSource; // This is a temp variable, bit of a hack

            const trackType = await featureSource.trackType();

            if (trackType) {
              type = trackType;
            } else {
              type = "annotation";
            } // Record in config to make type persistent in session


            config.type = type;
          }
        }

        let track;

        switch (type) {
          case "annotation":
          case "genes":
          case "fusionjuncspan":
          case "junctions":
          case "splicejunctions":
          case "snp":
            track = TrackFactory.getTrack("feature")(config, browser);
            break;

          default:
            if (TrackFactory.tracks.hasOwnProperty(type)) {
              track = TrackFactory.getTrack(type)(config, browser);
            } else {
              track = undefined;
            }

        }

        if (config.roi && track) {
          track.roi = [];

          for (let r of config.roi) {
            track.roi.push(new ROI(r, browser.genome));
          }
        }

        return track;
      }

    };

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    function isMobile() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    function throttle(fn, threshhold, scope) {
      var last, deferTimer;
      threshhold || (threshhold = 200);
      return function () {
        var context, now, args;
        context = scope || this;
        now = +new Date();
        args = arguments;

        if (last && now < last + threshhold) {
          // hold on to it
          clearTimeout(deferTimer);
          deferTimer = setTimeout(function () {
            last = now;
            fn.apply(context, args);
          }, threshhold);
        } else {
          last = now;
          fn.apply(context, args);
        }
      };
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    const Globals = {};
    const Track2DDisplaceModes = {
      displayAllMatrix: 'displayAllMatrix',
      displayLowerMatrix: 'displayLowerMatrix',
      displayUpperMatrix: 'displayUpperMatrix'
    };

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    /**
     * @author Jim Robinson
     */

    /**
     * Barebones event bus.
     */
    class EventBus {
      constructor() {
        // Map eventType -> list of subscribers
        this.subscribers = {};
        this.stack = [];
      }

      subscribe(eventType, object) {
        var subscriberList = this.subscribers[eventType];

        if (subscriberList == undefined) {
          subscriberList = [];
          this.subscribers[eventType] = subscriberList;
        }

        subscriberList.push(object);
      }

      post(event) {
        const eventType = event.type;

        if (this._hold) {
          this.stack.push(event);
        } else {
          const subscriberList = this.subscribers[eventType];

          if (subscriberList) {
            for (let subscriber of subscriberList) {
              if ("function" === typeof subscriber.receiveEvent) {
                subscriber.receiveEvent(event);
              } else if ("function" === typeof subscriber) {
                subscriber(event);
              }
            }
          }
        }
      }

      hold() {
        this._hold = true;
      }

      release() {
        this._hold = false;

        for (let event of this.stack) {
          this.post(event);
        }

        this.stack = [];
      }

    } // The global event bus


    EventBus.globalBus = new EventBus();

    class Track2D {
      constructor(config, features) {
        this.config = config;
        this.name = config.name;
        this.featureMap = {};
        this.featureCount = 0;
        this.isVisible = true;
        this.displayMode = Track2DDisplaceModes.displayAllMatrix;

        if (config.color && validateColor(config.color)) {
          this.color = this.color = config.color; // If specified, this will override colors of individual records.
        }

        this.repColor = features.length > 0 ? features[0].color : "black";

        for (let f of features) {
          this.featureCount++;
          const key = getKey(f.chr1, f.chr2);
          let list = this.featureMap[key];

          if (!list) {
            list = [];
            this.featureMap[key] = list;
          }

          list.push(f);
        }
      }

      static async loadTrack2D(config, genome) {
        // if (isString(config.url) && config.url.startsWith("https://drive.google.com")) {
        //     const json = await google.getDriveFileInfo(config.url)
        //     config.url = "https://www.googleapis.com/drive/v3/files/" + json.id + "?alt=media";
        //     if (!config.filename) {
        //         config.filename = json.originalFileName || json.name;
        //     }
        //     if (!config.name) {
        //         config.name = json.name || json.originalFileName;
        //     }
        // }
        const data = await igvxhr.loadString(config.url, buildOptions(config));
        const features = parseData(data, isBedPE(config), genome);
        return new Track2D(config, features);
      }

      getColor() {
        return this.color || this.repColor;
      }

      getFeatures(chr1, chr2) {
        const key = getKey(chr1, chr2);
        return this.featureMap[key];
      }

    }

    function isBedPE(config) {
      if (typeof config.url === "string") {
        return config.url.toLowerCase().indexOf(".bedpe") > 0;
      } else if (typeof config.name === "string") {
        return config.name.toLowerCase().indexOf(".bedpe") > 0;
      } else {
        return true; // Default
      }
    }

    function parseData(data, isBedPE, genome) {
      if (!data) return null;
      const lines = splitLines(data);
      const allFeatures = [];
      const delimiter = "\t";
      const colorColumn = isBedPE ? 10 : 6;
      let errorCount = 0;

      for (let line of lines) {
        line = line.trim();

        if (line.startsWith("#") || line.startsWith("track") || line.startsWith("browser") || line.length === 0) {
          continue;
        }

        const tokens = line.split(delimiter);

        if (tokens.length < 6 && errorCount <= 5) {
          if (errorCount === 5) {
            console.error("...");
          } else {
            console.error("Could not parse line: " + line);
          }

          errorCount++;
          continue;
        }

        const feature = {
          chr1: genome ? genome.getChromosomeName(tokens[0]) : tokens[0],
          x1: parseInt(tokens[1]),
          x2: parseInt(tokens[2]),
          chr2: genome ? genome.getChromosomeName(tokens[3]) : tokens[3],
          y1: parseInt(tokens[4]),
          y2: parseInt(tokens[5])
        };

        if (tokens.length > colorColumn) {
          feature.color = "rgb(" + tokens[colorColumn] + ")";
        }

        if (!Number.isNaN(feature.x1)) {
          allFeatures.push(feature);
        }
      }

      return allFeatures;
    }

    function getKey(chr1, chr2) {
      return chr1 > chr2 ? chr2 + "_" + chr1 : chr1 + "_" + chr2;
    }

    function validateColor(str) {
      var div = document.createElement("div");
      div.style.borderColor = str;
      return div.style.borderColor !== "";
    }

    function buildOptions(config, options) {
      const defaultOptions = {
        oauthToken: config.oauthToken,
        headers: config.headers,
        withCredentials: config.withCredentials,
        filename: config.filename
      };
      return Object.assign(defaultOptions, options);
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    class Ruler {
      constructor(browser, $parent, axis) {
        this.browser = browser;
        this.axis = axis;
        this.$axis = $parent.find(`div[id$='-axis']`);
        this.$canvas = $parent.find("canvas");
        this.ctx = this.$canvas.get(0).getContext("2d");
        this.ctx.canvas.width = this.$axis.width();
        this.ctx.canvas.height = this.$axis.height();
        this.$wholeGenomeContainer = $parent.find("div[id$='-axis-whole-genome-container']");

        this.yAxisTransformWithContext = ctx => {
          ctx.scale(-1, 1);
          ctx.rotate(Math.PI / 2.0);
        };

        this.setAxisTransform(axis);
        browser.eventBus.subscribe('MapLoad', this);
        browser.eventBus.subscribe("UpdateContactMapMousePosition", this);
      }

      wholeGenomeLayout($axis, $wholeGenomeContainer, axisName, dataset) {
        var self = this,
            list,
            dimen,
            extent,
            scraps,
            $div,
            $firstDiv; // discard current tiles

        $wholeGenomeContainer.empty();
        list = dataset.chromosomes.filter(function (chromosome) {
          return 'all' !== chromosome.name.toLowerCase();
        });
        extent = 0; // could use reduce for this

        list.forEach(function (chromosome) {
          extent += chromosome.size;
        });
        dimen = 'x' === axisName ? $axis.width() : $axis.height();
        scraps = 0;
        this.bboxes = [];
        $firstDiv = undefined;
        list.forEach(function (chr) {
          var size, percentage;
          percentage = chr.bpLength / extent;

          if (percentage * dimen < 1.0) {
            scraps += percentage;
          } else {
            $div = $("<div>", {
              class: `${self.axis}-axis-whole-genome-chromosome-container`
            });
            $wholeGenomeContainer.append($div);
            $div.data('label', chr.name); // debug
            // $div.get(0).style.backgroundColor = randomRGB(150, 250);

            if (!$firstDiv) {
              $firstDiv = $div;
            }

            if ('x' === axisName) {
              size = Math.round(percentage * dimen);
              $div.width(size);
            } else {
              size = Math.round(percentage * dimen);
              $div.height(size);
            } // border


            const $border = $('<div>');
            $div.append($border); // label

            const $label = $('<div>');
            $border.append($label);
            $label.text($div.data('label'));
            $label.get(0).title = $div.data('label');
            decorate.call(self, $div);
          }
        });
        scraps *= dimen;
        scraps = Math.floor(scraps);

        if (scraps >= 1) {
          const className = self.axis + '-axis-whole-genome-chromosome-container';
          $div = $("<div>", {
            class: className
          });
          $wholeGenomeContainer.append($div);
          $div.data('label', '-');
          $div.width(scraps); // className = self.axis + '-axis-whole-genome-chromosome';
          // $e = $("<div>", {class: className});
          // $div.append($e);
          // $e.text($div.data('label'));

          decorate.call(self, $div);
        }

        $wholeGenomeContainer.children().each(function (index) {
          self.bboxes.push(bbox(axisName, $(this), $firstDiv));
        }); // initially hide

        this.hideWholeGenome();

        function decorate($d) {
          var self = this;
          $d.on('click', function (e) {
            var $o;
            $o = $(this).first();
            self.browser.parseGotoInput($o.text());
            self.unhighlightWholeChromosome();
            self.otherRuler.unhighlightWholeChromosome();
          });
          $d.hover(function () {
            hoverHandler.call(self, $(this), true);
          }, function () {
            hoverHandler.call(self, $(this), false);
          });
        }

        function hoverHandler($e, doHover) {
          var target, $target;
          target = $e.data('label');
          this.otherRuler.$wholeGenomeContainer.children().each(function (index) {
            if (target === $(this).data('label')) {
              $target = $(this);
            }
          });

          if (true === doHover) {
            $e.addClass('hic-whole-genome-chromosome-highlight');
            $target.addClass('hic-whole-genome-chromosome-highlight');
          } else {
            $e.removeClass('hic-whole-genome-chromosome-highlight');
            $target.removeClass('hic-whole-genome-chromosome-highlight');
          }
        }
      }

      hideWholeGenome() {
        this.$wholeGenomeContainer.hide();
        this.$canvas.show();
      }

      showWholeGenome() {
        this.$canvas.hide();
        this.$wholeGenomeContainer.show();
      }

      setAxisTransform(axis) {
        this.canvasTransform = 'y' === axis ? this.yAxisTransformWithContext : identityTransformWithContext;
        this.labelReflectionTransform = 'y' === axis ? reflectionTransformWithContext : function (context, exe) {};
      }

      unhighlightWholeChromosome() {
        this.$wholeGenomeContainer.children().removeClass('hic-whole-genome-chromosome-highlight');
      }

      receiveEvent(event) {
        var offset, $e;

        if ('MapLoad' === event.type) {
          this.wholeGenomeLayout(this.$axis, this.$wholeGenomeContainer, this.axis, event.data);
          this.update();
        } else if ('UpdateContactMapMousePosition' === event.type) {
          if (this.bboxes) {
            this.unhighlightWholeChromosome();
            offset = 'x' === this.axis ? event.data.x : event.data.y;
            $e = hitTest(this.bboxes, offset);

            if ($e) {
              // console.log(this.axis + ' highlight chr ' + $e.text());
              $e.addClass('hic-whole-genome-chromosome-highlight');
            }
          }
        }
      }

      locusChange(event) {
        this.update();
      }

      updateWidthWithCalculation(calc) {
        this.$axis.css('width', calc);
        this.$canvas.width(this.$axis.width());
        this.$canvas.attr('width', this.$axis.width());
        this.wholeGenomeLayout(this.$axis, this.$wholeGenomeContainer, this.axis, this.browser.dataset);
        this.update();
      }

      updateHeight(height) {
        this.$canvas.height(height);
        this.$canvas.attr('height', height);
        this.wholeGenomeLayout(this.$axis, this.$wholeGenomeContainer, this.axis, this.browser.dataset);
        this.update();
      }

      update() {
        var w,
            h,
            bin,
            config = {},
            browser = this.browser;

        if (browser.dataset.isWholeGenome(browser.state.chr1)) {
          this.showWholeGenome();
          return;
        }

        this.hideWholeGenome();
        identityTransformWithContext(this.ctx);
        IGVGraphics.fillRect(this.ctx, 0, 0, this.$canvas.width(), this.$canvas.height(), {
          fillStyle: IGVColor.rgbColor(255, 255, 255)
        });
        this.canvasTransform(this.ctx);
        w = 'x' === this.axis ? this.$canvas.width() : this.$canvas.height();
        h = 'x' === this.axis ? this.$canvas.height() : this.$canvas.width();
        IGVGraphics.fillRect(this.ctx, 0, 0, w, h, {
          fillStyle: IGVColor.rgbColor(255, 255, 255)
        });
        config.bpPerPixel = browser.dataset.bpResolutions[browser.state.zoom] / browser.state.pixelSize;
        bin = 'x' === this.axis ? browser.state.x : browser.state.y;
        config.bpStart = bin * browser.dataset.bpResolutions[browser.state.zoom];
        config.rulerTickMarkReferencePixels = Math.max(Math.max(this.$canvas.width(), this.$canvas.height()), Math.max(this.$otherRulerCanvas.width(), this.$otherRulerCanvas.height()));
        config.rulerLengthPixels = w;
        config.rulerHeightPixels = h;
        config.height = Math.min(this.$canvas.width(), this.$canvas.height());
        this.draw(config);
      }

      draw(options) {
        var fontStyle,
            tickSpec,
            majorTickSpacing,
            nTick,
            pixelLast,
            pixel,
            tickSpacingPixels,
            labelWidthPixels,
            modulo,
            l,
            yShim,
            tickHeight,
            rulerLabel,
            chrSize,
            chromosomes = this.browser.dataset.chromosomes;
        'x' === this.axis ? chromosomes[this.browser.state.chr1].name : chromosomes[this.browser.state.chr2].name;
        chrSize = 'x' === this.axis ? chromosomes[this.browser.state.chr1].size : chromosomes[this.browser.state.chr2].size;

        if (options.chrName === "all") ; else {
          IGVGraphics.fillRect(this.ctx, 0, 0, options.rulerLengthPixels, options.rulerHeightPixels, {
            fillStyle: IGVColor.rgbColor(255, 255, 255)
          });
          fontStyle = {
            textAlign: 'center',
            font: '9px PT Sans',
            fillStyle: "rgba(64, 64, 64, 1)",
            strokeStyle: "rgba(64, 64, 64, 1)"
          };
          tickSpec = findSpacing(Math.floor(options.rulerTickMarkReferencePixels * options.bpPerPixel));
          majorTickSpacing = tickSpec.majorTick; // Find starting point closest to the current origin

          nTick = Math.floor(options.bpStart / majorTickSpacing) - 1;
          pixel = pixelLast = 0;
          IGVGraphics.setProperties(this.ctx, fontStyle);
          this.ctx.lineWidth = 1.0;
          yShim = 1;
          tickHeight = 8;

          while (pixel < options.rulerLengthPixels) {
            l = Math.floor(nTick * majorTickSpacing);
            pixel = Math.round((l - 1 - options.bpStart + 0.5) / options.bpPerPixel);
            rulerLabel = formatNumber(l / tickSpec.unitMultiplier, 0) + " " + tickSpec.majorUnit;
            tickSpacingPixels = Math.abs(pixel - pixelLast);
            labelWidthPixels = this.ctx.measureText(rulerLabel).width;

            if (labelWidthPixels > tickSpacingPixels) {
              if (tickSpacingPixels < 32) {
                modulo = 4;
              } else {
                modulo = 2;
              }
            } else {
              modulo = 1;
            } // modulo = 1;


            if (0 === nTick % modulo) {
              if (Math.floor(pixel * options.bpPerPixel + options.bpStart) < chrSize) {
                // console.log('   label delta(' + Math.abs(pixel - pixelLast) + ') modulo(' + modulo + ') bpp(' + options.bpPerPixel + ')');
                this.ctx.save();
                this.labelReflectionTransform(this.ctx, pixel);
                IGVGraphics.fillText(this.ctx, rulerLabel, pixel, options.height - tickHeight / 0.75);
                this.ctx.restore();
              }
            }

            if (Math.floor(pixel * options.bpPerPixel + options.bpStart) < chrSize) {
              IGVGraphics.strokeLine(this.ctx, pixel, options.height - tickHeight, pixel, options.height - yShim);
            }

            pixelLast = pixel;
            nTick++;
          } // while (pixel < options.rulerLengthPixels)


          IGVGraphics.strokeLine(this.ctx, 0, options.height - yShim, options.rulerLengthPixels, options.height - yShim);
        }

        function formatNumber(anynum, decimal) {
          //decimal  - the number of decimals after the digit from 0 to 3
          //-- Returns the passed number as a string in the xxx,xxx.xx format.
          //anynum = eval(obj.value);
          var divider = 10;

          switch (decimal) {
            case 0:
              divider = 1;
              break;

            case 1:
              divider = 10;
              break;

            case 2:
              divider = 100;
              break;

            default:
              //for 3 decimal places
              divider = 1000;
          }

          var workNum = Math.abs(Math.round(anynum * divider) / divider);
          var workStr = "" + workNum;

          if (-1 === workStr.indexOf(".")) {
            workStr += ".";
          }

          var dStr = workStr.substr(0, workStr.indexOf("."));
          var dNum = dStr - 0;
          var pStr = workStr.substr(workStr.indexOf("."));

          while (pStr.length - 1 < decimal) {
            pStr += "0";
          }

          if ('.' === pStr) {
            pStr = '';
          } //--- Adds a comma in the thousands place.


          if (dNum >= 1000) {
            var dLen = dStr.length;
            dStr = parseInt("" + dNum / 1000) + "," + dStr.substring(dLen - 3, dLen);
          } //-- Adds a comma in the millions place.


          if (dNum >= 1000000) {
            dLen = dStr.length;
            dStr = parseInt("" + dNum / 1000000) + "," + dStr.substring(dLen - 7, dLen);
          }

          var retval = dStr + pStr; //-- Put numbers in parentheses if negative.

          if (anynum < 0) {
            retval = "(" + retval + ")";
          } //You could include a dollar sign in the return value.
          //retval =  "$"+retval


          return retval;
        }
      }

    }

    function bbox(axis, $child, $firstChild) {
      var delta, size, o, fo;
      o = 'x' === axis ? $child.offset().left : $child.offset().top;
      fo = 'x' === axis ? $firstChild.offset().left : $firstChild.offset().top;
      delta = o - fo;
      size = 'x' === axis ? $child.width() : $child.height();
      return {
        $e: $child,
        a: delta,
        b: delta + size
      };
    }

    function hitTest(bboxes, value) {
      var $result, success;
      success = false;
      $result = undefined;
      bboxes.forEach(function (bbox) {
        if (false === success) {
          if (value < bbox.a) ; else if (value > bbox.b) ; else {
            $result = bbox.$e;
            success = true;
          }
        }
      });
      return $result;
    }

    function TickSpacing(majorTick, majorUnit, unitMultiplier) {
      this.majorTick = majorTick;
      this.majorUnit = majorUnit;
      this.unitMultiplier = unitMultiplier;
    }

    function findSpacing(rulerLengthBP) {
      if (rulerLengthBP < 10) {
        return new TickSpacing(1, "", 1);
      } // How many zeroes?


      var nZeroes = Math.floor(log10(rulerLengthBP));
      var majorUnit = "";
      var unitMultiplier = 1;

      if (nZeroes > 9) {
        majorUnit = "gb";
        unitMultiplier = 1000000000;
      }

      if (nZeroes > 6) {
        majorUnit = "mb";
        unitMultiplier = 1000000;
      } else if (nZeroes > 3) {
        majorUnit = "kb";
        unitMultiplier = 1000;
      }

      var nMajorTicks = rulerLengthBP / Math.pow(10, nZeroes - 1);

      if (nMajorTicks < 25) {
        return new TickSpacing(Math.pow(10, nZeroes - 1), majorUnit, unitMultiplier);
      } else {
        return new TickSpacing(Math.pow(10, nZeroes) / 2, majorUnit, unitMultiplier);
      }

      function log10(x) {
        var dn = Math.log(10);
        return Math.log(x) / dn;
      }
    }

    function reflectionTransformWithContext(context, exe) {
      context.translate(exe, 0);
      context.scale(-1, 1);
      context.translate(-exe, 0);
    }

    function identityTransformWithContext(context) {
      // 3x2 matrix. column major. (sx 0 0 sy tx ty).
      context.setTransform(1, 0, 0, 1, 0, 0);
    }

    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2014 Broad Institute
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    const trackMenuItemListHelper = (itemList, $popover) => {
      var list = [];

      if (itemList.length > 0) {
        list = itemList.map(function (item, i) {
          let $e; // name and object fields checked for backward compatibility

          if (item.name) {
            $e = $('<div>');
            $e.text(item.name);
          } else if (item.object) {
            $e = $(item.object); // This creates a JQuery object form a dom element, or clones if already a jQuery object
          } else if (typeof item.label === 'string') {
            $e = $('<div>');
            $e.html(item.label);
          } else if (typeof item === 'string') {
            if (item.startsWith("<")) {
              $e = $(item);
            } else {
              $e = $("<div>" + item + "</div>");
            }
          }

          if (0 === i) {
            $e.addClass('igv-track-menu-border-top');
          }

          if (item.click) {
            $e.on('click', handleClick);
            $e.on('touchend', function (e) {
              handleClick(e);
            });
            $e.on('mouseup', function (e) {
              e.preventDefault();
              e.stopPropagation();
            }); // eslint-disable-next-line no-inner-declarations

            function handleClick(e) {
              item.click(e);
              $popover.hide();
              e.preventDefault();
              e.stopPropagation();
            }
          }

          return {
            object: $e,
            init: item.init || undefined
          };
        });
      }

      return list;
    };

    const MenuPopup = function ($parent) {
      // popover container
      this.$popover = $('<div>', {
        class: 'igv-menu-popup'
      });
      $parent.append(this.$popover); // popover header

      let $popoverHeader = $('<div>', {
        class: 'igv-menu-popup-header'
      });
      this.$popover.append($popoverHeader);
      attachDialogCloseHandlerWithParent$1($popoverHeader.get(0), () => this.$popover.hide());
      this.$popoverContent = $('<div>');
      this.$popover.append(this.$popoverContent);
      makeDraggable$1(this.$popover.get(0), $popoverHeader.get(0));
      $popoverHeader.on('click.menu-popup-dismiss', function (e) {
        e.stopPropagation();
        e.preventDefault(); // absorb click to prevent it leaking through to parent DOM element
      });
    };

    MenuPopup.prototype.presentMenuList = function (dx, dy, list) {
      hideAllMenuPopups();

      if (list.length > 0) {
        this.$popoverContent.empty();
        list = trackMenuItemListHelper(list, this.$popover);

        for (let item of list) {
          if (item.init) {
            item.init();
          }

          let $e = item.object;

          if (0 === list.indexOf(item)) {
            $e.removeClass('igv-track-menu-border-top');
          }

          if ($e.hasClass('igv-track-menu-border-top') || $e.hasClass('igv-menu-popup-check-container')) ; else if ($e.is('div')) {
            $e.addClass('igv-menu-popup-shim');
          }

          this.$popoverContent.append($e);
        }

        this.$popover.css({
          left: dx + 'px',
          top: dy + 'px'
        });
        this.$popover.show();
      }
    };

    MenuPopup.prototype.presentTrackContextMenu = function (e, menuItems) {
      this.$popoverContent.empty();
      const menuElements = createMenuElements(menuItems, this.$popover.get(0));

      for (let item of menuElements) {
        this.$popoverContent.get(0).appendChild(item.object);
      }

      present(e, this.$popover.get(0));
      this.$popover.show();
    };

    MenuPopup.prototype.dispose = function () {
      this.$popover.empty();
      this.$popoverContent.empty();
      Object.keys(this).forEach(function (key) {
        this[key] = undefined;
      });
    };

    function createMenuElements(itemList, popover) {
      return itemList.map(item => {
        let elem;

        if (typeof item === 'string' && '<hr/>' === item) {
          elem = document.createElement('hr');
        } else if (typeof item === 'string') {
          elem = div$1({
            class: 'context-menu'
          });
          elem.innerHTML = item;
        } else if (typeof item === 'Node') {
          elem = item;
        } else {
          if (typeof item.init === 'function') {
            item.init();
          }

          if ("checkbox" === item.type) {
            elem = Icon.createCheckbox("Show all bases", item.value);
          } else if ("color" === item.type) {
            const colorPicker = new ColorPicker({
              parent: popover.parentElement,
              width: 364,
              //defaultColor: 'aqua',
              colorHandler: color => item.click(color)
            });
            elem = div$1({
              class: 'context-menu'
            });

            if (typeof item.label === 'string') {
              elem.innerHTML = item.label;
            }

            const clickHandler = e => {
              colorPicker.show();
              hide$1(popover);
              e.preventDefault();
              e.stopPropagation();
            };

            elem.addEventListener('click', clickHandler);
            elem.addEventListener('touchend', clickHandler);
            elem.addEventListener('mouseup', function (e) {
              e.preventDefault();
              e.stopPropagation();
            });
          } else {
            elem = div$1({
              class: 'context-menu'
            });

            if (typeof item.label === 'string') {
              elem.innerHTML = item.label;
            }
          }

          if (item.click && "color" !== item.type) {
            elem.addEventListener('click', handleClick);
            elem.addEventListener('touchend', handleClick);
            elem.addEventListener('mouseup', function (e) {
              e.preventDefault();
              e.stopPropagation();
            }); // eslint-disable-next-line no-inner-declarations

            function handleClick(e) {
              item.click();
              hide$1(popover);
              e.preventDefault();
              e.stopPropagation();
            }
          }
        }

        return {
          object: elem,
          init: item.init
        };
      });
    }

    function present(e, popover) {
      const {
        x,
        y
      } = translateMouseCoordinates(e, popover.parentNode); // parent bbox

      const {
        width
      } = popover.parentNode.getBoundingClientRect();
      const {
        width: w
      } = popover.getBoundingClientRect();
      const xmax = x + w;
      popover.style.left = `${xmax > width ? x - (xmax - width) : x}px`;
      popover.style.top = `${y}px`;
    }

    const hideAllMenuPopups = () => $('.igv-menu-popup').hide();

    /**
     * Created by dat on 4/5/17.
     */

    class TrackPair {
      constructor(browser, trackHeight, $x_tracks, $y_tracks, track, index) {
        this.browser = browser;
        this.track = track;
        this.x = new TrackRenderer(browser, {
          height: trackHeight
        }, $x_tracks, track, 'x', index);
        this.y = new TrackRenderer(browser, {
          width: trackHeight
        }, $y_tracks, track, 'y', index);
        this.init();
      }

      init() {
        this.colorPicker = new ColorPicker({
          parent: this.x.$viewport[0],
          width: 456,
          height: undefined,
          colorHandler: color => this.setColor(color)
        });
        this.colorPicker.hide();
        this.dataRangeDialog = new DataRangeDialog(this.x.$viewport[0], (min, max) => this.setDataRange(min, max));
        this.appendRightHandGutter(this.x.$viewport); // igvjs compatibility

        this.track.trackView = this;
        this.track.trackView.trackDiv = this.x.$viewport.get(0);
      }

      presentColorPicker() {
        const bbox = this.x.trackDiv.getBoundingClientRect();
        this.colorPicker.origin = {
          x: bbox.x,
          y: 0
        };
        this.colorPicker.$container.offset({
          left: this.colorPicker.origin.x,
          top: this.colorPicker.origin.y
        });
        this.colorPicker.$container.show();
      }

      setTrackName(name) {
        this.track.name = name;
        this.x.$label.text(name);
      }

      setColor(color) {
        this.y.tile = undefined;
        this.x.tile = undefined;
        this.track.color = color;
        this.repaintViews();
      }

      dataRange() {
        return this.track.dataRange ? this.track.dataRange : undefined;
      }

      setDataRange(min, max) {
        if (min !== undefined) {
          this.track.dataRange.min = min;
          this.track.config.min = min;
        }

        if (max !== undefined) {
          this.track.dataRange.max = max;
          this.track.config.max = max;
        }

        this.track.autoscale = false;
        this.track.config.autoScale = false;
        this.y.tile = undefined;
        this.x.tile = undefined;
        this.repaintViews();
      }

      appendRightHandGutter($parent) {
        let $div = $('<div class="hic-igv-right-hand-gutter">');
        $parent.append($div);
        this.createTrackGearPopup($div);
      }

      createTrackGearPopup($parent) {
        let $container = $("<div>", {
          class: 'igv-trackgear-container'
        });
        $parent.append($container);
        $container.append(createIcon('cog'));
        this.trackGearPopup = new MenuPopup($parent);
        this.trackGearPopup.$popover.hide();
        $container.click(e => {
          e.preventDefault();
          e.stopPropagation();
          this.trackGearPopup.presentMenuList(-this.trackGearPopup.$popover.width(), 0, MenuUtils.trackMenuItemList(this));
        });
      }

      async updateViews() {
        if (this.updating) {
          this.pending = true;
        } else {
          try {
            this.updating = true;
            const genomicStateX = this.browser.genomicState(this.x.axis);
            let imageTileX = await this.getTileX(genomicStateX);

            if (imageTileX) {
              this.x.drawTile(imageTileX, genomicStateX);
            }

            const genomicStateY = this.browser.genomicState(this.y.axis);
            let imageTileY = await this.getTileY(genomicStateY);

            if (imageTileY) {
              this.y.drawTile(imageTileY, genomicStateY);
            }
          } finally {
            this.updating = false;

            if (this.pending) {
              this.pending = false;
              this.updateViews();
            }
          }
        }
      }
      /**
       * Repaint current tiles with cached features (due to color, scale, or other visual attribute change)
       * @returns {Promise<void>}
       */


      async repaintViews() {
        const genomicStateX = this.browser.genomicState(this.x.axis);

        if (this.tileX) {
          this.tileX = await this.createImageTile(genomicStateX, this.tileX.features);
          this.x.drawTile(this.tileX, genomicStateX);
        }

        const genomicStateY = this.browser.genomicState(this.y.axis);

        if (this.tileY) {
          this.tileY = await this.createImageTile(genomicStateX, this.tileY.features);
          this.y.drawTile(this.tileY, genomicStateY);
        }
      }

      async getTileX(genomicState) {
        const chrName = genomicState.chromosome.name;
        const bpPerPixel = genomicState.bpp;

        if (!(this.tileX && this.tileX.containsRange(chrName, genomicState.startBP, genomicState.endBP, bpPerPixel))) {
          this.tileX = await this.createImageTile(genomicState);
        }

        return this.tileX;
      }

      async getTileY(genomicState) {
        const chrName = genomicState.chromosome.name;
        const bpPerPixel = genomicState.bpp;

        if (this.tileX && this.tileX.containsRange(chrName, genomicState.startBP, genomicState.endBP, bpPerPixel)) {
          this.tileY = this.tileX;
        } else if (!(this.tileY && this.tileY.containsRange(chrName, genomicState.startBP, genomicState.endBP, bpPerPixel))) {
          this.tileY = await this.createImageTile(genomicState);
        }

        return this.tileY;
      }

      async createImageTile(genomicState, tileFeatures) {
        const chrName = genomicState.chromosome.name;
        const bpPerPixel = genomicState.bpp;

        if (bpPerPixel * Math.max(this.x.$canvas.width(), this.x.$canvas.height()) > this.track.visibilityWindow) ; else {
          // Expand the requested range so we can pan a bit without reloading
          const pixelWidth = 3 * this.x.$canvas.width();
          const lengthBP = Math.round(bpPerPixel * pixelWidth);
          const bpStart = Math.max(0, Math.round(genomicState.startBP - lengthBP / 3));
          const bpEnd = bpStart + lengthBP;
          const features = tileFeatures || (await this.track.getFeatures(genomicState.chromosome.name, bpStart, bpEnd, bpPerPixel));
          const buffer = document.createElement('canvas');
          buffer.width = pixelWidth;
          buffer.height = this.x.$canvas.height();
          const context = buffer.getContext("2d");

          if (features) {
            const drawConfiguration = {
              features,
              context,
              pixelWidth,
              bpStart,
              bpEnd,
              bpPerPixel,
              genomicState,
              pixelHeight: Math.min(buffer.width, buffer.height),
              viewportContainerX: (genomicState.startBP - bpStart) / bpPerPixel,
              viewportContainerWidth: pixelWidth,
              viewportWidth: pixelWidth,
              referenceFrame: {}
            };

            if (this.track.autoscale || !this.track.dataRange) {
              if (typeof this.track.doAutoscale === 'function') {
                this.track.doAutoscale(features);
              } else {
                this.track.dataRange = doAutoscale(features);
              }
            }

            this.track.draw(drawConfiguration);
          } else {
            context.clearRect(0, 0, this.$canvas.width(), this.$canvas.height());
          }

          this.tile = new Tile(chrName, bpStart, bpEnd, bpPerPixel, buffer, features);
          return this.tile;
        }
      }

      dispose() {
        this['x'].dispose();
        this['y'].dispose();
      }

    }

    class TrackRenderer {
      constructor(browser, size, $container, track, axis, order) {
        this.browser = browser;
        this.track = track;
        this.id = `trackRender_${guid()}`;
        this.axis = axis;
        this.init($container, size, order);
      }

      init($container, size, order) {
        var self = this; // track canvas container

        this.$viewport = 'x' === this.axis ? $('<div class="x-track-canvas-container">') : $('<div class="y-track-canvas-container">');

        if (size.width) {
          this.$viewport.width(size.width);
        }

        if (size.height) {
          this.$viewport.height(size.height);
        }

        $container.append(this.$viewport);
        this.$viewport.css({
          order: order
        }); // canvas

        this.$canvas = $('<canvas>');
        this.$viewport.append(this.$canvas);
        this.ctx = this.$canvas.get(0).getContext("2d");

        if ('x' === this.axis) {
          // label
          this.$label = $('<div class="x-track-label">');
          const str = this.track.name || 'untitled';
          this.$label.text(str);
          this.$viewport.append(this.$label);

          if (true === self.browser.showTrackLabelAndGutter) {
            this.$label.show();
          } else {
            this.$label.hide();
          }

          this.$viewport.on('click', function (e) {
            e.preventDefault();
            e.stopPropagation();
            self.browser.toggleTrackLabelAndGutterState();

            if (true === self.browser.showTrackLabelAndGutter) {
              $('.x-track-label').show();
              $('.hic-igv-right-hand-gutter').show();
            } else {
              $('.x-track-label').hide();
              $('.hic-igv-right-hand-gutter').hide();
            }
          });
        } // track spinner container


        this.$spinner = 'x' === this.axis ? $('<div class="x-track-spinner">') : $('<div class="y-track-spinner">');
        this.$viewport.append(this.$spinner);
        this.stopSpinner();
      }

      dispose($container, size, order) {
        this.tile = undefined;
        this.$viewport.remove();
      }

      syncCanvas() {
        this.$canvas.width(this.$viewport.width());
        this.$canvas.attr('width', this.$viewport.width());
        this.$canvas.height(this.$viewport.height());
        this.$canvas.attr('height', this.$viewport.height());
      }

      drawTile(tile, genomicState) {
        if (tile) {
          this.offsetPixel = Math.round((tile.startBP - genomicState.startBP) / genomicState.bpp);

          if ('x' === this.axis) {
            this.ctx.clearRect(0, 0, this.$canvas.width(), this.$canvas.height());
            this.ctx.drawImage(tile.buffer, this.offsetPixel, 0);
          } else {
            this.ctx.setTransform(0, 1, 1, 0, 0, 0);
            this.ctx.clearRect(0, 0, this.$canvas.height(), this.$canvas.width());
            this.ctx.drawImage(tile.buffer, this.offsetPixel, 0);
          }
        }
      }

      startSpinner() {
        this.browser.startSpinner();
      }

      stopSpinner() {
        this.browser.stopSpinner();
      }

      isLoading() {
        return !(undefined === this.loading);
      }

    }

    class Tile {
      constructor(chr, startBP, endBP, bpp, buffer, features) {
        this.chr = chr;
        this.startBP = startBP;
        this.endBP = endBP;
        this.bpp = bpp;
        this.buffer = buffer;
        this.features = features;
      }

      containsRange(chr, startBP, endBP, bpp) {
        return chr === this.chr && this.bpp === bpp && this.startBP <= startBP && this.endBP >= endBP;
      }

    }

    /**
     * Created by dat on 4/4/17.
     */
    // $nav-bar-label-height: 36px;

    const nav_bar_label_height = 36; // $nav-bar-widget-container-height: 36px;

    const nav_bar_widget_container_height = 36; // $nav-bar-widget-container-margin: 4px;

    const nav_bar_widget_container_margin = 4; // $hic-scrollbar-height: 20px;

    const scrollbar_height = 20; // $hic-axis-height: 40px;

    const axis_height = 40; // $track-margin: 2px;

    const track_margin = 2;
    const trackHeight = 40;

    class LayoutController {
      constructor(browser, $root) {
        this.browser = browser;
        createNavBar(browser, $root);
        this.createAllContainers(browser, $root);
      }

      createAllContainers(browser, $root) {
        const html_x_track_container = `<div id="${browser.id}-x-track-container"><div id="${browser.id}-track-shim"></div><div id="${browser.id}-x-tracks"><div id="${browser.id}-y-track-guide" style="display: none;"></div></div></div>`;
        $root.append($(html_x_track_container));
        this.$x_track_container = $root.find("div[id$='x-track-container']");
        this.$track_shim = this.$x_track_container.find("div[id$='track-shim']");
        this.$x_tracks = this.$x_track_container.find("div[id$='x-tracks']");
        this.$y_track_guide = this.$x_track_container.find("div[id$='y-track-guide']");
        const html_content_container = `<div id="${browser.id}-content-container"></div>`;
        this.$content_container = $(html_content_container);
        $root.append(this.$content_container);
        const html_x_axis_container = `<div id="${browser.id}-x-axis-container">
            <div id="${browser.id}-x-axis">
                <canvas></canvas>
                <div id="${browser.id}-x-axis-whole-genome-container"></div>
            </div>
	    </div>`;
        this.$content_container.append($(html_x_axis_container));
        const $x_axis_container = this.$content_container.find("div[id$='x-axis-container']");
        this.xAxisRuler = new Ruler(browser, $x_axis_container, 'x');
        const html_y_tracks_y_axis_viewport_y_scrollbar = `<div id="${browser.id}-y-tracks-y-axis-viewport-y-scrollbar">

            <div id="${browser.id}-y-tracks">
                <div id="${browser.id}-x-track-guide" style="display: none;"></div>
            </div>
            
            <div id="${browser.id}-y-axis">
    			<canvas></canvas>
			    <div id="${browser.id}-y-axis-whole-genome-container"></div>
		    </div>
		    
        </div>`;
        this.$content_container.append($(html_y_tracks_y_axis_viewport_y_scrollbar));
        const $y_tracks_y_axis_viewport_y_scrollbar = this.$content_container.find("div[id$='-y-tracks-y-axis-viewport-y-scrollbar']");
        this.$y_tracks = $y_tracks_y_axis_viewport_y_scrollbar.find("div[id$='-y-tracks']");
        this.$x_track_guide = this.$y_tracks.find("div[id$='-x-track-guide']");
        this.yAxisRuler = new Ruler(browser, $y_tracks_y_axis_viewport_y_scrollbar, 'y');
        this.xAxisRuler.$otherRulerCanvas = this.yAxisRuler.$canvas;
        this.xAxisRuler.otherRuler = this.yAxisRuler;
        this.yAxisRuler.$otherRulerCanvas = this.xAxisRuler.$canvas;
        this.yAxisRuler.otherRuler = this.xAxisRuler;
        const html_viewport = `<div id="${browser.id}-viewport">
			<canvas></canvas>
			<i class="fa fa-spinner fa-spin" style="font-size: 48px; position: absolute; left: 40%; top: 40%; display: none;"></i>
			<div id="${browser.id}-sweep-zoom-container" style="display: none;"></div>
			<div id="${browser.id}-x-guide" style="display: none;"></div>
			<div id="${browser.id}-y-guide" style="display: none;"></div>
		</div>`;
        $y_tracks_y_axis_viewport_y_scrollbar.append($(html_viewport));
        const html_y_axis_scrollbar_container = `<div id="${browser.id}-y-axis-scrollbar-container">
			<div id="${browser.id}-y-axis-scrollbar">
				<div class="scrollbar-label-rotation-in-place"></div>
			</div>
		</div>`;
        $y_tracks_y_axis_viewport_y_scrollbar.append($(html_y_axis_scrollbar_container));
        const html_x_axis_scrollbar_container = `<div id="${browser.id}-x-scrollbar-container">
            <div id="${browser.id}-x-axis-scrollbar-container">
                <div id="${browser.id}-x-axis-scrollbar">
                    <div></div>
                </div>
            </div>
	    </div>`;
        this.$content_container.append($(html_x_axis_scrollbar_container));
      }

      getContactMatrixViewport() {
        const $parent = this.$content_container.find("div[id$='-y-tracks-y-axis-viewport-y-scrollbar']");
        return $parent.find("div[id$='-viewport']");
      }

      getYAxisScrollbarContainer() {
        const $parent = this.$content_container.find("div[id$='-y-tracks-y-axis-viewport-y-scrollbar']");
        return $parent.find("div[id$='-y-axis-scrollbar-container']");
      }

      getXAxisScrollbarContainer() {
        return this.$content_container.find("div[id$='-x-axis-scrollbar-container']");
      }

      tracksLoaded(tracks) {
        this.doLayoutTrackXYPairCount(tracks.length + this.browser.trackPairs.length);
        tracks.forEach((track, index) => {
          const trackPair = new TrackPair(this.browser, trackHeight, this.$x_tracks, this.$y_tracks, track, index);
          this.browser.trackPairs.push(trackPair);
        });
      }

      removeAllTrackXYPairs() {
        if (this.browser.trackPairs.length === 0) {
          return;
        }

        for (let trackPair of this.browser.trackPairs) {
          // discard DOM element's
          trackPair.dispose();
        }

        this.browser.trackPairs = [];
        this.browser.updateLayout();
        this.doLayoutTrackXYPairCount(0); // What ???
        // [...Array(this.browser.trackPairs.length).keys()].forEach(() => {
        //
        //     // select last track to discard
        //     let discard = this.browser.trackPairs[this.browser.trackPairs.length - 1];
        //
        //     // discard DOM element's
        //     discard['x'].$viewport.remove();
        //     discard['y'].$viewport.remove();
        //
        //     // remove discard from list
        //     const index = this.browser.trackPairs.indexOf(discard);
        //     this.browser.trackPairs.splice(index, 1);
        //
        //     discard = undefined;
        //     this.doLayoutTrackXYPairCount(this.browser.trackPairs.length);
        //
        // });
      }

      removeLastTrackXYPair() {
        if (this.browser.trackPairs.length > 0) {
          // select last track to dicard
          let discard = this.browser.trackPairs[this.browser.trackPairs.length - 1]; // discard DOM element's

          discard['x'].$viewport.remove();
          discard['y'].$viewport.remove(); // remove discard from list

          const index = this.browser.trackPairs.indexOf(discard);
          this.browser.trackPairs.splice(index, 1);
          discard = undefined;
          this.doLayoutTrackXYPairCount(this.browser.trackPairs.length);
          this.browser.updateLayout();
        }
      }

      removeTrackXYPair(trackXYPair) {
        if (this.browser.trackPairs.length > 0) {
          const discard = trackXYPair; // discard DOM element's

          discard['x'].$viewport.remove();
          discard['y'].$viewport.remove(); // remove discard from list

          const index = this.browser.trackPairs.indexOf(discard);
          this.browser.trackPairs.splice(index, 1);
          this.doLayoutTrackXYPairCount(this.browser.trackPairs.length);
          this.browser.updateLayout();
        }
      }

      doLayoutTrackXYPairCount(trackXYPairCount) {
        const track_aggregate_height = 0 === trackXYPairCount ? 0 : trackXYPairCount * (trackHeight + track_margin);
        let tokens = [getNavbarHeight(), track_aggregate_height].map(number => `${number}px`);
        const height_calc = 'calc(100% - (' + tokens.join(' + ') + '))';
        tokens = [track_aggregate_height, axis_height, scrollbar_height].map(number => `${number}px`);
        const width_calc = 'calc(100% - (' + tokens.join(' + ') + '))'; // x-track container

        this.$x_track_container.height(track_aggregate_height); // track labels

        this.$track_shim.width(track_aggregate_height); // x-tracks

        this.$x_tracks.css('width', width_calc); // content container

        this.$content_container.css('height', height_calc); // x-axis - repaint canvas

        this.xAxisRuler.updateWidthWithCalculation(width_calc); // y-tracks

        this.$y_tracks.width(track_aggregate_height); // y-axis - repaint canvas

        this.yAxisRuler.updateHeight(this.yAxisRuler.$axis.height()); // viewport

        this.browser.contactMatrixView.$viewport.css('width', width_calc); // x-scrollbar

        this.browser.contactMatrixView.scrollbarWidget.$x_axis_scrollbar_container.css('width', width_calc);
      }

      doLayoutWithRootContainerSize(size) {
        this.browser.$root.width(size.width);
        this.browser.$root.height(size.height + getNavbarHeight());
        const count = this.browser.trackPairs.length > 0 ? this.browser.trackPairs.length : 0;
        this.doLayoutTrackXYPairCount(count);
        this.browser.updateLayout();
      }

    }

    const getNavbarHeight = () => 2 * (nav_bar_label_height + nav_bar_widget_container_height + 2 * nav_bar_widget_container_margin);

    const getNavbarContainer = browser => browser.$root.find('.hic-navbar-container');

    function createNavBar(browser, $root) {
      const $hic_navbar_container = $('<div>', {
        class: 'hic-navbar-container'
      });
      $root.append($hic_navbar_container);
      $hic_navbar_container.on('click', e => {
        e.stopPropagation();
        e.preventDefault();
        setCurrentBrowser(browser);
      });
      const html_contact_map_hic_nav_bar_map_container = `<div id="${browser.id}-contact-map-hic-nav-bar-map-container">
            <div id="${browser.id}-contact-map-hic-nav-bar-map-label">
            </div>
             <div class="hic-nav-bar-button-container">
                <i class="fa fa-bars fa-lg" title="Present menu"></i>
                <i class="fa fa-minus-circle fa-lg" title="Delete browser panel" style="display: none;"></i>
             </div>
        </div>`;
      $hic_navbar_container.append($(html_contact_map_hic_nav_bar_map_container));
      browser.$contactMaplabel = $hic_navbar_container.find("div[id$='contact-map-hic-nav-bar-map-label']");
      browser.$menuPresentDismiss = $hic_navbar_container.find('.fa-bars');
      browser.$menuPresentDismiss.on('click', e => browser.toggleMenu());
      browser.$browser_panel_delete_button = $hic_navbar_container.find('.fa-minus-circle');
      browser.$browser_panel_delete_button.on('click', e => deleteBrowser(browser)); // Delete button is only vidible if there is more then one browser

      browser.$browser_panel_delete_button.hide();
      const html_control_map_hic_nav_bar_map_container = `<div id="${browser.id}-control-map-hic-nav-bar-map-container">
            <div id="${browser.id}-control-map-hic-nav-bar-map-label"></div>
        </div>`;
      $hic_navbar_container.append($(html_control_map_hic_nav_bar_map_container));
      browser.$controlMaplabel = $hic_navbar_container.find("div[id$='control-map-hic-nav-bar-map-label']");
      const html_upper_hic_nav_bar_widget_container = `<div id="${browser.id}-upper-hic-nav-bar-widget-container"></div>`;
      $hic_navbar_container.append($(html_upper_hic_nav_bar_widget_container));
      const html_lower_hic_nav_bar_widget_container = `<div id="${browser.id}-lower-hic-nav-bar-widget-container"></div>`;
      $hic_navbar_container.append($(html_lower_hic_nav_bar_widget_container));
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    function HICEvent(type, data, propogate) {
      return {
        type: type,
        data: data || {},
        propogate: propogate !== undefined ? propogate : true // Default to true

      };
    }

    // from https://github.com/imaya/zlib.js
    var Zlib = {
      Huffman: {},
      Util: {},
      CRC32: {}
    };
    /**
     * Compression Method
     * @enum {number}
     */

    Zlib.CompressionMethod = {
      DEFLATE: 8,
      RESERVED: 15
    };
    /**
     * @param {Object=} opt_params options.
     * @constructor
     */

    Zlib.Zip = function (opt_params) {
      opt_params = opt_params || {};
      /** @type {Array.<{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }>} */

      this.files = [];
      /** @type {(Array.<number>|Uint8Array)} */

      this.comment = opt_params['comment'];
      /** @type {(Array.<number>|Uint8Array)} */

      this.password;
    };
    /**
     * @enum {number}
     */


    Zlib.Zip.CompressionMethod = {
      STORE: 0,
      DEFLATE: 8
    };
    /**
     * @enum {number}
     */

    Zlib.Zip.OperatingSystem = {
      MSDOS: 0,
      UNIX: 3,
      MACINTOSH: 7
    };
    /**
     * @enum {number}
     */

    Zlib.Zip.Flags = {
      ENCRYPT: 0x0001,
      DESCRIPTOR: 0x0008,
      UTF8: 0x0800
    };
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib.Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib.Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib.Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];
    /**
     * @param {Array.<number>|Uint8Array} input
     * @param {Object=} opt_params options.
     */

    Zlib.Zip.prototype.addFile = function (input, opt_params) {
      opt_params = opt_params || {};
      /** @type {string} */

      opt_params['filename'];
      /** @type {boolean} */

      var compressed;
      /** @type {number} */

      var size = input.length;
      /** @type {number} */

      var crc32 = 0;

      if (input instanceof Array) {
        input = new Uint8Array(input);
      } // default


      if (typeof opt_params['compressionMethod'] !== 'number') {
        opt_params['compressionMethod'] = Zlib.Zip.CompressionMethod.DEFLATE;
      } // その場で圧縮する場合


      if (opt_params['compress']) {
        switch (opt_params['compressionMethod']) {
          case Zlib.Zip.CompressionMethod.STORE:
            break;

          case Zlib.Zip.CompressionMethod.DEFLATE:
            crc32 = Zlib.CRC32.calc(input);
            input = this.deflateWithOption(input, opt_params);
            compressed = true;
            break;

          default:
            throw new Error('unknown compression method:' + opt_params['compressionMethod']);
        }
      }

      this.files.push({
        buffer: input,
        option: opt_params,
        compressed: compressed,
        encrypted: false,
        size: size,
        crc32: crc32
      });
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     */


    Zlib.Zip.prototype.setPassword = function (password) {
      this.password = password;
    };

    Zlib.Zip.prototype.compress = function () {
      /** @type {Array.<{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }>} */
      var files = this.files;
      /** @type {{
       *   buffer: !(Array.<number>|Uint8Array),
       *   option: Object,
       *   compressed: boolean,
       *   encrypted: boolean,
       *   size: number,
       *   crc32: number
       * }} */

      var file;
      /** @type {!(Array.<number>|Uint8Array)} */

      var output;
      /** @type {number} */

      var op1;
      /** @type {number} */

      var op2;
      /** @type {number} */

      var op3;
      /** @type {number} */

      var localFileSize = 0;
      /** @type {number} */

      var centralDirectorySize = 0;
      /** @type {number} */

      var endOfCentralDirectorySize;
      /** @type {number} */

      var offset;
      /** @type {number} */

      var needVersion;
      /** @type {number} */

      var flags;
      /** @type {Zlib.Zip.CompressionMethod} */

      var compressionMethod;
      /** @type {Date} */

      var date;
      /** @type {number} */

      var crc32;
      /** @type {number} */

      var size;
      /** @type {number} */

      var plainSize;
      /** @type {number} */

      var filenameLength;
      /** @type {number} */

      var extraFieldLength;
      /** @type {number} */

      var commentLength;
      /** @type {(Array.<number>|Uint8Array)} */

      var filename;
      /** @type {(Array.<number>|Uint8Array)} */

      var extraField;
      /** @type {(Array.<number>|Uint8Array)} */

      var comment;
      /** @type {(Array.<number>|Uint8Array)} */

      var buffer;
      /** @type {*} */

      var tmp;
      /** @type {Array.<number>|Uint32Array|Object} */

      var key;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {number} */

      var j;
      /** @type {number} */

      var jl; // ファイルの圧縮

      for (i = 0, il = files.length; i < il; ++i) {
        file = files[i];
        filenameLength = file.option['filename'] ? file.option['filename'].length : 0;
        extraFieldLength = file.option['extraField'] ? file.option['extraField'].length : 0;
        commentLength = file.option['comment'] ? file.option['comment'].length : 0; // 圧縮されていなかったら圧縮

        if (!file.compressed) {
          // 圧縮前に CRC32 の計算をしておく
          file.crc32 = Zlib.CRC32.calc(file.buffer);

          switch (file.option['compressionMethod']) {
            case Zlib.Zip.CompressionMethod.STORE:
              break;

            case Zlib.Zip.CompressionMethod.DEFLATE:
              file.buffer = this.deflateWithOption(file.buffer, file.option);
              file.compressed = true;
              break;

            default:
              throw new Error('unknown compression method:' + file.option['compressionMethod']);
          }
        } // encryption


        if (file.option['password'] !== void 0 || this.password !== void 0) {
          // init encryption
          key = this.createEncryptionKey(file.option['password'] || this.password); // add header

          buffer = file.buffer;

          {
            tmp = new Uint8Array(buffer.length + 12);
            tmp.set(buffer, 12);
            buffer = tmp;
          }

          for (j = 0; j < 12; ++j) {
            buffer[j] = this.encode(key, i === 11 ? file.crc32 & 0xff : Math.random() * 256 | 0);
          } // data encryption


          for (jl = buffer.length; j < jl; ++j) {
            buffer[j] = this.encode(key, buffer[j]);
          }

          file.buffer = buffer;
        } // 必要バッファサイズの計算


        localFileSize += // local file header
        30 + filenameLength + // file data
        file.buffer.length;
        centralDirectorySize += // file header
        46 + filenameLength + commentLength;
      } // end of central directory


      endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);
      output = new (Uint8Array )(localFileSize + centralDirectorySize + endOfCentralDirectorySize);
      op1 = 0;
      op2 = localFileSize;
      op3 = op2 + centralDirectorySize; // ファイルの圧縮

      for (i = 0, il = files.length; i < il; ++i) {
        file = files[i];
        filenameLength = file.option['filename'] ? file.option['filename'].length : 0;
        extraFieldLength = 0; // TODO

        commentLength = file.option['comment'] ? file.option['comment'].length : 0; //-------------------------------------------------------------------------
        // local file header & file header
        //-------------------------------------------------------------------------

        offset = op1; // signature
        // local file header

        output[op1++] = Zlib.Zip.LocalFileHeaderSignature[0];
        output[op1++] = Zlib.Zip.LocalFileHeaderSignature[1];
        output[op1++] = Zlib.Zip.LocalFileHeaderSignature[2];
        output[op1++] = Zlib.Zip.LocalFileHeaderSignature[3]; // file header

        output[op2++] = Zlib.Zip.FileHeaderSignature[0];
        output[op2++] = Zlib.Zip.FileHeaderSignature[1];
        output[op2++] = Zlib.Zip.FileHeaderSignature[2];
        output[op2++] = Zlib.Zip.FileHeaderSignature[3]; // compressor info

        needVersion = 20;
        output[op2++] = needVersion & 0xff;
        output[op2++] =
        /** @type {Zlib.Zip.OperatingSystem} */
        file.option['os'] || Zlib.Zip.OperatingSystem.MSDOS; // need version

        output[op1++] = output[op2++] = needVersion & 0xff;
        output[op1++] = output[op2++] = needVersion >> 8 & 0xff; // general purpose bit flag

        flags = 0;

        if (file.option['password'] || this.password) {
          flags |= Zlib.Zip.Flags.ENCRYPT;
        }

        output[op1++] = output[op2++] = flags & 0xff;
        output[op1++] = output[op2++] = flags >> 8 & 0xff; // compression method

        compressionMethod =
        /** @type {Zlib.Zip.CompressionMethod} */
        file.option['compressionMethod'];
        output[op1++] = output[op2++] = compressionMethod & 0xff;
        output[op1++] = output[op2++] = compressionMethod >> 8 & 0xff; // date

        date =
        /** @type {(Date|undefined)} */
        file.option['date'] || new Date();
        output[op1++] = output[op2++] = (date.getMinutes() & 0x7) << 5 | (date.getSeconds() / 2 | 0);
        output[op1++] = output[op2++] = date.getHours() << 3 | date.getMinutes() >> 3; //

        output[op1++] = output[op2++] = (date.getMonth() + 1 & 0x7) << 5 | date.getDate();
        output[op1++] = output[op2++] = (date.getFullYear() - 1980 & 0x7f) << 1 | date.getMonth() + 1 >> 3; // CRC-32

        crc32 = file.crc32;
        output[op1++] = output[op2++] = crc32 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 8 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 16 & 0xff;
        output[op1++] = output[op2++] = crc32 >> 24 & 0xff; // compressed size

        size = file.buffer.length;
        output[op1++] = output[op2++] = size & 0xff;
        output[op1++] = output[op2++] = size >> 8 & 0xff;
        output[op1++] = output[op2++] = size >> 16 & 0xff;
        output[op1++] = output[op2++] = size >> 24 & 0xff; // uncompressed size

        plainSize = file.size;
        output[op1++] = output[op2++] = plainSize & 0xff;
        output[op1++] = output[op2++] = plainSize >> 8 & 0xff;
        output[op1++] = output[op2++] = plainSize >> 16 & 0xff;
        output[op1++] = output[op2++] = plainSize >> 24 & 0xff; // filename length

        output[op1++] = output[op2++] = filenameLength & 0xff;
        output[op1++] = output[op2++] = filenameLength >> 8 & 0xff; // extra field length

        output[op1++] = output[op2++] = extraFieldLength & 0xff;
        output[op1++] = output[op2++] = extraFieldLength >> 8 & 0xff; // file comment length

        output[op2++] = commentLength & 0xff;
        output[op2++] = commentLength >> 8 & 0xff; // disk number start

        output[op2++] = 0;
        output[op2++] = 0; // internal file attributes

        output[op2++] = 0;
        output[op2++] = 0; // external file attributes

        output[op2++] = 0;
        output[op2++] = 0;
        output[op2++] = 0;
        output[op2++] = 0; // relative offset of local header

        output[op2++] = offset & 0xff;
        output[op2++] = offset >> 8 & 0xff;
        output[op2++] = offset >> 16 & 0xff;
        output[op2++] = offset >> 24 & 0xff; // filename

        filename = file.option['filename'];

        if (filename) {
          {
            output.set(filename, op1);
            output.set(filename, op2);
            op1 += filenameLength;
            op2 += filenameLength;
          }
        } // extra field


        extraField = file.option['extraField'];

        if (extraField) {
          {
            output.set(extraField, op1);
            output.set(extraField, op2);
            op1 += extraFieldLength;
            op2 += extraFieldLength;
          }
        } // comment


        comment = file.option['comment'];

        if (comment) {
          {
            output.set(comment, op2);
            op2 += commentLength;
          }
        } //-------------------------------------------------------------------------
        // file data
        //-------------------------------------------------------------------------


        {
          output.set(file.buffer, op1);
          op1 += file.buffer.length;
        }
      } //-------------------------------------------------------------------------
      // end of central directory
      //-------------------------------------------------------------------------
      // signature


      output[op3++] = Zlib.Zip.CentralDirectorySignature[0];
      output[op3++] = Zlib.Zip.CentralDirectorySignature[1];
      output[op3++] = Zlib.Zip.CentralDirectorySignature[2];
      output[op3++] = Zlib.Zip.CentralDirectorySignature[3]; // number of this disk

      output[op3++] = 0;
      output[op3++] = 0; // number of the disk with the start of the central directory

      output[op3++] = 0;
      output[op3++] = 0; // total number of entries in the central directory on this disk

      output[op3++] = il & 0xff;
      output[op3++] = il >> 8 & 0xff; // total number of entries in the central directory

      output[op3++] = il & 0xff;
      output[op3++] = il >> 8 & 0xff; // size of the central directory

      output[op3++] = centralDirectorySize & 0xff;
      output[op3++] = centralDirectorySize >> 8 & 0xff;
      output[op3++] = centralDirectorySize >> 16 & 0xff;
      output[op3++] = centralDirectorySize >> 24 & 0xff; // offset of start of central directory with respect to the starting disk number

      output[op3++] = localFileSize & 0xff;
      output[op3++] = localFileSize >> 8 & 0xff;
      output[op3++] = localFileSize >> 16 & 0xff;
      output[op3++] = localFileSize >> 24 & 0xff; // .ZIP file comment length

      commentLength = this.comment ? this.comment.length : 0;
      output[op3++] = commentLength & 0xff;
      output[op3++] = commentLength >> 8 & 0xff; // .ZIP file comment

      if (this.comment) {
        {
          output.set(this.comment, op3);
          op3 += commentLength;
        }
      }

      return output;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input
     * @param {Object=} opt_params options.
     * @return {!(Array.<number>|Uint8Array)}
     */


    Zlib.Zip.prototype.deflateWithOption = function (input, opt_params) {
      /** @type {Zlib.RawDeflate} */
      var deflator = new Zlib.RawDeflate(input, opt_params['deflateOption']);
      return deflator.compress();
    };
    /**
     * @param {(Array.<number>|Uint32Array)} key
     * @return {number}
     */


    Zlib.Zip.prototype.getByte = function (key) {
      /** @type {number} */
      var tmp = key[2] & 0xffff | 2;
      return tmp * (tmp ^ 1) >> 8 & 0xff;
    };
    /**
     * @param {(Array.<number>|Uint32Array|Object)} key
     * @param {number} n
     * @return {number}
     */


    Zlib.Zip.prototype.encode = function (key, n) {
      /** @type {number} */
      var tmp = this.getByte(
      /** @type {(Array.<number>|Uint32Array)} */
      key);
      this.updateKeys(
      /** @type {(Array.<number>|Uint32Array)} */
      key, n);
      return tmp ^ n;
    };
    /**
     * @param {(Array.<number>|Uint32Array)} key
     * @param {number} n
     */


    Zlib.Zip.prototype.updateKeys = function (key, n) {
      key[0] = Zlib.CRC32.single(key[0], n);
      key[1] = (((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681 >>> 0) + 1 >>> 0;
      key[2] = Zlib.CRC32.single(key[2], key[1] >>> 24);
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     * @return {!(Array.<number>|Uint32Array|Object)}
     */


    Zlib.Zip.prototype.createEncryptionKey = function (password) {
      /** @type {!(Array.<number>|Uint32Array)} */
      var key = [305419896, 591751049, 878082192];
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;

      {
        key = new Uint32Array(key);
      }

      for (i = 0, il = password.length; i < il; ++i) {
        this.updateKeys(key, password[i] & 0xff);
      }

      return key;
    };
    /**
     * build huffman table from length list.
     * @param {!(Array.<number>|Uint8Array)} lengths length list.
     * @return {!Array} huffman table.
     */


    Zlib.Huffman.buildHuffmanTable = function (lengths) {
      /** @type {number} length list size. */
      var listSize = lengths.length;
      /** @type {number} max code length for table size. */

      var maxCodeLength = 0;
      /** @type {number} min code length for table size. */

      var minCodeLength = Number.POSITIVE_INFINITY;
      /** @type {number} table size. */

      var size;
      /** @type {!(Array|Uint8Array)} huffman code table. */

      var table;
      /** @type {number} bit length. */

      var bitLength;
      /** @type {number} huffman code. */

      var code;
      /**
       * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.
       * @type {number} skip length for table filling.
       */

      var skip;
      /** @type {number} reversed code. */

      var reversed;
      /** @type {number} reverse temp. */

      var rtemp;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limit. */

      var il;
      /** @type {number} loop counter. */

      var j;
      /** @type {number} table value. */

      var value; // Math.max は遅いので最長の値は for-loop で取得する

      for (i = 0, il = listSize; i < il; ++i) {
        if (lengths[i] > maxCodeLength) {
          maxCodeLength = lengths[i];
        }

        if (lengths[i] < minCodeLength) {
          minCodeLength = lengths[i];
        }
      }

      size = 1 << maxCodeLength;
      table = new (Uint32Array )(size); // ビット長の短い順からハフマン符号を割り当てる

      for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {
        for (i = 0; i < listSize; ++i) {
          if (lengths[i] === bitLength) {
            // ビットオーダーが逆になるためビット長分並びを反転する
            for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
              reversed = reversed << 1 | rtemp & 1;
              rtemp >>= 1;
            } // 最大ビット長をもとにテーブルを作るため、
            // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる
            // そのどちらでも良い場所は同じ値で埋めることで
            // 本来のビット長以上のビット数取得しても問題が起こらないようにする


            value = bitLength << 16 | i;

            for (j = reversed; j < size; j += skip) {
              table[j] = value;
            }

            ++code;
          }
        } // 次のビット長へ


        ++bitLength;
        code <<= 1;
        skip <<= 1;
      }

      return [table, maxCodeLength, minCodeLength];
    }; //-----------------------------------------------------------------------------

    /** @define {number} buffer block size. */


    var ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]
    //-----------------------------------------------------------------------------

    var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;
    /**
     * @constructor
     * @param {!(Uint8Array|Array.<number>)} input input buffer.
     * @param {Object} opt_params option parameter.
     *
     * opt_params は以下のプロパティを指定する事ができます。
     *   - index: input buffer の deflate コンテナの開始位置.
     *   - blockSize: バッファのブロックサイズ.
     *   - bufferType: Zlib.RawInflate.BufferType の値によってバッファの管理方法を指定する.
     *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.
     */

    Zlib.RawInflate = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} inflated buffer */
      this.buffer;
      /** @type {!Array.<(Array.<number>|Uint8Array)>} */

      this.blocks = [];
      /** @type {number} block size. */

      this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;
      /** @type {!number} total output buffer pointer. */

      this.totalpos = 0;
      /** @type {!number} input buffer pointer. */

      this.ip = 0;
      /** @type {!number} bit stream reader buffer. */

      this.bitsbuf = 0;
      /** @type {!number} bit stream reader buffer size. */

      this.bitsbuflen = 0;
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */

      this.input = new Uint8Array(input) ;
      /** @type {!(Uint8Array|Array.<number>)} output buffer. */

      this.output;
      /** @type {!number} output buffer pointer. */

      this.op;
      /** @type {boolean} is final block flag. */

      this.bfinal = false;
      /** @type {Zlib.RawInflate.BufferType} buffer management. */

      this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;
      /** @type {boolean} resize flag for memory size optimization. */

      this.resize = false; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (opt_params['index']) {
          this.ip = opt_params['index'];
        }

        if (opt_params['bufferSize']) {
          this.bufferSize = opt_params['bufferSize'];
        }

        if (opt_params['bufferType']) {
          this.bufferType = opt_params['bufferType'];
        }

        if (opt_params['resize']) {
          this.resize = opt_params['resize'];
        }
      } // initialize


      switch (this.bufferType) {
        case Zlib.RawInflate.BufferType.BLOCK:
          this.op = Zlib.RawInflate.MaxBackwardLength;
          this.output = new (Uint8Array )(Zlib.RawInflate.MaxBackwardLength + this.bufferSize + Zlib.RawInflate.MaxCopyLength);
          break;

        case Zlib.RawInflate.BufferType.ADAPTIVE:
          this.op = 0;
          this.output = new (Uint8Array )(this.bufferSize);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * @enum {number}
     */


    Zlib.RawInflate.BufferType = {
      BLOCK: 0,
      ADAPTIVE: 1
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array.<number>)} inflated buffer.
     */

    Zlib.RawInflate.prototype.decompress = function () {
      while (!this.bfinal) {
        this.parseBlock();
      }

      switch (this.bufferType) {
        case Zlib.RawInflate.BufferType.BLOCK:
          return this.concatBufferBlock();

        case Zlib.RawInflate.BufferType.ADAPTIVE:
          return this.concatBufferDynamic();

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * @const
     * @type {number} max backward length for LZ77.
     */


    Zlib.RawInflate.MaxBackwardLength = 32768;
    /**
     * @const
     * @type {number} max copy length for LZ77.
     */

    Zlib.RawInflate.MaxCopyLength = 258;
    /**
     * huffman order
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */

    Zlib.RawInflate.Order = function (table) {
      return new Uint16Array(table) ;
    }([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    /**
     * huffman length code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib.RawInflate.LengthCodeTable = function (table) {
      return new Uint16Array(table) ;
    }([0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b, 0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3, 0x00e3, 0x0102, 0x0102, 0x0102]);
    /**
     * huffman length extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib.RawInflate.LengthExtraTable = function (table) {
      return new Uint8Array(table) ;
    }([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
    /**
     * huffman dist code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib.RawInflate.DistCodeTable = function (table) {
      return new Uint16Array(table) ;
    }([0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001]);
    /**
     * huffman dist extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib.RawInflate.DistExtraTable = function (table) {
      return new Uint8Array(table) ;
    }([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    /**
     * fixed huffman length code table
     * @const
     * @type {!Array}
     */


    Zlib.RawInflate.FixedLiteralLengthTable = function (table) {
      return table;
    }(function () {
      var lengths = new (Uint8Array )(288);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
      }

      return buildHuffmanTable(lengths);
    }());
    /**
     * fixed huffman distance code table
     * @const
     * @type {!Array}
     */


    Zlib.RawInflate.FixedDistanceTable = function (table) {
      return table;
    }(function () {
      var lengths = new (Uint8Array )(30);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = 5;
      }

      return buildHuffmanTable(lengths);
    }());
    /**
     * parse deflated block.
     */


    Zlib.RawInflate.prototype.parseBlock = function () {
      /** @type {number} header */
      var hdr = this.readBits(3); // BFINAL

      if (hdr & 0x1) {
        this.bfinal = true;
      } // BTYPE


      hdr >>>= 1;

      switch (hdr) {
        // uncompressed
        case 0:
          this.parseUncompressedBlock();
          break;
        // fixed huffman

        case 1:
          this.parseFixedHuffmanBlock();
          break;
        // dynamic huffman

        case 2:
          this.parseDynamicHuffmanBlock();
          break;
        // reserved or other

        default:
          throw new Error('unknown BTYPE: ' + hdr);
      }
    };
    /**
     * read inflate bits
     * @param {number} length bits length.
     * @return {number} read bits.
     */


    Zlib.RawInflate.prototype.readBits = function (length) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {number} input and output byte. */

      var octet; // input byte

      if (ip + (length - bitsbuflen + 7 >> 3) >= inputLength) {
        throw new Error('input buffer is broken');
      } // not enough buffer


      while (bitsbuflen < length) {
        bitsbuf |= input[ip++] << bitsbuflen;
        bitsbuflen += 8;
      } // output byte


      octet = bitsbuf &
      /* MASK */
      (1 << length) - 1;
      bitsbuf >>>= length;
      bitsbuflen -= length;
      this.bitsbuf = bitsbuf;
      this.bitsbuflen = bitsbuflen;
      this.ip = ip;
      return octet;
    };
    /**
     * read huffman code using table
     * @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.
     * @return {number} huffman code.
     */


    Zlib.RawInflate.prototype.readCodeByTable = function (table) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {!(Array.<number>|Uint8Array)} huffman code table */

      var codeTable = table[0];
      /** @type {number} */

      var maxCodeLength = table[1];
      /** @type {number} code length & code (16bit, 16bit) */

      var codeWithLength;
      /** @type {number} code bits length */

      var codeLength; // not enough buffer

      while (bitsbuflen < maxCodeLength) {
        if (ip >= inputLength) {
          break;
        }

        bitsbuf |= input[ip++] << bitsbuflen;
        bitsbuflen += 8;
      } // read max length


      codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
      codeLength = codeWithLength >>> 16;

      if (codeLength > bitsbuflen) {
        throw new Error('invalid code length: ' + codeLength);
      }

      this.bitsbuf = bitsbuf >> codeLength;
      this.bitsbuflen = bitsbuflen - codeLength;
      this.ip = ip;
      return codeWithLength & 0xffff;
    };
    /**
     * parse uncompressed block.
     */


    Zlib.RawInflate.prototype.parseUncompressedBlock = function () {
      var input = this.input;
      var ip = this.ip;
      var output = this.output;
      var op = this.op;
      /** @type {number} */

      var inputLength = input.length;
      /** @type {number} block length */

      var len;
      /** @type {number} number for check block length */

      var nlen;
      /** @type {number} output buffer length */

      var olength = output.length;
      /** @type {number} copy counter */

      var preCopy; // skip buffered header bits

      this.bitsbuf = 0;
      this.bitsbuflen = 0; // len

      if (ip + 1 >= inputLength) {
        throw new Error('invalid uncompressed block header: LEN');
      }

      len = input[ip++] | input[ip++] << 8; // nlen

      if (ip + 1 >= inputLength) {
        throw new Error('invalid uncompressed block header: NLEN');
      }

      nlen = input[ip++] | input[ip++] << 8; // check len & nlen

      if (len === ~nlen) {
        throw new Error('invalid uncompressed block header: length verify');
      } // check size


      if (ip + len > input.length) {
        throw new Error('input buffer is broken');
      } // expand buffer


      switch (this.bufferType) {
        case Zlib.RawInflate.BufferType.BLOCK:
          // pre copy
          while (op + len > output.length) {
            preCopy = olength - op;
            len -= preCopy;

            {
              output.set(input.subarray(ip, ip + preCopy), op);
              op += preCopy;
              ip += preCopy;
            }

            this.op = op;
            output = this.expandBufferBlock();
            op = this.op;
          }

          break;

        case Zlib.RawInflate.BufferType.ADAPTIVE:
          while (op + len > output.length) {
            output = this.expandBufferAdaptive({
              fixRatio: 2
            });
          }

          break;

        default:
          throw new Error('invalid inflate mode');
      } // copy


      {
        output.set(input.subarray(ip, ip + len), op);
        op += len;
        ip += len;
      }

      this.ip = ip;
      this.op = op;
      this.output = output;
    };
    /**
     * parse fixed huffman block.
     */


    Zlib.RawInflate.prototype.parseFixedHuffmanBlock = function () {
      switch (this.bufferType) {
        case Zlib.RawInflate.BufferType.ADAPTIVE:
          this.decodeHuffmanAdaptive(Zlib.RawInflate.FixedLiteralLengthTable, Zlib.RawInflate.FixedDistanceTable);
          break;

        case Zlib.RawInflate.BufferType.BLOCK:
          this.decodeHuffmanBlock(Zlib.RawInflate.FixedLiteralLengthTable, Zlib.RawInflate.FixedDistanceTable);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * parse dynamic huffman block.
     */


    Zlib.RawInflate.prototype.parseDynamicHuffmanBlock = function () {
      /** @type {number} number of literal and length codes. */
      var hlit = this.readBits(5) + 257;
      /** @type {number} number of distance codes. */

      var hdist = this.readBits(5) + 1;
      /** @type {number} number of code lengths. */

      var hclen = this.readBits(4) + 4;
      /** @type {!(Uint8Array|Array.<number>)} code lengths. */

      var codeLengths = new (Uint8Array )(Zlib.RawInflate.Order.length);
      /** @type {!Array} code lengths table. */

      var codeLengthsTable;
      /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */

      var litlenTable;
      /** @type {!(Uint8Array|Array.<number>)} distance code table. */

      var distTable;
      /** @type {!(Uint8Array|Array.<number>)} code length table. */

      var lengthTable;
      /** @type {number} */

      var code;
      /** @type {number} */

      var prev;
      /** @type {number} */

      var repeat;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limit. */

      var il; // decode code lengths

      for (i = 0; i < hclen; ++i) {
        codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);
      }


      codeLengthsTable = buildHuffmanTable(codeLengths);
      lengthTable = new (Uint8Array )(hlit + hdist);

      for (i = 0, il = hlit + hdist; i < il;) {
        code = this.readCodeByTable(codeLengthsTable);

        switch (code) {
          case 16:
            repeat = 3 + this.readBits(2);

            while (repeat--) {
              lengthTable[i++] = prev;
            }

            break;

          case 17:
            repeat = 3 + this.readBits(3);

            while (repeat--) {
              lengthTable[i++] = 0;
            }

            prev = 0;
            break;

          case 18:
            repeat = 11 + this.readBits(7);

            while (repeat--) {
              lengthTable[i++] = 0;
            }

            prev = 0;
            break;

          default:
            lengthTable[i++] = code;
            prev = code;
            break;
        }
      }

      litlenTable = buildHuffmanTable(lengthTable.subarray(0, hlit)) ;
      distTable = buildHuffmanTable(lengthTable.subarray(hlit)) ;

      switch (this.bufferType) {
        case Zlib.RawInflate.BufferType.ADAPTIVE:
          this.decodeHuffmanAdaptive(litlenTable, distTable);
          break;

        case Zlib.RawInflate.BufferType.BLOCK:
          this.decodeHuffmanBlock(litlenTable, distTable);
          break;

        default:
          throw new Error('invalid inflate mode');
      }
    };
    /**
     * decode huffman code
     * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
     * @param {!(Array.<number>|Uint8Array)} dist distination code table.
     */


    Zlib.RawInflate.prototype.decodeHuffmanBlock = function (litlen, dist) {
      var output = this.output;
      var op = this.op;
      this.currentLitlenTable = litlen;
      /** @type {number} output position limit. */

      var olength = output.length - Zlib.RawInflate.MaxCopyLength;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;
      var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;
      var distCodeTable = Zlib.RawInflate.DistCodeTable;
      var distExtraTable = Zlib.RawInflate.DistExtraTable;

      while ((code = this.readCodeByTable(litlen)) !== 256) {
        // literal
        if (code < 256) {
          if (op >= olength) {
            this.op = op;
            output = this.expandBufferBlock();
            op = this.op;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = lengthCodeTable[ti];

        if (lengthExtraTable[ti] > 0) {
          codeLength += this.readBits(lengthExtraTable[ti]);
        } // dist code


        code = this.readCodeByTable(dist);
        codeDist = distCodeTable[code];

        if (distExtraTable[code] > 0) {
          codeDist += this.readBits(distExtraTable[code]);
        } // lz77 decode


        if (op >= olength) {
          this.op = op;
          output = this.expandBufferBlock();
          op = this.op;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
    };
    /**
     * decode huffman code (adaptive)
     * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.
     * @param {!(Array.<number>|Uint8Array)} dist distination code table.
     */


    Zlib.RawInflate.prototype.decodeHuffmanAdaptive = function (litlen, dist) {
      var output = this.output;
      var op = this.op;
      this.currentLitlenTable = litlen;
      /** @type {number} output position limit. */

      var olength = output.length;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;
      var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;
      var distCodeTable = Zlib.RawInflate.DistCodeTable;
      var distExtraTable = Zlib.RawInflate.DistExtraTable;

      while ((code = this.readCodeByTable(litlen)) !== 256) {
        // literal
        if (code < 256) {
          if (op >= olength) {
            output = this.expandBufferAdaptive();
            olength = output.length;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = lengthCodeTable[ti];

        if (lengthExtraTable[ti] > 0) {
          codeLength += this.readBits(lengthExtraTable[ti]);
        } // dist code


        code = this.readCodeByTable(dist);
        codeDist = distCodeTable[code];

        if (distExtraTable[code] > 0) {
          codeDist += this.readBits(distExtraTable[code]);
        } // lz77 decode


        if (op + codeLength > olength) {
          output = this.expandBufferAdaptive();
          olength = output.length;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
    };
    /**
     * expand output buffer.
     * @param {Object=} opt_param option parameters.
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib.RawInflate.prototype.expandBufferBlock = function (opt_param) {
      /** @type {!(Array.<number>|Uint8Array)} store buffer. */
      var buffer = new (Uint8Array )(this.op - Zlib.RawInflate.MaxBackwardLength);
      /** @type {number} backward base point */

      var backward = this.op - Zlib.RawInflate.MaxBackwardLength;
      var output = this.output; // copy to output buffer

      {
        buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));
      }

      this.blocks.push(buffer);
      this.totalpos += buffer.length; // copy to backward buffer

      {
        output.set(output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength));
      }

      this.op = Zlib.RawInflate.MaxBackwardLength;
      return output;
    };
    /**
     * expand output buffer. (adaptive)
     * @param {Object=} opt_param option parameters.
     * @return {!(Array.<number>|Uint8Array)} output buffer pointer.
     */


    Zlib.RawInflate.prototype.expandBufferAdaptive = function (opt_param) {
      /** @type {!(Array.<number>|Uint8Array)} store buffer. */
      var buffer;
      /** @type {number} expantion ratio. */

      var ratio = this.input.length / this.ip + 1 | 0;
      /** @type {number} maximum number of huffman code. */

      var maxHuffCode;
      /** @type {number} new output buffer size. */

      var newSize;
      /** @type {number} max inflate size. */

      var maxInflateSize;
      var input = this.input;
      var output = this.output;

      if (opt_param) {
        if (typeof opt_param.fixRatio === 'number') {
          ratio = opt_param.fixRatio;
        }

        if (typeof opt_param.addRatio === 'number') {
          ratio += opt_param.addRatio;
        }
      } // calculate new buffer size


      if (ratio < 2) {
        maxHuffCode = (input.length - this.ip) / this.currentLitlenTable[2];
        maxInflateSize = maxHuffCode / 2 * 258 | 0;
        newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
      } else {
        newSize = output.length * ratio;
      } // buffer expantion


      {
        buffer = new Uint8Array(newSize);
        buffer.set(output);
      }

      this.output = buffer;
      return this.output;
    };
    /**
     * concat output buffer.
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib.RawInflate.prototype.concatBufferBlock = function () {
      /** @type {number} buffer pointer. */
      var pos = 0;
      /** @type {number} buffer pointer. */

      var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);
      /** @type {!(Array.<number>|Uint8Array)} output block array. */

      var output = this.output;
      /** @type {!Array} blocks array. */

      var blocks = this.blocks;
      /** @type {!(Array.<number>|Uint8Array)} output block array. */

      var block;
      /** @type {!(Array.<number>|Uint8Array)} output buffer. */

      var buffer = new (Uint8Array )(limit);
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limiter. */

      var il;
      /** @type {number} loop counter. */

      var j;
      /** @type {number} loop limiter. */

      var jl; // single buffer

      if (blocks.length === 0) {
        return this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op) ;
      } // copy to buffer


      for (i = 0, il = blocks.length; i < il; ++i) {
        block = blocks[i];

        for (j = 0, jl = block.length; j < jl; ++j) {
          buffer[pos++] = block[j];
        }
      } // current buffer


      for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
        buffer[pos++] = output[i];
      }

      this.blocks = [];
      this.buffer = buffer;
      return this.buffer;
    };
    /**
     * concat output buffer. (dynamic)
     * @return {!(Array.<number>|Uint8Array)} output buffer.
     */


    Zlib.RawInflate.prototype.concatBufferDynamic = function () {
      /** @type {Array.<number>|Uint8Array} output buffer. */
      var buffer;
      var op = this.op;

      {
        if (this.resize) {
          buffer = new Uint8Array(op);
          buffer.set(this.output.subarray(0, op));
        } else {
          buffer = this.output.subarray(0, op);
        }
      }

      this.buffer = buffer;
      return this.buffer;
    };

    var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;
    /**
     * @param {!(Uint8Array|Array.<number>)} input input buffer.
     * @param {number} ip input buffer pointer.
     * @param {number=} opt_buffersize buffer block size.
     * @constructor
     */

    Zlib.RawInflateStream = function (input, ip, opt_buffersize) {
      /** @type {!Array.<(Array|Uint8Array)>} */
      this.blocks = [];
      /** @type {number} block size. */

      this.bufferSize = opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;
      /** @type {!number} total output buffer pointer. */

      this.totalpos = 0;
      /** @type {!number} input buffer pointer. */

      this.ip = ip === void 0 ? 0 : ip;
      /** @type {!number} bit stream reader buffer. */

      this.bitsbuf = 0;
      /** @type {!number} bit stream reader buffer size. */

      this.bitsbuflen = 0;
      /** @type {!(Array|Uint8Array)} input buffer. */

      this.input = new Uint8Array(input) ;
      /** @type {!(Uint8Array|Array)} output buffer. */

      this.output = new (Uint8Array )(this.bufferSize);
      /** @type {!number} output buffer pointer. */

      this.op = 0;
      /** @type {boolean} is final block flag. */

      this.bfinal = false;
      /** @type {number} uncompressed block length. */

      this.blockLength;
      /** @type {boolean} resize flag for memory size optimization. */

      this.resize = false;
      /** @type {Array} */

      this.litlenTable;
      /** @type {Array} */

      this.distTable;
      /** @type {number} */

      this.sp = 0; // stream pointer

      /** @type {Zlib.RawInflateStream.Status} */

      this.status = Zlib.RawInflateStream.Status.INITIALIZED; //
      // backup
      //

      /** @type {!number} */

      this.ip_;
      /** @type {!number} */

      this.bitsbuflen_;
      /** @type {!number} */

      this.bitsbuf_;
    };
    /**
     * @enum {number}
     */


    Zlib.RawInflateStream.BlockType = {
      UNCOMPRESSED: 0,
      FIXED: 1,
      DYNAMIC: 2
    };
    /**
     * @enum {number}
     */

    Zlib.RawInflateStream.Status = {
      INITIALIZED: 0,
      BLOCK_HEADER_START: 1,
      BLOCK_HEADER_END: 2,
      BLOCK_BODY_START: 3,
      BLOCK_BODY_END: 4,
      DECODE_BLOCK_START: 5,
      DECODE_BLOCK_END: 6
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */

    Zlib.RawInflateStream.prototype.decompress = function (newInput, ip) {
      /** @type {boolean} */
      var stop = false;

      if (newInput !== void 0) {
        this.input = newInput;
      }

      if (ip !== void 0) {
        this.ip = ip;
      } // decompress


      while (!stop) {
        switch (this.status) {
          // block header
          case Zlib.RawInflateStream.Status.INITIALIZED:
          case Zlib.RawInflateStream.Status.BLOCK_HEADER_START:
            if (this.readBlockHeader() < 0) {
              stop = true;
            }

            break;
          // block body

          case Zlib.RawInflateStream.Status.BLOCK_HEADER_END:
          /* FALLTHROUGH */

          case Zlib.RawInflateStream.Status.BLOCK_BODY_START:
            switch (this.currentBlockType) {
              case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:
                if (this.readUncompressedBlockHeader() < 0) {
                  stop = true;
                }

                break;

              case Zlib.RawInflateStream.BlockType.FIXED:
                if (this.parseFixedHuffmanBlock() < 0) {
                  stop = true;
                }

                break;

              case Zlib.RawInflateStream.BlockType.DYNAMIC:
                if (this.parseDynamicHuffmanBlock() < 0) {
                  stop = true;
                }

                break;
            }

            break;
          // decode data

          case Zlib.RawInflateStream.Status.BLOCK_BODY_END:
          case Zlib.RawInflateStream.Status.DECODE_BLOCK_START:
            switch (this.currentBlockType) {
              case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:
                if (this.parseUncompressedBlock() < 0) {
                  stop = true;
                }

                break;

              case Zlib.RawInflateStream.BlockType.FIXED:
              /* FALLTHROUGH */

              case Zlib.RawInflateStream.BlockType.DYNAMIC:
                if (this.decodeHuffman() < 0) {
                  stop = true;
                }

                break;
            }

            break;

          case Zlib.RawInflateStream.Status.DECODE_BLOCK_END:
            if (this.bfinal) {
              stop = true;
            } else {
              this.status = Zlib.RawInflateStream.Status.INITIALIZED;
            }

            break;
        }
      }

      return this.concatBuffer();
    };
    /**
     * @const
     * @type {number} max backward length for LZ77.
     */


    Zlib.RawInflateStream.MaxBackwardLength = 32768;
    /**
     * @const
     * @type {number} max copy length for LZ77.
     */

    Zlib.RawInflateStream.MaxCopyLength = 258;
    /**
     * huffman order
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */

    Zlib.RawInflateStream.Order = function (table) {
      return new Uint16Array(table) ;
    }([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    /**
     * huffman length code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib.RawInflateStream.LengthCodeTable = function (table) {
      return new Uint16Array(table) ;
    }([0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b, 0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3, 0x00e3, 0x0102, 0x0102, 0x0102]);
    /**
     * huffman length extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib.RawInflateStream.LengthExtraTable = function (table) {
      return new Uint8Array(table) ;
    }([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0]);
    /**
     * huffman dist code table.
     * @const
     * @type {!(Array.<number>|Uint16Array)}
     */


    Zlib.RawInflateStream.DistCodeTable = function (table) {
      return new Uint16Array(table) ;
    }([0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001]);
    /**
     * huffman dist extra-bits table.
     * @const
     * @type {!(Array.<number>|Uint8Array)}
     */


    Zlib.RawInflateStream.DistExtraTable = function (table) {
      return new Uint8Array(table) ;
    }([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    /**
     * fixed huffman length code table
     * @const
     * @type {!Array}
     */


    Zlib.RawInflateStream.FixedLiteralLengthTable = function (table) {
      return table;
    }(function () {
      var lengths = new (Uint8Array )(288);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
      }

      return buildHuffmanTable(lengths);
    }());
    /**
     * fixed huffman distance code table
     * @const
     * @type {!Array}
     */


    Zlib.RawInflateStream.FixedDistanceTable = function (table) {
      return table;
    }(function () {
      var lengths = new (Uint8Array )(30);
      var i, il;

      for (i = 0, il = lengths.length; i < il; ++i) {
        lengths[i] = 5;
      }

      return buildHuffmanTable(lengths);
    }());
    /**
     * parse deflated block.
     */


    Zlib.RawInflateStream.prototype.readBlockHeader = function () {
      /** @type {number} header */
      var hdr;
      this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_START;
      this.save_();

      if ((hdr = this.readBits(3)) < 0) {
        this.restore_();
        return -1;
      } // BFINAL


      if (hdr & 0x1) {
        this.bfinal = true;
      } // BTYPE


      hdr >>>= 1;

      switch (hdr) {
        case 0:
          // uncompressed
          this.currentBlockType = Zlib.RawInflateStream.BlockType.UNCOMPRESSED;
          break;

        case 1:
          // fixed huffman
          this.currentBlockType = Zlib.RawInflateStream.BlockType.FIXED;
          break;

        case 2:
          // dynamic huffman
          this.currentBlockType = Zlib.RawInflateStream.BlockType.DYNAMIC;
          break;

        default:
          // reserved or other
          throw new Error('unknown BTYPE: ' + hdr);
      }

      this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_END;
    };
    /**
     * read inflate bits
     * @param {number} length bits length.
     * @return {number} read bits.
     */


    Zlib.RawInflateStream.prototype.readBits = function (length) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {number} input and output byte. */

      var octet; // not enough buffer

      while (bitsbuflen < length) {
        // input byte
        if (input.length <= ip) {
          return -1;
        }

        octet = input[ip++]; // concat octet

        bitsbuf |= octet << bitsbuflen;
        bitsbuflen += 8;
      } // output byte


      octet = bitsbuf &
      /* MASK */
      (1 << length) - 1;
      bitsbuf >>>= length;
      bitsbuflen -= length;
      this.bitsbuf = bitsbuf;
      this.bitsbuflen = bitsbuflen;
      this.ip = ip;
      return octet;
    };
    /**
     * read huffman code using table
     * @param {Array} table huffman code table.
     * @return {number} huffman code.
     */


    Zlib.RawInflateStream.prototype.readCodeByTable = function (table) {
      var bitsbuf = this.bitsbuf;
      var bitsbuflen = this.bitsbuflen;
      var input = this.input;
      var ip = this.ip;
      /** @type {!(Array|Uint8Array)} huffman code table */

      var codeTable = table[0];
      /** @type {number} */

      var maxCodeLength = table[1];
      /** @type {number} input byte */

      var octet;
      /** @type {number} code length & code (16bit, 16bit) */

      var codeWithLength;
      /** @type {number} code bits length */

      var codeLength; // not enough buffer

      while (bitsbuflen < maxCodeLength) {
        if (input.length <= ip) {
          return -1;
        }

        octet = input[ip++];
        bitsbuf |= octet << bitsbuflen;
        bitsbuflen += 8;
      } // read max length


      codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
      codeLength = codeWithLength >>> 16;

      if (codeLength > bitsbuflen) {
        throw new Error('invalid code length: ' + codeLength);
      }

      this.bitsbuf = bitsbuf >> codeLength;
      this.bitsbuflen = bitsbuflen - codeLength;
      this.ip = ip;
      return codeWithLength & 0xffff;
    };
    /**
     * read uncompressed block header
     */


    Zlib.RawInflateStream.prototype.readUncompressedBlockHeader = function () {
      /** @type {number} block length */
      var len;
      /** @type {number} number for check block length */

      var nlen;
      var input = this.input;
      var ip = this.ip;
      this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;

      if (ip + 4 >= input.length) {
        return -1;
      }

      len = input[ip++] | input[ip++] << 8;
      nlen = input[ip++] | input[ip++] << 8; // check len & nlen

      if (len === ~nlen) {
        throw new Error('invalid uncompressed block header: length verify');
      } // skip buffered header bits


      this.bitsbuf = 0;
      this.bitsbuflen = 0;
      this.ip = ip;
      this.blockLength = len;
      this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;
    };
    /**
     * parse uncompressed block.
     */


    Zlib.RawInflateStream.prototype.parseUncompressedBlock = function () {
      var input = this.input;
      var ip = this.ip;
      var output = this.output;
      var op = this.op;
      var len = this.blockLength;
      this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START; // copy
      // XXX: とりあえず素直にコピー

      while (len--) {
        if (op === output.length) {
          output = this.expandBuffer({
            fixRatio: 2
          });
        } // not enough input buffer


        if (ip >= input.length) {
          this.ip = ip;
          this.op = op;
          this.blockLength = len + 1; // コピーしてないので戻す

          return -1;
        }

        output[op++] = input[ip++];
      }

      if (len < 0) {
        this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;
      }

      this.ip = ip;
      this.op = op;
      return 0;
    };
    /**
     * parse fixed huffman block.
     */


    Zlib.RawInflateStream.prototype.parseFixedHuffmanBlock = function () {
      this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;
      this.litlenTable = Zlib.RawInflateStream.FixedLiteralLengthTable;
      this.distTable = Zlib.RawInflateStream.FixedDistanceTable;
      this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;
      return 0;
    };
    /**
     * オブジェクトのコンテキストを別のプロパティに退避する.
     * @private
     */


    Zlib.RawInflateStream.prototype.save_ = function () {
      this.ip_ = this.ip;
      this.bitsbuflen_ = this.bitsbuflen;
      this.bitsbuf_ = this.bitsbuf;
    };
    /**
     * 別のプロパティに退避したコンテキストを復元する.
     * @private
     */


    Zlib.RawInflateStream.prototype.restore_ = function () {
      this.ip = this.ip_;
      this.bitsbuflen = this.bitsbuflen_;
      this.bitsbuf = this.bitsbuf_;
    };
    /**
     * parse dynamic huffman block.
     */


    Zlib.RawInflateStream.prototype.parseDynamicHuffmanBlock = function () {
      /** @type {number} number of literal and length codes. */
      var hlit;
      /** @type {number} number of distance codes. */

      var hdist;
      /** @type {number} number of code lengths. */

      var hclen;
      /** @type {!(Uint8Array|Array)} code lengths. */

      var codeLengths = new (Uint8Array )(Zlib.RawInflateStream.Order.length);
      /** @type {!Array} code lengths table. */

      var codeLengthsTable;
      this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;
      this.save_();
      hlit = this.readBits(5) + 257;
      hdist = this.readBits(5) + 1;
      hclen = this.readBits(4) + 4;

      if (hlit < 0 || hdist < 0 || hclen < 0) {
        this.restore_();
        return -1;
      }

      try {
        parseDynamicHuffmanBlockImpl.call(this);
      } catch (e) {
        this.restore_();
        return -1;
      }

      function parseDynamicHuffmanBlockImpl() {
        /** @type {number} */
        var bits;
        var code;
        var prev = 0;
        var repeat;
        /** @type {!(Uint8Array|Array.<number>)} code length table. */

        var lengthTable;
        /** @type {number} loop counter. */

        var i;
        /** @type {number} loop limit. */

        var il; // decode code lengths

        for (i = 0; i < hclen; ++i) {
          if ((bits = this.readBits(3)) < 0) {
            throw new Error('not enough input');
          }

          codeLengths[Zlib.RawInflateStream.Order[i]] = bits;
        } // decode length table


        codeLengthsTable = buildHuffmanTable(codeLengths);
        lengthTable = new (Uint8Array )(hlit + hdist);

        for (i = 0, il = hlit + hdist; i < il;) {
          code = this.readCodeByTable(codeLengthsTable);

          if (code < 0) {
            throw new Error('not enough input');
          }

          switch (code) {
            case 16:
              if ((bits = this.readBits(2)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 3 + bits;

              while (repeat--) {
                lengthTable[i++] = prev;
              }

              break;

            case 17:
              if ((bits = this.readBits(3)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 3 + bits;

              while (repeat--) {
                lengthTable[i++] = 0;
              }

              prev = 0;
              break;

            case 18:
              if ((bits = this.readBits(7)) < 0) {
                throw new Error('not enough input');
              }

              repeat = 11 + bits;

              while (repeat--) {
                lengthTable[i++] = 0;
              }

              prev = 0;
              break;

            default:
              lengthTable[i++] = code;
              prev = code;
              break;
          }
        } // literal and length code
        this.litlenTable = buildHuffmanTable(lengthTable.subarray(0, hlit)) ;
        this.distTable = buildHuffmanTable(lengthTable.subarray(hlit)) ;
      }

      this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;
      return 0;
    };
    /**
     * decode huffman code (dynamic)
     * @return {(number|undefined)} -1 is error.
     */


    Zlib.RawInflateStream.prototype.decodeHuffman = function () {
      var output = this.output;
      var op = this.op;
      /** @type {number} huffman code. */

      var code;
      /** @type {number} table index. */

      var ti;
      /** @type {number} huffman code distination. */

      var codeDist;
      /** @type {number} huffman code length. */

      var codeLength;
      var litlen = this.litlenTable;
      var dist = this.distTable;
      var olength = output.length;
      var bits;
      this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;

      while (true) {
        this.save_();
        code = this.readCodeByTable(litlen);

        if (code < 0) {
          this.op = op;
          this.restore_();
          return -1;
        }

        if (code === 256) {
          break;
        } // literal


        if (code < 256) {
          if (op === olength) {
            output = this.expandBuffer();
            olength = output.length;
          }

          output[op++] = code;
          continue;
        } // length code


        ti = code - 257;
        codeLength = Zlib.RawInflateStream.LengthCodeTable[ti];

        if (Zlib.RawInflateStream.LengthExtraTable[ti] > 0) {
          bits = this.readBits(Zlib.RawInflateStream.LengthExtraTable[ti]);

          if (bits < 0) {
            this.op = op;
            this.restore_();
            return -1;
          }

          codeLength += bits;
        } // dist code


        code = this.readCodeByTable(dist);

        if (code < 0) {
          this.op = op;
          this.restore_();
          return -1;
        }

        codeDist = Zlib.RawInflateStream.DistCodeTable[code];

        if (Zlib.RawInflateStream.DistExtraTable[code] > 0) {
          bits = this.readBits(Zlib.RawInflateStream.DistExtraTable[code]);

          if (bits < 0) {
            this.op = op;
            this.restore_();
            return -1;
          }

          codeDist += bits;
        } // lz77 decode


        if (op + codeLength >= olength) {
          output = this.expandBuffer();
          olength = output.length;
        }

        while (codeLength--) {
          output[op] = output[op++ - codeDist];
        } // break


        if (this.ip === this.input.length) {
          this.op = op;
          return -1;
        }
      }

      while (this.bitsbuflen >= 8) {
        this.bitsbuflen -= 8;
        this.ip--;
      }

      this.op = op;
      this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;
    };
    /**
     * expand output buffer. (dynamic)
     * @param {Object=} opt_param option parameters.
     * @return {!(Array|Uint8Array)} output buffer pointer.
     */


    Zlib.RawInflateStream.prototype.expandBuffer = function (opt_param) {
      /** @type {!(Array|Uint8Array)} store buffer. */
      var buffer;
      /** @type {number} expantion ratio. */

      var ratio = this.input.length / this.ip + 1 | 0;
      /** @type {number} maximum number of huffman code. */

      var maxHuffCode;
      /** @type {number} new output buffer size. */

      var newSize;
      /** @type {number} max inflate size. */

      var maxInflateSize;
      var input = this.input;
      var output = this.output;

      if (opt_param) {
        if (typeof opt_param.fixRatio === 'number') {
          ratio = opt_param.fixRatio;
        }

        if (typeof opt_param.addRatio === 'number') {
          ratio += opt_param.addRatio;
        }
      } // calculate new buffer size


      if (ratio < 2) {
        maxHuffCode = (input.length - this.ip) / this.litlenTable[2];
        maxInflateSize = maxHuffCode / 2 * 258 | 0;
        newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
      } else {
        newSize = output.length * ratio;
      } // buffer expantion


      {
        buffer = new Uint8Array(newSize);
        buffer.set(output);
      }

      this.output = buffer;
      return this.output;
    };
    /**
     * concat output buffer. (dynamic)
     * @return {!(Array|Uint8Array)} output buffer.
     */


    Zlib.RawInflateStream.prototype.concatBuffer = function () {
      /** @type {!(Array|Uint8Array)} output buffer. */
      var buffer;
      /** @type {number} */

      var op = this.op;
      /** @type {Uint8Array} */

      var tmp;

      if (this.resize) {
        {
          buffer = new Uint8Array(this.output.subarray(this.sp, op));
        }
      } else {
        buffer = this.output.subarray(this.sp, op) ;
      }

      this.sp = op; // compaction

      if (op > Zlib.RawInflateStream.MaxBackwardLength + this.bufferSize) {
        this.op = this.sp = Zlib.RawInflateStream.MaxBackwardLength;

        {
          tmp =
          /** @type {Uint8Array} */
          this.output;
          this.output = new Uint8Array(this.bufferSize + Zlib.RawInflateStream.MaxBackwardLength);
          this.output.set(tmp.subarray(op - Zlib.RawInflateStream.MaxBackwardLength, op));
        }
      }

      return buffer;
    };
    /**
     * @constructor
     * @param {!(Uint8Array|Array)} input deflated buffer.
     * @param {Object=} opt_params option parameters.
     *
     * opt_params は以下のプロパティを指定する事ができます。
     *   - index: input buffer の deflate コンテナの開始位置.
     *   - blockSize: バッファのブロックサイズ.
     *   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.
     *   - bufferType: Zlib.Inflate.BufferType の値によってバッファの管理方法を指定する.
     *       Zlib.Inflate.BufferType は Zlib.RawInflate.BufferType のエイリアス.
     */


    Zlib.Inflate = function (input, opt_params) {
      /** @type {number} */

      var cmf;
      /** @type {number} */

      var flg;
      /** @type {!(Uint8Array|Array)} */

      this.input = input;
      /** @type {number} */

      this.ip = 0;
      /** @type {Zlib.RawInflate} */

      this.rawinflate;
      /** @type {(boolean|undefined)} verify flag. */

      this.verify; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (opt_params['index']) {
          this.ip = opt_params['index'];
        }

        if (opt_params['verify']) {
          this.verify = opt_params['verify'];
        }
      } // Compression Method and Flags


      cmf = input[this.ip++];
      flg = input[this.ip++]; // compression method

      switch (cmf & 0x0f) {
        case Zlib.CompressionMethod.DEFLATE:
          this.method = Zlib.CompressionMethod.DEFLATE;
          break;

        default:
          throw new Error('unsupported compression method');
      } // fcheck


      if (((cmf << 8) + flg) % 31 !== 0) {
        throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
      } // fdict (not supported)


      if (flg & 0x20) {
        throw new Error('fdict flag is not supported');
      } // RawInflate


      this.rawinflate = new Zlib.RawInflate(input, {
        'index': this.ip,
        'bufferSize': opt_params['bufferSize'],
        'bufferType': opt_params['bufferType'],
        'resize': opt_params['resize']
      });
    };
    /**
     * @enum {number}
     */


    Zlib.Inflate.BufferType = Zlib.RawInflate.BufferType;
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */

    Zlib.Inflate.prototype.decompress = function () {
      /** @type {!(Array|Uint8Array)} input buffer. */
      var input = this.input;
      /** @type {!(Uint8Array|Array)} inflated buffer. */

      var buffer;
      /** @type {number} adler-32 checksum */

      var adler32;
      buffer = this.rawinflate.decompress();
      this.ip = this.rawinflate.ip; // verify adler-32

      if (this.verify) {
        adler32 = (input[this.ip++] << 24 | input[this.ip++] << 16 | input[this.ip++] << 8 | input[this.ip++]) >>> 0;

        if (adler32 !== Zlib.Adler32(buffer)) {
          throw new Error('invalid adler-32 checksum');
        }
      }

      return buffer;
    };
    /* vim:set expandtab ts=2 sw=2 tw=80: */

    /**
     * @param {!(Uint8Array|Array)} input deflated buffer.
     * @constructor
     */


    Zlib.InflateStream = function (input) {
      /** @type {!(Uint8Array|Array)} */
      this.input = input === void 0 ? new (Uint8Array )() : input;
      /** @type {number} */

      this.ip = 0;
      /** @type {Zlib.RawInflateStream} */

      this.rawinflate = new Zlib.RawInflateStream(this.input, this.ip);
      /** @type {Zlib.CompressionMethod} */

      this.method;
      /** @type {!(Array|Uint8Array)} */

      this.output = this.rawinflate.output;
    };
    /**
     * decompress.
     * @return {!(Uint8Array|Array)} inflated buffer.
     */


    Zlib.InflateStream.prototype.decompress = function (input) {
      /** @type {!(Uint8Array|Array)} inflated buffer. */
      var buffer;
      // XXX Array, Uint8Array のチェックを行うか確認する

      if (input !== void 0) {
        {
          var tmp = new Uint8Array(this.input.length + input.length);
          tmp.set(this.input, 0);
          tmp.set(input, this.input.length);
          this.input = tmp;
        }
      }

      if (this.method === void 0) {
        if (this.readHeader() < 0) {
          return new (Uint8Array )();
        }
      }

      buffer = this.rawinflate.decompress(this.input, this.ip);

      if (this.rawinflate.ip !== 0) {
        this.input = this.input.subarray(this.rawinflate.ip) ;
        this.ip = 0;
      } // verify adler-32

      /*
      if (this.verify) {
        adler32 =
          input[this.ip++] << 24 | input[this.ip++] << 16 |
          input[this.ip++] << 8 | input[this.ip++];
         if (adler32 !== Zlib.Adler32(buffer)) {
          throw new Error('invalid adler-32 checksum');
        }
      }
      */


      return buffer;
    };

    Zlib.InflateStream.prototype.readHeader = function () {
      var ip = this.ip;
      var input = this.input; // Compression Method and Flags

      var cmf = input[ip++];
      var flg = input[ip++];

      if (cmf === void 0 || flg === void 0) {
        return -1;
      } // compression method


      switch (cmf & 0x0f) {
        case Zlib.CompressionMethod.DEFLATE:
          this.method = Zlib.CompressionMethod.DEFLATE;
          break;

        default:
          throw new Error('unsupported compression method');
      } // fcheck


      if (((cmf << 8) + flg) % 31 !== 0) {
        throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);
      } // fdict (not supported)


      if (flg & 0x20) {
        throw new Error('fdict flag is not supported');
      }

      this.ip = ip;
    };
    /**
     * @fileoverview GZIP (RFC1952) 展開コンテナ実装.
     */

    /**
     * @constructor
     * @param {!(Array|Uint8Array)} input input buffer.
     * @param {Object=} opt_params option parameters.
     */


    Zlib.Gunzip = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */
      this.input = input;
      /** @type {number} input buffer pointer. */

      this.ip = 0;
      /** @type {Array.<Zlib.GunzipMember>} */

      this.member = [];
      /** @type {boolean} */

      this.decompressed = false;
    };
    /**
     * @return {Array.<Zlib.GunzipMember>}
     */


    Zlib.Gunzip.prototype.getMembers = function () {
      if (!this.decompressed) {
        this.decompress();
      }

      return this.member.slice();
    };
    /**
     * inflate gzip data.
     * @return {!(Array.<number>|Uint8Array)} inflated buffer.
     */


    Zlib.Gunzip.prototype.decompress = function () {
      /** @type {number} input length. */
      var il = this.input.length;

      while (this.ip < il) {
        this.decodeMember();
      }

      this.decompressed = true;
      return this.concatMember();
    };
    /**
     * decode gzip member.
     */


    Zlib.Gunzip.prototype.decodeMember = function () {
      /** @type {Zlib.GunzipMember} */
      var member = new Zlib.GunzipMember();
      /** @type {number} */

      var isize;
      /** @type {Zlib.RawInflate} RawInflate implementation. */

      var rawinflate;
      /** @type {!(Array.<number>|Uint8Array)} inflated data. */

      var inflated;
      /** @type {number} inflate size */

      var inflen;
      /** @type {number} character code */

      var c;
      /** @type {number} character index in string. */

      var ci;
      /** @type {Array.<string>} character array. */

      var str;
      /** @type {number} modification time. */

      var mtime;
      /** @type {number} */

      var crc32;
      var input = this.input;
      var ip = this.ip;
      member.id1 = input[ip++];
      member.id2 = input[ip++]; // check signature

      if (member.id1 !== 0x1f || member.id2 !== 0x8b) {
        throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);
      } // check compression method


      member.cm = input[ip++];

      switch (member.cm) {
        case 8:
          /* XXX: use Zlib const */
          break;

        default:
          throw new Error('unknown compression method: ' + member.cm);
      } // flags


      member.flg = input[ip++]; // modification time

      mtime = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24;
      member.mtime = new Date(mtime * 1000); // extra flags

      member.xfl = input[ip++]; // operating system

      member.os = input[ip++]; // extra

      if ((member.flg & Zlib.Gzip.FlagsMask.FEXTRA) > 0) {
        member.xlen = input[ip++] | input[ip++] << 8;
        ip = this.decodeSubField(ip, member.xlen);
      } // fname


      if ((member.flg & Zlib.Gzip.FlagsMask.FNAME) > 0) {
        for (str = [], ci = 0; (c = input[ip++]) > 0;) {
          str[ci++] = String.fromCharCode(c);
        }

        member.name = str.join('');
      } // fcomment


      if ((member.flg & Zlib.Gzip.FlagsMask.FCOMMENT) > 0) {
        for (str = [], ci = 0; (c = input[ip++]) > 0;) {
          str[ci++] = String.fromCharCode(c);
        }

        member.comment = str.join('');
      } // fhcrc


      if ((member.flg & Zlib.Gzip.FlagsMask.FHCRC) > 0) {
        member.crc16 = Zlib.CRC32.calc(input, 0, ip) & 0xffff;

        if (member.crc16 !== (input[ip++] | input[ip++] << 8)) {
          throw new Error('invalid header crc16');
        }
      } // isize を事前に取得すると展開後のサイズが分かるため、
      // inflate処理のバッファサイズが事前に分かり、高速になる


      isize = input[input.length - 4] | input[input.length - 3] << 8 | input[input.length - 2] << 16 | input[input.length - 1] << 24; // isize の妥当性チェック
      // ハフマン符号では最小 2-bit のため、最大で 1/4 になる
      // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、
      // 1/128 になるとする
      // ここから入力バッファの残りが isize の 512 倍以上だったら
      // サイズ指定のバッファ確保は行わない事とする

      if (input.length - ip -
      /* CRC-32 */
      4 -
      /* ISIZE */
      4 < isize * 512) {
        inflen = isize;
      } // compressed block


      rawinflate = new Zlib.RawInflate(input, {
        'index': ip,
        'bufferSize': inflen
      });
      member.data = inflated = rawinflate.decompress();
      ip = rawinflate.ip; // crc32

      member.crc32 = crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;

      if (Zlib.CRC32.calc(inflated) !== crc32) {
        throw new Error('invalid CRC-32 checksum: 0x' + Zlib.CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));
      } // input size


      member.isize = isize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;

      if ((inflated.length & 0xffffffff) !== isize) {
        throw new Error('invalid input size: ' + (inflated.length & 0xffffffff) + ' / ' + isize);
      }

      this.member.push(member);
      this.ip = ip;
    };
    /**
     * サブフィールドのデコード
     * XXX: 現在は何もせずスキップする
     */


    Zlib.Gunzip.prototype.decodeSubField = function (ip, length) {
      return ip + length;
    };
    /**
     * @return {!(Array.<number>|Uint8Array)}
     */


    Zlib.Gunzip.prototype.concatMember = function () {
      /** @type {Array.<Zlib.GunzipMember>} */
      var member = this.member;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {number} */

      var p = 0;
      /** @type {number} */

      var size = 0;
      /** @type {!(Array.<number>|Uint8Array)} */

      var buffer;

      for (i = 0, il = member.length; i < il; ++i) {
        size += member[i].data.length;
      }

      {
        buffer = new Uint8Array(size);

        for (i = 0; i < il; ++i) {
          buffer.set(member[i].data, p);
          p += member[i].data.length;
        }
      }

      return buffer;
    };
    /**
     * @constructor
     */


    Zlib.GunzipMember = function () {
      /** @type {number} signature first byte. */
      this.id1;
      /** @type {number} signature second byte. */

      this.id2;
      /** @type {number} compression method. */

      this.cm;
      /** @type {number} flags. */

      this.flg;
      /** @type {Date} modification time. */

      this.mtime;
      /** @type {number} extra flags. */

      this.xfl;
      /** @type {number} operating system number. */

      this.os;
      /** @type {number} CRC-16 value for FHCRC flag. */

      this.crc16;
      /** @type {number} extra length. */

      this.xlen;
      /** @type {number} CRC-32 value for verification. */

      this.crc32;
      /** @type {number} input size modulo 32 value. */

      this.isize;
      /** @type {string} filename. */

      this.name;
      /** @type {string} comment. */

      this.comment;
      /** @type {!(Uint8Array|Array.<number>)} */

      this.data;
    };

    Zlib.GunzipMember.prototype.getName = function () {
      return this.name;
    };

    Zlib.GunzipMember.prototype.getData = function () {
      return this.data;
    };

    Zlib.GunzipMember.prototype.getMtime = function () {
      return this.mtime;
    };
    /**
     * @fileoverview GZIP (RFC1952) 実装.
     */

    /**
     * @constructor
     * @param {!(Array|Uint8Array)} input input buffer.
     * @param {Object=} opt_params option parameters.
     */


    Zlib.Gzip = function (input, opt_params) {
      /** @type {!(Array.<number>|Uint8Array)} input buffer. */
      this.input = input;
      /** @type {number} input buffer pointer. */

      this.ip = 0;
      /** @type {!(Array.<number>|Uint8Array)} output buffer. */

      this.output;
      /** @type {number} output buffer. */

      this.op = 0;
      /** @type {!Object} flags option flags. */

      this.flags = {};
      /** @type {!string} filename. */

      this.filename;
      /** @type {!string} comment. */

      this.comment;
      /** @type {!Object} deflate options. */

      this.deflateOptions; // option parameters

      if (opt_params) {
        if (opt_params['flags']) {
          this.flags = opt_params['flags'];
        }

        if (typeof opt_params['filename'] === 'string') {
          this.filename = opt_params['filename'];
        }

        if (typeof opt_params['comment'] === 'string') {
          this.comment = opt_params['comment'];
        }

        if (opt_params['deflateOptions']) {
          this.deflateOptions = opt_params['deflateOptions'];
        }
      }

      if (!this.deflateOptions) {
        this.deflateOptions = {};
      }
    };
    /**
     * @type {number}
     * @const
     */


    Zlib.Gzip.DefaultBufferSize = 0x8000;
    /**
     * encode gzip members.
     * @return {!(Array|Uint8Array)} gzip binary array.
     */

    Zlib.Gzip.prototype.compress = function () {
      /** @type {number} flags. */
      var flg;
      /** @type {number} modification time. */

      var mtime;
      /** @type {number} CRC-16 value for FHCRC flag. */

      var crc16;
      /** @type {number} CRC-32 value for verification. */

      var crc32;
      /** @type {!Zlib.RawDeflate} raw deflate object. */

      var rawdeflate;
      /** @type {number} character code */

      var c;
      /** @type {number} loop counter. */

      var i;
      /** @type {number} loop limiter. */

      var il;
      /** @type {!(Array|Uint8Array)} output buffer. */

      var output = new (Uint8Array )(Zlib.Gzip.DefaultBufferSize);
      /** @type {number} output buffer pointer. */

      var op = 0;
      var input = this.input;
      var ip = this.ip;
      var filename = this.filename;
      var comment = this.comment; // check signature

      output[op++] = 0x1f;
      output[op++] = 0x8b; // check compression method

      output[op++] = 8;
      /* XXX: use Zlib const */
      // flags

      flg = 0;
      if (this.flags['fname']) flg |= Zlib.Gzip.FlagsMask.FNAME;
      if (this.flags['fcomment']) flg |= Zlib.Gzip.FlagsMask.FCOMMENT;
      if (this.flags['fhcrc']) flg |= Zlib.Gzip.FlagsMask.FHCRC; // XXX: FTEXT
      // XXX: FEXTRA

      output[op++] = flg; // modification time

      mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;
      output[op++] = mtime & 0xff;
      output[op++] = mtime >>> 8 & 0xff;
      output[op++] = mtime >>> 16 & 0xff;
      output[op++] = mtime >>> 24 & 0xff; // extra flags

      output[op++] = 0; // operating system

      output[op++] = Zlib.Gzip.OperatingSystem.UNKNOWN; // extra

      /* NOP */
      // fname

      if (this.flags['fname'] !== void 0) {
        for (i = 0, il = filename.length; i < il; ++i) {
          c = filename.charCodeAt(i);

          if (c > 0xff) {
            output[op++] = c >>> 8 & 0xff;
          }

          output[op++] = c & 0xff;
        }

        output[op++] = 0; // null termination
      } // fcomment


      if (this.flags['comment']) {
        for (i = 0, il = comment.length; i < il; ++i) {
          c = comment.charCodeAt(i);

          if (c > 0xff) {
            output[op++] = c >>> 8 & 0xff;
          }

          output[op++] = c & 0xff;
        }

        output[op++] = 0; // null termination
      } // fhcrc


      if (this.flags['fhcrc']) {
        crc16 = Zlib.CRC32.calc(output, 0, op) & 0xffff;
        output[op++] = crc16 & 0xff;
        output[op++] = crc16 >>> 8 & 0xff;
      } // add compress option


      this.deflateOptions['outputBuffer'] = output;
      this.deflateOptions['outputIndex'] = op; // compress

      rawdeflate = new Zlib.RawDeflate(input, this.deflateOptions);
      output = rawdeflate.compress();
      op = rawdeflate.op; // expand buffer

      {
        if (op + 8 > output.buffer.byteLength) {
          this.output = new Uint8Array(op + 8);
          this.output.set(new Uint8Array(output.buffer));
          output = this.output;
        } else {
          output = new Uint8Array(output.buffer);
        }
      } // crc32


      crc32 = Zlib.CRC32.calc(input);
      output[op++] = crc32 & 0xff;
      output[op++] = crc32 >>> 8 & 0xff;
      output[op++] = crc32 >>> 16 & 0xff;
      output[op++] = crc32 >>> 24 & 0xff; // input size

      il = input.length;
      output[op++] = il & 0xff;
      output[op++] = il >>> 8 & 0xff;
      output[op++] = il >>> 16 & 0xff;
      output[op++] = il >>> 24 & 0xff;
      this.ip = ip;

      if (op < output.length) {
        this.output = output = output.subarray(0, op);
      }

      return output;
    };
    /** @enum {number} */


    Zlib.Gzip.OperatingSystem = {
      FAT: 0,
      AMIGA: 1,
      VMS: 2,
      UNIX: 3,
      VM_CMS: 4,
      ATARI_TOS: 5,
      HPFS: 6,
      MACINTOSH: 7,
      Z_SYSTEM: 8,
      CP_M: 9,
      TOPS_20: 10,
      NTFS: 11,
      QDOS: 12,
      ACORN_RISCOS: 13,
      UNKNOWN: 255
    };
    /** @enum {number} */

    Zlib.Gzip.FlagsMask = {
      FTEXT: 0x01,
      FHCRC: 0x02,
      FEXTRA: 0x04,
      FNAME: 0x08,
      FCOMMENT: 0x10
    };
    /**
     * @fileoverview Heap Sort 実装. ハフマン符号化で使用する.
     */

    /**
     * カスタムハフマン符号で使用するヒープ実装
     * @param {number} length ヒープサイズ.
     * @constructor
     */

    Zlib.Heap = function (length) {
      this.buffer = new (Uint16Array )(length * 2);
      this.length = 0;
    };
    /**
     * 親ノードの index 取得
     * @param {number} index 子ノードの index.
     * @return {number} 親ノードの index.
     *
     */


    Zlib.Heap.prototype.getParent = function (index) {
      return ((index - 2) / 4 | 0) * 2;
    };
    /**
     * 子ノードの index 取得
     * @param {number} index 親ノードの index.
     * @return {number} 子ノードの index.
     */


    Zlib.Heap.prototype.getChild = function (index) {
      return 2 * index + 2;
    };
    /**
     * Heap に値を追加する
     * @param {number} index キー index.
     * @param {number} value 値.
     * @return {number} 現在のヒープ長.
     */


    Zlib.Heap.prototype.push = function (index, value) {
      var current,
          parent,
          heap = this.buffer,
          swap;
      current = this.length;
      heap[this.length++] = value;
      heap[this.length++] = index; // ルートノードにたどり着くまで入れ替えを試みる

      while (current > 0) {
        parent = this.getParent(current); // 親ノードと比較して親の方が小さければ入れ替える

        if (heap[current] > heap[parent]) {
          swap = heap[current];
          heap[current] = heap[parent];
          heap[parent] = swap;
          swap = heap[current + 1];
          heap[current + 1] = heap[parent + 1];
          heap[parent + 1] = swap;
          current = parent; // 入れ替えが必要なくなったらそこで抜ける
        } else {
          break;
        }
      }

      return this.length;
    };
    /**
     * Heapから一番大きい値を返す
     * @return {{index: number, value: number, length: number}} {index: キーindex,
     *     value: 値, length: ヒープ長} の Object.
     */


    Zlib.Heap.prototype.pop = function () {
      var index,
          value,
          heap = this.buffer,
          swap,
          current,
          parent;
      value = heap[0];
      index = heap[1]; // 後ろから値を取る

      this.length -= 2;
      heap[0] = heap[this.length];
      heap[1] = heap[this.length + 1];
      parent = 0; // ルートノードから下がっていく

      while (true) {
        current = this.getChild(parent); // 範囲チェック

        if (current >= this.length) {
          break;
        } // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択


        if (current + 2 < this.length && heap[current + 2] > heap[current]) {
          current += 2;
        } // 親ノードと比較して親の方が小さい場合は入れ替える


        if (heap[current] > heap[parent]) {
          swap = heap[parent];
          heap[parent] = heap[current];
          heap[current] = swap;
          swap = heap[parent + 1];
          heap[parent + 1] = heap[current + 1];
          heap[current + 1] = swap;
        } else {
          break;
        }

        parent = current;
      }

      return {
        index: index,
        value: value,
        length: this.length
      };
    };
    /* vim:set expandtab ts=2 sw=2 tw=80: */

    /**
     * @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.
     */

    /**
     * Raw Deflate 実装
     *
     * @constructor
     * @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.
     * @param {Object=} opt_params option parameters.
     *
     * typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に
     * 変換されます.
     * 別のオブジェクトになるため出力バッファを参照している変数などは
     * 更新する必要があります.
     */


    Zlib.RawDeflate = function (input, opt_params) {
      /** @type {Zlib.RawDeflate.CompressionType} */
      this.compressionType = Zlib.RawDeflate.CompressionType.DYNAMIC;
      /** @type {number} */

      this.lazy = 0;
      /** @type {!(Array.<number>|Uint32Array)} */

      this.freqsLitLen;
      /** @type {!(Array.<number>|Uint32Array)} */

      this.freqsDist;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.input = input instanceof Array ? new Uint8Array(input) : input;
      /** @type {!(Array.<number>|Uint8Array)} output output buffer. */

      this.output;
      /** @type {number} pos output buffer position. */

      this.op = 0; // option parameters

      if (opt_params) {
        if (opt_params['lazy']) {
          this.lazy = opt_params['lazy'];
        }

        if (typeof opt_params['compressionType'] === 'number') {
          this.compressionType = opt_params['compressionType'];
        }

        if (opt_params['outputBuffer']) {
          this.output = opt_params['outputBuffer'] instanceof Array ? new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];
        }

        if (typeof opt_params['outputIndex'] === 'number') {
          this.op = opt_params['outputIndex'];
        }
      }

      if (!this.output) {
        this.output = new (Uint8Array )(0x8000);
      }
    };
    /**
     * @enum {number}
     */


    Zlib.RawDeflate.CompressionType = {
      NONE: 0,
      FIXED: 1,
      DYNAMIC: 2,
      RESERVED: 3
    };
    /**
     * LZ77 の最小マッチ長
     * @const
     * @type {number}
     */

    Zlib.RawDeflate.Lz77MinLength = 3;
    /**
     * LZ77 の最大マッチ長
     * @const
     * @type {number}
     */

    Zlib.RawDeflate.Lz77MaxLength = 258;
    /**
     * LZ77 のウィンドウサイズ
     * @const
     * @type {number}
     */

    Zlib.RawDeflate.WindowSize = 0x8000;
    /**
     * 最長の符号長
     * @const
     * @type {number}
     */

    Zlib.RawDeflate.MaxCodeLength = 16;
    /**
     * ハフマン符号の最大数値
     * @const
     * @type {number}
     */

    Zlib.RawDeflate.HUFMAX = 286;
    /**
     * 固定ハフマン符号の符号化テーブル
     * @const
     * @type {Array.<Array.<number, number>>}
     */

    Zlib.RawDeflate.FixedHuffmanTable = function () {
      var table = [],
          i;

      for (i = 0; i < 288; i++) {
        switch (true) {
          case i <= 143:
            table.push([i + 0x030, 8]);
            break;

          case i <= 255:
            table.push([i - 144 + 0x190, 9]);
            break;

          case i <= 279:
            table.push([i - 256 + 0x000, 7]);
            break;

          case i <= 287:
            table.push([i - 280 + 0x0C0, 8]);
            break;

          default:
            throw 'invalid literal: ' + i;
        }
      }

      return table;
    }();
    /**
     * DEFLATE ブロックの作成
     * @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.
     */


    Zlib.RawDeflate.prototype.compress = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var blockArray;
      /** @type {number} */

      var position;
      /** @type {number} */

      var length;
      var input = this.input; // compression

      switch (this.compressionType) {
        case Zlib.RawDeflate.CompressionType.NONE:
          // each 65535-Byte (length header: 16-bit)
          for (position = 0, length = input.length; position < length;) {
            blockArray = input.subarray(position, position + 0xffff) ;
            position += blockArray.length;
            this.makeNocompressBlock(blockArray, position === length);
          }

          break;

        case Zlib.RawDeflate.CompressionType.FIXED:
          this.output = this.makeFixedHuffmanBlock(input, true);
          this.op = this.output.length;
          break;

        case Zlib.RawDeflate.CompressionType.DYNAMIC:
          this.output = this.makeDynamicHuffmanBlock(input, true);
          this.op = this.output.length;
          break;

        default:
          throw 'invalid compression type';
      }

      return this.output;
    };
    /**
     * 非圧縮ブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.
     */


    Zlib.RawDeflate.prototype.makeNocompressBlock = function (blockArray, isFinalBlock) {
      /** @type {number} */
      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {number} */

      var len;
      /** @type {number} */

      var nlen;
      var output = this.output;
      var op = this.op; // expand buffer

      {
        output = new Uint8Array(this.output.buffer);

        while (output.length <= op + blockArray.length + 5) {
          output = new Uint8Array(output.length << 1);
        }

        output.set(this.output);
      } // header


      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib.RawDeflate.CompressionType.NONE;
      output[op++] = bfinal | btype << 1; // length

      len = blockArray.length;
      nlen = ~len + 0x10000 & 0xffff;
      output[op++] = len & 0xff;
      output[op++] = len >>> 8 & 0xff;
      output[op++] = nlen & 0xff;
      output[op++] = nlen >>> 8 & 0xff; // copy buffer

      {
        output.set(blockArray, op);
        op += blockArray.length;
        output = output.subarray(0, op);
      }

      this.op = op;
      this.output = output;
      return output;
    };
    /**
     * 固定ハフマンブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.
     */


    Zlib.RawDeflate.prototype.makeFixedHuffmanBlock = function (blockArray, isFinalBlock) {
      /** @type {Zlib.BitStream} */
      var stream = new Zlib.BitStream(new Uint8Array(this.output.buffer) , this.op);
      /** @type {number} */

      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {!(Array.<number>|Uint16Array)} */

      var data; // header

      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib.RawDeflate.CompressionType.FIXED;
      stream.writeBits(bfinal, 1, true);
      stream.writeBits(btype, 2, true);
      data = this.lz77(blockArray);
      this.fixedHuffman(data, stream);
      return stream.finish();
    };
    /**
     * 動的ハフマンブロックの作成
     * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.
     * @param {!boolean} isFinalBlock 最後のブロックならばtrue.
     * @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.
     */


    Zlib.RawDeflate.prototype.makeDynamicHuffmanBlock = function (blockArray, isFinalBlock) {
      /** @type {Zlib.BitStream} */
      var stream = new Zlib.BitStream(new Uint8Array(this.output.buffer) , this.op);
      /** @type {number} */

      var bfinal;
      /** @type {Zlib.RawDeflate.CompressionType} */

      var btype;
      /** @type {!(Array.<number>|Uint16Array)} */

      var data;
      /** @type {number} */

      var hlit;
      /** @type {number} */

      var hdist;
      /** @type {number} */

      var hclen;
      /** @const @type {Array.<number>} */

      var hclenOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      /** @type {!(Array.<number>|Uint8Array)} */

      var litLenLengths;
      /** @type {!(Array.<number>|Uint16Array)} */

      var litLenCodes;
      /** @type {!(Array.<number>|Uint8Array)} */

      var distLengths;
      /** @type {!(Array.<number>|Uint16Array)} */

      var distCodes;
      /** @type {{
       *   codes: !(Array.<number>|Uint32Array),
       *   freqs: !(Array.<number>|Uint8Array)
       * }} */

      var treeSymbols;
      /** @type {!(Array.<number>|Uint8Array)} */

      var treeLengths;
      /** @type {Array} */

      var transLengths = new Array(19);
      /** @type {!(Array.<number>|Uint16Array)} */

      var treeCodes;
      /** @type {number} */

      var code;
      /** @type {number} */

      var bitlen;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il; // header

      bfinal = isFinalBlock ? 1 : 0;
      btype = Zlib.RawDeflate.CompressionType.DYNAMIC;
      stream.writeBits(bfinal, 1, true);
      stream.writeBits(btype, 2, true);
      data = this.lz77(blockArray); // リテラル・長さ, 距離のハフマン符号と符号長の算出

      litLenLengths = this.getLengths_(this.freqsLitLen, 15);
      litLenCodes = this.getCodesFromLengths_(litLenLengths);
      distLengths = this.getLengths_(this.freqsDist, 7);
      distCodes = this.getCodesFromLengths_(distLengths); // HLIT, HDIST の決定

      for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}

      for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {} // HCLEN


      treeSymbols = this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
      treeLengths = this.getLengths_(treeSymbols.freqs, 7);

      for (i = 0; i < 19; i++) {
        transLengths[i] = treeLengths[hclenOrder[i]];
      }

      for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}

      treeCodes = this.getCodesFromLengths_(treeLengths); // 出力

      stream.writeBits(hlit - 257, 5, true);
      stream.writeBits(hdist - 1, 5, true);
      stream.writeBits(hclen - 4, 4, true);

      for (i = 0; i < hclen; i++) {
        stream.writeBits(transLengths[i], 3, true);
      } // ツリーの出力


      for (i = 0, il = treeSymbols.codes.length; i < il; i++) {
        code = treeSymbols.codes[i];
        stream.writeBits(treeCodes[code], treeLengths[code], true); // extra bits

        if (code >= 16) {
          i++;

          switch (code) {
            case 16:
              bitlen = 2;
              break;

            case 17:
              bitlen = 3;
              break;

            case 18:
              bitlen = 7;
              break;

            default:
              throw 'invalid code: ' + code;
          }

          stream.writeBits(treeSymbols.codes[i], bitlen, true);
        }
      }

      this.dynamicHuffman(data, [litLenCodes, litLenLengths], [distCodes, distLengths], stream);
      return stream.finish();
    };
    /**
     * 動的ハフマン符号化(カスタムハフマンテーブル)
     * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
     * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
     * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
     */


    Zlib.RawDeflate.prototype.dynamicHuffman = function (dataArray, litLen, dist, stream) {
      /** @type {number} */
      var index;
      /** @type {number} */

      var length;
      /** @type {number} */

      var literal;
      /** @type {number} */

      var code;
      /** @type {number} */

      var litLenCodes;
      /** @type {number} */

      var litLenLengths;
      /** @type {number} */

      var distCodes;
      /** @type {number} */

      var distLengths;
      litLenCodes = litLen[0];
      litLenLengths = litLen[1];
      distCodes = dist[0];
      distLengths = dist[1]; // 符号を BitStream に書き込んでいく

      for (index = 0, length = dataArray.length; index < length; ++index) {
        literal = dataArray[index]; // literal or length

        stream.writeBits(litLenCodes[literal], litLenLengths[literal], true); // 長さ・距離符号

        if (literal > 256) {
          // length extra
          stream.writeBits(dataArray[++index], dataArray[++index], true); // distance

          code = dataArray[++index];
          stream.writeBits(distCodes[code], distLengths[code], true); // distance extra

          stream.writeBits(dataArray[++index], dataArray[++index], true); // 終端
        } else if (literal === 256) {
          break;
        }
      }

      return stream;
    };
    /**
     * 固定ハフマン符号化
     * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.
     * @param {!Zlib.BitStream} stream 書き込み用ビットストリーム.
     * @return {!Zlib.BitStream} ハフマン符号化済みビットストリームオブジェクト.
     */


    Zlib.RawDeflate.prototype.fixedHuffman = function (dataArray, stream) {
      /** @type {number} */
      var index;
      /** @type {number} */

      var length;
      /** @type {number} */

      var literal; // 符号を BitStream に書き込んでいく

      for (index = 0, length = dataArray.length; index < length; index++) {
        literal = dataArray[index]; // 符号の書き込み

        Zlib.BitStream.prototype.writeBits.apply(stream, Zlib.RawDeflate.FixedHuffmanTable[literal]); // 長さ・距離符号

        if (literal > 0x100) {
          // length extra
          stream.writeBits(dataArray[++index], dataArray[++index], true); // distance

          stream.writeBits(dataArray[++index], 5); // distance extra

          stream.writeBits(dataArray[++index], dataArray[++index], true); // 終端
        } else if (literal === 0x100) {
          break;
        }
      }

      return stream;
    };
    /**
     * マッチ情報
     * @param {!number} length マッチした長さ.
     * @param {!number} backwardDistance マッチ位置との距離.
     * @constructor
     */


    Zlib.RawDeflate.Lz77Match = function (length, backwardDistance) {
      /** @type {number} match length. */
      this.length = length;
      /** @type {number} backward distance. */

      this.backwardDistance = backwardDistance;
    };
    /**
     * 長さ符号テーブル.
     * [コード, 拡張ビット, 拡張ビット長] の配列となっている.
     * @const
     * @type {!(Array.<number>|Uint32Array)}
     */


    Zlib.RawDeflate.Lz77Match.LengthCodeTable = function (table) {
      return new Uint32Array(table) ;
    }(function () {
      /** @type {!Array} */
      var table = [];
      /** @type {number} */

      var i;
      /** @type {!Array.<number>} */

      var c;

      for (i = 3; i <= 258; i++) {
        c = code(i);
        table[i] = c[2] << 24 | c[1] << 16 | c[0];
      }
      /**
       * @param {number} length lz77 length.
       * @return {!Array.<number>} lz77 codes.
       */


      function code(length) {
        switch (true) {
          case length === 3:
            return [257, length - 3, 0];

          case length === 4:
            return [258, length - 4, 0];

          case length === 5:
            return [259, length - 5, 0];

          case length === 6:
            return [260, length - 6, 0];

          case length === 7:
            return [261, length - 7, 0];

          case length === 8:
            return [262, length - 8, 0];

          case length === 9:
            return [263, length - 9, 0];

          case length === 10:
            return [264, length - 10, 0];

          case length <= 12:
            return [265, length - 11, 1];

          case length <= 14:
            return [266, length - 13, 1];

          case length <= 16:
            return [267, length - 15, 1];

          case length <= 18:
            return [268, length - 17, 1];

          case length <= 22:
            return [269, length - 19, 2];

          case length <= 26:
            return [270, length - 23, 2];

          case length <= 30:
            return [271, length - 27, 2];

          case length <= 34:
            return [272, length - 31, 2];

          case length <= 42:
            return [273, length - 35, 3];

          case length <= 50:
            return [274, length - 43, 3];

          case length <= 58:
            return [275, length - 51, 3];

          case length <= 66:
            return [276, length - 59, 3];

          case length <= 82:
            return [277, length - 67, 4];

          case length <= 98:
            return [278, length - 83, 4];

          case length <= 114:
            return [279, length - 99, 4];

          case length <= 130:
            return [280, length - 115, 4];

          case length <= 162:
            return [281, length - 131, 5];

          case length <= 194:
            return [282, length - 163, 5];

          case length <= 226:
            return [283, length - 195, 5];

          case length <= 257:
            return [284, length - 227, 5];

          case length === 258:
            return [285, length - 258, 0];

          default:
            throw 'invalid length: ' + length;
        }
      }

      return table;
    }());
    /**
     * 距離符号テーブル
     * @param {!number} dist 距離.
     * @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.
     * @private
     */


    Zlib.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function (dist) {
      /** @type {!Array.<number>} distance code table. */
      var r;

      switch (true) {
        case dist === 1:
          r = [0, dist - 1, 0];
          break;

        case dist === 2:
          r = [1, dist - 2, 0];
          break;

        case dist === 3:
          r = [2, dist - 3, 0];
          break;

        case dist === 4:
          r = [3, dist - 4, 0];
          break;

        case dist <= 6:
          r = [4, dist - 5, 1];
          break;

        case dist <= 8:
          r = [5, dist - 7, 1];
          break;

        case dist <= 12:
          r = [6, dist - 9, 2];
          break;

        case dist <= 16:
          r = [7, dist - 13, 2];
          break;

        case dist <= 24:
          r = [8, dist - 17, 3];
          break;

        case dist <= 32:
          r = [9, dist - 25, 3];
          break;

        case dist <= 48:
          r = [10, dist - 33, 4];
          break;

        case dist <= 64:
          r = [11, dist - 49, 4];
          break;

        case dist <= 96:
          r = [12, dist - 65, 5];
          break;

        case dist <= 128:
          r = [13, dist - 97, 5];
          break;

        case dist <= 192:
          r = [14, dist - 129, 6];
          break;

        case dist <= 256:
          r = [15, dist - 193, 6];
          break;

        case dist <= 384:
          r = [16, dist - 257, 7];
          break;

        case dist <= 512:
          r = [17, dist - 385, 7];
          break;

        case dist <= 768:
          r = [18, dist - 513, 8];
          break;

        case dist <= 1024:
          r = [19, dist - 769, 8];
          break;

        case dist <= 1536:
          r = [20, dist - 1025, 9];
          break;

        case dist <= 2048:
          r = [21, dist - 1537, 9];
          break;

        case dist <= 3072:
          r = [22, dist - 2049, 10];
          break;

        case dist <= 4096:
          r = [23, dist - 3073, 10];
          break;

        case dist <= 6144:
          r = [24, dist - 4097, 11];
          break;

        case dist <= 8192:
          r = [25, dist - 6145, 11];
          break;

        case dist <= 12288:
          r = [26, dist - 8193, 12];
          break;

        case dist <= 16384:
          r = [27, dist - 12289, 12];
          break;

        case dist <= 24576:
          r = [28, dist - 16385, 13];
          break;

        case dist <= 32768:
          r = [29, dist - 24577, 13];
          break;

        default:
          throw 'invalid distance';
      }

      return r;
    };
    /**
     * マッチ情報を LZ77 符号化配列で返す.
     * なお、ここでは以下の内部仕様で符号化している
     * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]
     * @return {!Array.<number>} LZ77 符号化 byte array.
     */


    Zlib.RawDeflate.Lz77Match.prototype.toLz77Array = function () {
      /** @type {number} */
      var length = this.length;
      /** @type {number} */

      var dist = this.backwardDistance;
      /** @type {Array} */

      var codeArray = [];
      /** @type {number} */

      var pos = 0;
      /** @type {!Array.<number>} */

      var code; // length

      code = Zlib.RawDeflate.Lz77Match.LengthCodeTable[length];
      codeArray[pos++] = code & 0xffff;
      codeArray[pos++] = code >> 16 & 0xff;
      codeArray[pos++] = code >> 24; // distance

      code = this.getDistanceCode_(dist);
      codeArray[pos++] = code[0];
      codeArray[pos++] = code[1];
      codeArray[pos++] = code[2];
      return codeArray;
    };
    /**
     * LZ77 実装
     * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.
     * @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.
     */


    Zlib.RawDeflate.prototype.lz77 = function (dataArray) {
      /** @type {number} input position */
      var position;
      /** @type {number} input length */

      var length;
      /** @type {number} loop counter */

      var i;
      /** @type {number} loop limiter */

      var il;
      /** @type {number} chained-hash-table key */

      var matchKey;
      /** @type {Object.<number, Array.<number>>} chained-hash-table */

      var table = {};
      /** @const @type {number} */

      var windowSize = Zlib.RawDeflate.WindowSize;
      /** @type {Array.<number>} match list */

      var matchList;
      /** @type {Zlib.RawDeflate.Lz77Match} longest match */

      var longestMatch;
      /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */

      var prevMatch;
      /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */

      var lz77buf = new Uint16Array(dataArray.length * 2) ;
      /** @type {number} lz77 output buffer pointer */

      var pos = 0;
      /** @type {number} lz77 skip length */

      var skipLength = 0;
      /** @type {!(Array.<number>|Uint32Array)} */

      var freqsLitLen = new (Uint32Array )(286);
      /** @type {!(Array.<number>|Uint32Array)} */

      var freqsDist = new (Uint32Array )(30);
      /** @type {number} */

      var lazy = this.lazy;
      /** @type {*} temporary variable */

      var tmp; // 初期化

      freqsLitLen[256] = 1; // EOB の最低出現回数は 1

      /**
       * マッチデータの書き込み
       * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.
       * @param {!number} offset スキップ開始位置(相対指定).
       * @private
       */

      function writeMatch(match, offset) {
        /** @type {Array.<number>} */
        var lz77Array = match.toLz77Array();
        /** @type {number} */

        var i;
        /** @type {number} */

        var il;

        for (i = 0, il = lz77Array.length; i < il; ++i) {
          lz77buf[pos++] = lz77Array[i];
        }

        freqsLitLen[lz77Array[0]]++;
        freqsDist[lz77Array[3]]++;
        skipLength = match.length + offset - 1;
        prevMatch = null;
      } // LZ77 符号化


      for (position = 0, length = dataArray.length; position < length; ++position) {
        // ハッシュキーの作成
        for (matchKey = 0, i = 0, il = Zlib.RawDeflate.Lz77MinLength; i < il; ++i) {
          if (position + i === length) {
            break;
          }

          matchKey = matchKey << 8 | dataArray[position + i];
        } // テーブルが未定義だったら作成する


        if (table[matchKey] === void 0) {
          table[matchKey] = [];
        }

        matchList = table[matchKey]; // skip

        if (skipLength-- > 0) {
          matchList.push(position);
          continue;
        } // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)


        while (matchList.length > 0 && position - matchList[0] > windowSize) {
          matchList.shift();
        } // データ末尾でマッチしようがない場合はそのまま流しこむ


        if (position + Zlib.RawDeflate.Lz77MinLength >= length) {
          if (prevMatch) {
            writeMatch(prevMatch, -1);
          }

          for (i = 0, il = length - position; i < il; ++i) {
            tmp = dataArray[position + i];
            lz77buf[pos++] = tmp;
            ++freqsLitLen[tmp];
          }

          break;
        } // マッチ候補から最長のものを探す


        if (matchList.length > 0) {
          longestMatch = this.searchLongestMatch_(dataArray, position, matchList);

          if (prevMatch) {
            // 現在のマッチの方が前回のマッチよりも長い
            if (prevMatch.length < longestMatch.length) {
              // write previous literal
              tmp = dataArray[position - 1];
              lz77buf[pos++] = tmp;
              ++freqsLitLen[tmp]; // write current match

              writeMatch(longestMatch, 0);
            } else {
              // write previous match
              writeMatch(prevMatch, -1);
            }
          } else if (longestMatch.length < lazy) {
            prevMatch = longestMatch;
          } else {
            writeMatch(longestMatch, 0);
          } // 前回マッチしていて今回マッチがなかったら前回のを採用

        } else if (prevMatch) {
          writeMatch(prevMatch, -1);
        } else {
          tmp = dataArray[position];
          lz77buf[pos++] = tmp;
          ++freqsLitLen[tmp];
        }

        matchList.push(position); // マッチテーブルに現在の位置を保存
      } // 終端処理


      lz77buf[pos++] = 256;
      freqsLitLen[256]++;
      this.freqsLitLen = freqsLitLen;
      this.freqsDist = freqsDist;
      return (
        /** @type {!(Uint16Array|Array.<number>)} */
        lz77buf.subarray(0, pos) 
      );
    };
    /**
     * マッチした候補の中から最長一致を探す
     * @param {!Object} data plain data byte array.
     * @param {!number} position plain data byte array position.
     * @param {!Array.<number>} matchList 候補となる位置の配列.
     * @return {!Zlib.RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.
     * @private
     */


    Zlib.RawDeflate.prototype.searchLongestMatch_ = function (data, position, matchList) {
      var match,
          currentMatch,
          matchMax = 0,
          matchLength,
          i,
          j,
          l,
          dl = data.length; // 候補を後ろから 1 つずつ絞り込んでゆく

      permatch: for (i = 0, l = matchList.length; i < l; i++) {
        match = matchList[l - i - 1];
        matchLength = Zlib.RawDeflate.Lz77MinLength; // 前回までの最長一致を末尾から一致検索する

        if (matchMax > Zlib.RawDeflate.Lz77MinLength) {
          for (j = matchMax; j > Zlib.RawDeflate.Lz77MinLength; j--) {
            if (data[match + j - 1] !== data[position + j - 1]) {
              continue permatch;
            }
          }

          matchLength = matchMax;
        } // 最長一致探索


        while (matchLength < Zlib.RawDeflate.Lz77MaxLength && position + matchLength < dl && data[match + matchLength] === data[position + matchLength]) {
          ++matchLength;
        } // マッチ長が同じ場合は後方を優先


        if (matchLength > matchMax) {
          currentMatch = match;
          matchMax = matchLength;
        } // 最長が確定したら後の処理は省略


        if (matchLength === Zlib.RawDeflate.Lz77MaxLength) {
          break;
        }
      }

      return new Zlib.RawDeflate.Lz77Match(matchMax, position - currentMatch);
    };
    /**
     * Tree-Transmit Symbols の算出
     * reference: PuTTY Deflate implementation
     * @param {number} hlit HLIT.
     * @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.
     * @param {number} hdist HDIST.
     * @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.
     * @return {{
     *   codes: !(Array.<number>|Uint32Array),
     *   freqs: !(Array.<number>|Uint8Array)
     * }} Tree-Transmit Symbols.
     */


    Zlib.RawDeflate.prototype.getTreeSymbols_ = function (hlit, litlenLengths, hdist, distLengths) {
      var src = new (Uint32Array )(hlit + hdist),
          i,
          j,
          runLength,
          l,
          result = new (Uint32Array )(286 + 30),
          nResult,
          rpt,
          freqs = new (Uint8Array )(19);
      j = 0;

      for (i = 0; i < hlit; i++) {
        src[j++] = litlenLengths[i];
      }

      for (i = 0; i < hdist; i++) {
        src[j++] = distLengths[i];
      } // 初期化


      nResult = 0;

      for (i = 0, l = src.length; i < l; i += j) {
        // Run Length Encoding
        for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}

        runLength = j;

        if (src[i] === 0) {
          // 0 の繰り返しが 3 回未満ならばそのまま
          if (runLength < 3) {
            while (runLength-- > 0) {
              result[nResult++] = 0;
              freqs[0]++;
            }
          } else {
            while (runLength > 0) {
              // 繰り返しは最大 138 までなので切り詰める
              rpt = runLength < 138 ? runLength : 138;

              if (rpt > runLength - 3 && rpt < runLength) {
                rpt = runLength - 3;
              } // 3-10 回 -> 17


              if (rpt <= 10) {
                result[nResult++] = 17;
                result[nResult++] = rpt - 3;
                freqs[17]++; // 11-138 回 -> 18
              } else {
                result[nResult++] = 18;
                result[nResult++] = rpt - 11;
                freqs[18]++;
              }

              runLength -= rpt;
            }
          }
        } else {
          result[nResult++] = src[i];
          freqs[src[i]]++;
          runLength--; // 繰り返し回数が3回未満ならばランレングス符号は要らない

          if (runLength < 3) {
            while (runLength-- > 0) {
              result[nResult++] = src[i];
              freqs[src[i]]++;
            } // 3 回以上ならばランレングス符号化

          } else {
            while (runLength > 0) {
              // runLengthを 3-6 で分割
              rpt = runLength < 6 ? runLength : 6;

              if (rpt > runLength - 3 && rpt < runLength) {
                rpt = runLength - 3;
              }

              result[nResult++] = 16;
              result[nResult++] = rpt - 3;
              freqs[16]++;
              runLength -= rpt;
            }
          }
        }
      }

      return {
        codes: result.subarray(0, nResult) ,
        freqs: freqs
      };
    };
    /**
     * ハフマン符号の長さを取得する
     * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.
     * @param {number} limit 符号長の制限.
     * @return {!(Array.<number>|Uint8Array)} 符号長配列.
     * @private
     */


    Zlib.RawDeflate.prototype.getLengths_ = function (freqs, limit) {
      /** @type {number} */
      var nSymbols = freqs.length;
      /** @type {Zlib.Heap} */

      var heap = new Zlib.Heap(2 * Zlib.RawDeflate.HUFMAX);
      /** @type {!(Array.<number>|Uint8Array)} */

      var length = new (Uint8Array )(nSymbols);
      /** @type {Array} */

      var nodes;
      /** @type {!(Array.<number>|Uint32Array)} */

      var values;
      /** @type {!(Array.<number>|Uint8Array)} */

      var codeLength;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il; // 配列の初期化


      for (i = 0; i < nSymbols; ++i) {
        if (freqs[i] > 0) {
          heap.push(i, freqs[i]);
        }
      }

      nodes = new Array(heap.length / 2);
      values = new (Uint32Array )(heap.length / 2); // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了

      if (nodes.length === 1) {
        length[heap.pop().index] = 1;
        return length;
      } // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定


      for (i = 0, il = heap.length / 2; i < il; ++i) {
        nodes[i] = heap.pop();
        values[i] = nodes[i].value;
      }

      codeLength = this.reversePackageMerge_(values, values.length, limit);

      for (i = 0, il = nodes.length; i < il; ++i) {
        length[nodes[i].index] = codeLength[i];
      }

      return length;
    };
    /**
     * Reverse Package Merge Algorithm.
     * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.
     * @param {number} symbols number of symbols.
     * @param {number} limit code length limit.
     * @return {!(Array.<number>|Uint8Array)} code lengths.
     */


    Zlib.RawDeflate.prototype.reversePackageMerge_ = function (freqs, symbols, limit) {
      /** @type {!(Array.<number>|Uint16Array)} */
      var minimumCost = new (Uint16Array )(limit);
      /** @type {!(Array.<number>|Uint8Array)} */

      var flag = new (Uint8Array )(limit);
      /** @type {!(Array.<number>|Uint8Array)} */

      var codeLength = new (Uint8Array )(symbols);
      /** @type {Array} */

      var value = new Array(limit);
      /** @type {Array} */

      var type = new Array(limit);
      /** @type {Array.<number>} */

      var currentPosition = new Array(limit);
      /** @type {number} */

      var excess = (1 << limit) - symbols;
      /** @type {number} */

      var half = 1 << limit - 1;
      /** @type {number} */

      var i;
      /** @type {number} */

      var j;
      /** @type {number} */

      var t;
      /** @type {number} */

      var weight;
      /** @type {number} */

      var next;
      /**
       * @param {number} j
       */

      function takePackage(j) {
        /** @type {number} */
        var x = type[j][currentPosition[j]];

        if (x === symbols) {
          takePackage(j + 1);
          takePackage(j + 1);
        } else {
          --codeLength[x];
        }

        ++currentPosition[j];
      }

      minimumCost[limit - 1] = symbols;

      for (j = 0; j < limit; ++j) {
        if (excess < half) {
          flag[j] = 0;
        } else {
          flag[j] = 1;
          excess -= half;
        }

        excess <<= 1;
        minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols;
      }

      minimumCost[0] = flag[0];
      value[0] = new Array(minimumCost[0]);
      type[0] = new Array(minimumCost[0]);

      for (j = 1; j < limit; ++j) {
        if (minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {
          minimumCost[j] = 2 * minimumCost[j - 1] + flag[j];
        }

        value[j] = new Array(minimumCost[j]);
        type[j] = new Array(minimumCost[j]);
      }

      for (i = 0; i < symbols; ++i) {
        codeLength[i] = limit;
      }

      for (t = 0; t < minimumCost[limit - 1]; ++t) {
        value[limit - 1][t] = freqs[t];
        type[limit - 1][t] = t;
      }

      for (i = 0; i < limit; ++i) {
        currentPosition[i] = 0;
      }

      if (flag[limit - 1] === 1) {
        --codeLength[0];
        ++currentPosition[limit - 1];
      }

      for (j = limit - 2; j >= 0; --j) {
        i = 0;
        weight = 0;
        next = currentPosition[j + 1];

        for (t = 0; t < minimumCost[j]; t++) {
          weight = value[j + 1][next] + value[j + 1][next + 1];

          if (weight > freqs[i]) {
            value[j][t] = weight;
            type[j][t] = symbols;
            next += 2;
          } else {
            value[j][t] = freqs[i];
            type[j][t] = i;
            ++i;
          }
        }

        currentPosition[j] = 0;

        if (flag[j] === 1) {
          takePackage(j);
        }
      }

      return codeLength;
    };
    /**
     * 符号長配列からハフマン符号を取得する
     * reference: PuTTY Deflate implementation
     * @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.
     * @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.
     * @private
     */


    Zlib.RawDeflate.prototype.getCodesFromLengths_ = function (lengths) {
      var codes = new (Uint16Array )(lengths.length),
          count = [],
          startCode = [],
          code = 0,
          i,
          il,
          j,
          m; // Count the codes of each length.

      for (i = 0, il = lengths.length; i < il; i++) {
        count[lengths[i]] = (count[lengths[i]] | 0) + 1;
      } // Determine the starting code for each length block.


      for (i = 1, il = Zlib.RawDeflate.MaxCodeLength; i <= il; i++) {
        startCode[i] = code;
        code += count[i] | 0;
        code <<= 1;
      } // Determine the code for each symbol. Mirrored, of course.


      for (i = 0, il = lengths.length; i < il; i++) {
        code = startCode[lengths[i]];
        startCode[lengths[i]] += 1;
        codes[i] = 0;

        for (j = 0, m = lengths[i]; j < m; j++) {
          codes[i] = codes[i] << 1 | code & 1;
          code >>>= 1;
        }
      }

      return codes;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {Object=} opt_params options.
     * @constructor
     */


    Zlib.Unzip = function (input, opt_params) {
      opt_params = opt_params || {};
      /** @type {!(Array.<number>|Uint8Array)} */

      this.input = input instanceof Array ? new Uint8Array(input) : input;
      /** @type {number} */

      this.ip = 0;
      /** @type {number} */

      this.eocdrOffset;
      /** @type {number} */

      this.numberOfThisDisk;
      /** @type {number} */

      this.startDisk;
      /** @type {number} */

      this.totalEntriesThisDisk;
      /** @type {number} */

      this.totalEntries;
      /** @type {number} */

      this.centralDirectorySize;
      /** @type {number} */

      this.centralDirectoryOffset;
      /** @type {number} */

      this.commentLength;
      /** @type {(Array.<number>|Uint8Array)} */

      this.comment;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      this.fileHeaderList;
      /** @type {Object.<string, number>} */

      this.filenameToIndex;
      /** @type {boolean} */

      this.verify = opt_params['verify'] || false;
      /** @type {(Array.<number>|Uint8Array)} */

      this.password = opt_params['password'];
    };

    Zlib.Unzip.CompressionMethod = Zlib.Zip.CompressionMethod;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib.Unzip.FileHeaderSignature = Zlib.Zip.FileHeaderSignature;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib.Unzip.LocalFileHeaderSignature = Zlib.Zip.LocalFileHeaderSignature;
    /**
     * @type {Array.<number>}
     * @const
     */

    Zlib.Unzip.CentralDirectorySignature = Zlib.Zip.CentralDirectorySignature;
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {number} ip input position.
     * @constructor
     */

    Zlib.Unzip.FileHeader = function (input, ip) {
      /** @type {!(Array.<number>|Uint8Array)} */
      this.input = input;
      /** @type {number} */

      this.offset = ip;
      /** @type {number} */

      this.length;
      /** @type {number} */

      this.version;
      /** @type {number} */

      this.os;
      /** @type {number} */

      this.needVersion;
      /** @type {number} */

      this.flags;
      /** @type {number} */

      this.compression;
      /** @type {number} */

      this.time;
      /** @type {number} */

      this.date;
      /** @type {number} */

      this.crc32;
      /** @type {number} */

      this.compressedSize;
      /** @type {number} */

      this.plainSize;
      /** @type {number} */

      this.fileNameLength;
      /** @type {number} */

      this.extraFieldLength;
      /** @type {number} */

      this.fileCommentLength;
      /** @type {number} */

      this.diskNumberStart;
      /** @type {number} */

      this.internalFileAttributes;
      /** @type {number} */

      this.externalFileAttributes;
      /** @type {number} */

      this.relativeOffset;
      /** @type {string} */

      this.filename;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.extraField;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.comment;
    };

    Zlib.Unzip.FileHeader.prototype.parse = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip = this.offset; // central file header signature

      if (input[ip++] !== Zlib.Unzip.FileHeaderSignature[0] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[1] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[2] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[3]) {
        throw new Error('invalid file header signature');
      } // version made by


      this.version = input[ip++];
      this.os = input[ip++]; // version needed to extract

      this.needVersion = input[ip++] | input[ip++] << 8; // general purpose bit flag

      this.flags = input[ip++] | input[ip++] << 8; // compression method

      this.compression = input[ip++] | input[ip++] << 8; // last mod file time

      this.time = input[ip++] | input[ip++] << 8; //last mod file date

      this.date = input[ip++] | input[ip++] << 8; // crc-32

      this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // compressed size

      this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // uncompressed size

      this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name length

      this.fileNameLength = input[ip++] | input[ip++] << 8; // extra field length

      this.extraFieldLength = input[ip++] | input[ip++] << 8; // file comment length

      this.fileCommentLength = input[ip++] | input[ip++] << 8; // disk number start

      this.diskNumberStart = input[ip++] | input[ip++] << 8; // internal file attributes

      this.internalFileAttributes = input[ip++] | input[ip++] << 8; // external file attributes

      this.externalFileAttributes = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24; // relative offset of local header

      this.relativeOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name

      this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength) ); // extra field

      this.extraField = input.subarray(ip, ip += this.extraFieldLength) ; // file comment

      this.comment = input.subarray(ip, ip + this.fileCommentLength) ;
      this.length = ip - this.offset;
    };
    /**
     * @param {!(Array.<number>|Uint8Array)} input input buffer.
     * @param {number} ip input position.
     * @constructor
     */


    Zlib.Unzip.LocalFileHeader = function (input, ip) {
      /** @type {!(Array.<number>|Uint8Array)} */
      this.input = input;
      /** @type {number} */

      this.offset = ip;
      /** @type {number} */

      this.length;
      /** @type {number} */

      this.needVersion;
      /** @type {number} */

      this.flags;
      /** @type {number} */

      this.compression;
      /** @type {number} */

      this.time;
      /** @type {number} */

      this.date;
      /** @type {number} */

      this.crc32;
      /** @type {number} */

      this.compressedSize;
      /** @type {number} */

      this.plainSize;
      /** @type {number} */

      this.fileNameLength;
      /** @type {number} */

      this.extraFieldLength;
      /** @type {string} */

      this.filename;
      /** @type {!(Array.<number>|Uint8Array)} */

      this.extraField;
    };

    Zlib.Unzip.LocalFileHeader.Flags = Zlib.Zip.Flags;

    Zlib.Unzip.LocalFileHeader.prototype.parse = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip = this.offset; // local file header signature

      if (input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[0] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[1] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[2] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[3]) {
        throw new Error('invalid local file header signature');
      } // version needed to extract


      this.needVersion = input[ip++] | input[ip++] << 8; // general purpose bit flag

      this.flags = input[ip++] | input[ip++] << 8; // compression method

      this.compression = input[ip++] | input[ip++] << 8; // last mod file time

      this.time = input[ip++] | input[ip++] << 8; //last mod file date

      this.date = input[ip++] | input[ip++] << 8; // crc-32

      this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // compressed size

      this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // uncompressed size

      this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // file name length

      this.fileNameLength = input[ip++] | input[ip++] << 8; // extra field length

      this.extraFieldLength = input[ip++] | input[ip++] << 8; // file name

      this.filename = String.fromCharCode.apply(null, input.subarray(ip, ip += this.fileNameLength) ); // extra field

      this.extraField = input.subarray(ip, ip += this.extraFieldLength) ;
      this.length = ip - this.offset;
    };

    Zlib.Unzip.prototype.searchEndOfCentralDirectoryRecord = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip;

      for (ip = input.length - 12; ip > 0; --ip) {
        if (input[ip] === Zlib.Unzip.CentralDirectorySignature[0] && input[ip + 1] === Zlib.Unzip.CentralDirectorySignature[1] && input[ip + 2] === Zlib.Unzip.CentralDirectorySignature[2] && input[ip + 3] === Zlib.Unzip.CentralDirectorySignature[3]) {
          this.eocdrOffset = ip;
          return;
        }
      }

      throw new Error('End of Central Directory Record not found');
    };

    Zlib.Unzip.prototype.parseEndOfCentralDirectoryRecord = function () {
      /** @type {!(Array.<number>|Uint8Array)} */
      var input = this.input;
      /** @type {number} */

      var ip;

      if (!this.eocdrOffset) {
        this.searchEndOfCentralDirectoryRecord();
      }

      ip = this.eocdrOffset; // signature

      if (input[ip++] !== Zlib.Unzip.CentralDirectorySignature[0] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[1] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[2] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[3]) {
        throw new Error('invalid signature');
      } // number of this disk


      this.numberOfThisDisk = input[ip++] | input[ip++] << 8; // number of the disk with the start of the central directory

      this.startDisk = input[ip++] | input[ip++] << 8; // total number of entries in the central directory on this disk

      this.totalEntriesThisDisk = input[ip++] | input[ip++] << 8; // total number of entries in the central directory

      this.totalEntries = input[ip++] | input[ip++] << 8; // size of the central directory

      this.centralDirectorySize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // offset of start of central directory with respect to the starting disk number

      this.centralDirectoryOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0; // .ZIP file comment length

      this.commentLength = input[ip++] | input[ip++] << 8; // .ZIP file comment

      this.comment = input.subarray(ip, ip + this.commentLength) ;
    };

    Zlib.Unzip.prototype.parseFileHeader = function () {
      /** @type {Array.<Zlib.Unzip.FileHeader>} */
      var filelist = [];
      /** @type {Object.<string, number>} */

      var filetable = {};
      /** @type {number} */

      var ip;
      /** @type {Zlib.Unzip.FileHeader} */

      var fileHeader;
      /*: @type {number} */

      var i;
      /*: @type {number} */

      var il;

      if (this.fileHeaderList) {
        return;
      }

      if (this.centralDirectoryOffset === void 0) {
        this.parseEndOfCentralDirectoryRecord();
      }

      ip = this.centralDirectoryOffset;

      for (i = 0, il = this.totalEntries; i < il; ++i) {
        fileHeader = new Zlib.Unzip.FileHeader(this.input, ip);
        fileHeader.parse();
        ip += fileHeader.length;
        filelist[i] = fileHeader;
        filetable[fileHeader.filename] = i;
      }

      if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {
        throw new Error('invalid file header size');
      }

      this.fileHeaderList = filelist;
      this.filenameToIndex = filetable;
    };
    /**
     * @param {number} index file header index.
     * @param {Object=} opt_params
     * @return {!(Array.<number>|Uint8Array)} file data.
     */


    Zlib.Unzip.prototype.getFileData = function (index, opt_params) {
      opt_params = opt_params || {};
      /** @type {!(Array.<number>|Uint8Array)} */

      var input = this.input;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      var fileHeaderList = this.fileHeaderList;
      /** @type {Zlib.Unzip.LocalFileHeader} */

      var localFileHeader;
      /** @type {number} */

      var offset;
      /** @type {number} */

      var length;
      /** @type {!(Array.<number>|Uint8Array)} */

      var buffer;
      /** @type {number} */

      var crc32;
      /** @type {Array.<number>|Uint32Array|Object} */

      var key;
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;

      if (!fileHeaderList) {
        this.parseFileHeader();
      }

      if (fileHeaderList[index] === void 0) {
        throw new Error('wrong index');
      }

      offset = fileHeaderList[index].relativeOffset;
      localFileHeader = new Zlib.Unzip.LocalFileHeader(this.input, offset);
      localFileHeader.parse();
      offset += localFileHeader.length;
      length = localFileHeader.compressedSize; // decryption

      if ((localFileHeader.flags & Zlib.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {
        if (!(opt_params['password'] || this.password)) {
          throw new Error('please set password');
        }

        key = this.createDecryptionKey(opt_params['password'] || this.password); // encryption header

        for (i = offset, il = offset + 12; i < il; ++i) {
          this.decode(key, input[i]);
        }

        offset += 12;
        length -= 12; // decryption

        for (i = offset, il = offset + length; i < il; ++i) {
          input[i] = this.decode(key, input[i]);
        }
      }

      switch (localFileHeader.compression) {
        case Zlib.Unzip.CompressionMethod.STORE:
          buffer = this.input.subarray(offset, offset + length) ;
          break;

        case Zlib.Unzip.CompressionMethod.DEFLATE:
          buffer = new Zlib.RawInflate(this.input, {
            'index': offset,
            'bufferSize': localFileHeader.plainSize
          }).decompress();
          break;

        default:
          throw new Error('unknown compression type');
      }

      if (this.verify) {
        crc32 = Zlib.CRC32.calc(buffer);

        if (localFileHeader.crc32 !== crc32) {
          throw new Error('wrong crc: file=0x' + localFileHeader.crc32.toString(16) + ', data=0x' + crc32.toString(16));
        }
      }

      return buffer;
    };
    /**
     * @return {Array.<string>}
     */


    Zlib.Unzip.prototype.getFilenames = function () {
      /** @type {Array.<string>} */
      var filenameList = [];
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;
      /** @type {Array.<Zlib.Unzip.FileHeader>} */

      var fileHeaderList;

      if (!this.fileHeaderList) {
        this.parseFileHeader();
      }

      fileHeaderList = this.fileHeaderList;

      for (i = 0, il = fileHeaderList.length; i < il; ++i) {
        filenameList[i] = fileHeaderList[i].filename;
      }

      return filenameList;
    };
    /**
     * @param {string} filename extract filename.
     * @param {Object=} opt_params
     * @return {!(Array.<number>|Uint8Array)} decompressed data.
     */


    Zlib.Unzip.prototype.decompress = function (filename, opt_params) {
      /** @type {number} */
      var index;

      if (!this.filenameToIndex) {
        this.parseFileHeader();
      }

      index = this.filenameToIndex[filename];

      if (index === void 0) {
        throw new Error(filename + ' not found');
      }

      return this.getFileData(index, opt_params);
    };
    /**
     * @param {(Array.<number>|Uint8Array)} password
     */


    Zlib.Unzip.prototype.setPassword = function (password) {
      this.password = password;
    };
    /**
     * @param {(Array.<number>|Uint32Array|Object)} key
     * @param {number} n
     * @return {number}
     */


    Zlib.Unzip.prototype.decode = function (key, n) {
      n ^= this.getByte(
      /** @type {(Array.<number>|Uint32Array)} */
      key);
      this.updateKeys(
      /** @type {(Array.<number>|Uint32Array)} */
      key, n);
      return n;
    }; // common method


    Zlib.Unzip.prototype.updateKeys = Zlib.Zip.prototype.updateKeys;
    Zlib.Unzip.prototype.createDecryptionKey = Zlib.Zip.prototype.createEncryptionKey;
    Zlib.Unzip.prototype.getByte = Zlib.Zip.prototype.getByte;
    /**
     * @fileoverview 雑多な関数群をまとめたモジュール実装.
     */

    /**
     * Byte String から Byte Array に変換.
     * @param {!string} str byte string.
     * @return {!Array.<number>} byte array.
     */

    Zlib.Util.stringToByteArray = function (str) {
      /** @type {!Array.<(string|number)>} */
      var tmp = str.split('');
      /** @type {number} */

      var i;
      /** @type {number} */

      var il;

      for (i = 0, il = tmp.length; i < il; i++) {
        tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;
      }

      return tmp;
    };
    /**
     * @fileoverview Adler32 checksum 実装.
     */

    /**
     * Adler32 ハッシュ値の作成
     * @param {!(Array|Uint8Array|string)} array 算出に使用する byte array.
     * @return {number} Adler32 ハッシュ値.
     */


    Zlib.Adler32 = function (array) {
      if (typeof array === 'string') {
        array = Zlib.Util.stringToByteArray(array);
      }

      return Zlib.Adler32.update(1, array);
    };
    /**
     * Adler32 ハッシュ値の更新
     * @param {number} adler 現在のハッシュ値.
     * @param {!(Array|Uint8Array)} array 更新に使用する byte array.
     * @return {number} Adler32 ハッシュ値.
     */


    Zlib.Adler32.update = function (adler, array) {
      /** @type {number} */
      var s1 = adler & 0xffff;
      /** @type {number} */

      var s2 = adler >>> 16 & 0xffff;
      /** @type {number} array length */

      var len = array.length;
      /** @type {number} loop length (don't overflow) */

      var tlen;
      /** @type {number} array index */

      var i = 0;

      while (len > 0) {
        tlen = len > Zlib.Adler32.OptimizationParameter ? Zlib.Adler32.OptimizationParameter : len;
        len -= tlen;

        do {
          s1 += array[i++];
          s2 += s1;
        } while (--tlen);

        s1 %= 65521;
        s2 %= 65521;
      }

      return (s2 << 16 | s1) >>> 0;
    };
    /**
     * Adler32 最適化パラメータ
     * 現状では 1024 程度が最適.
     * @see http://jsperf.com/adler-32-simple-vs-optimized/3
     * @define {number}
     */


    Zlib.Adler32.OptimizationParameter = 1024;
    /**
     * ビットストリーム
     * @constructor
     * @param {!(Array|Uint8Array)=} buffer output buffer.
     * @param {number=} bufferPosition start buffer pointer.
     */

    Zlib.BitStream = function (buffer, bufferPosition) {
      /** @type {number} buffer index. */
      this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;
      /** @type {number} bit index. */

      this.bitindex = 0;
      /** @type {!(Array|Uint8Array)} bit-stream output buffer. */

      this.buffer = buffer instanceof (Uint8Array ) ? buffer : new (Uint8Array )(Zlib.BitStream.DefaultBlockSize); // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする

      if (this.buffer.length * 2 <= this.index) {
        throw new Error("invalid index");
      } else if (this.buffer.length <= this.index) {
        this.expandBuffer();
      }
    };
    /**
     * デフォルトブロックサイズ.
     * @const
     * @type {number}
     */


    Zlib.BitStream.DefaultBlockSize = 0x8000;
    /**
     * expand buffer.
     * @return {!(Array|Uint8Array)} new buffer.
     */

    Zlib.BitStream.prototype.expandBuffer = function () {
      /** @type {!(Array|Uint8Array)} old buffer. */
      var oldbuf = this.buffer;
      /** @type {number} loop limiter. */

      var il = oldbuf.length;
      /** @type {!(Array|Uint8Array)} new buffer. */

      var buffer = new (Uint8Array )(il << 1); // copy buffer

      {
        buffer.set(oldbuf);
      }

      return this.buffer = buffer;
    };
    /**
     * 数値をビットで指定した数だけ書き込む.
     * @param {number} number 書き込む数値.
     * @param {number} n 書き込むビット数.
     * @param {boolean=} reverse 逆順に書き込むならば true.
     */


    Zlib.BitStream.prototype.writeBits = function (number, n, reverse) {
      var buffer = this.buffer;
      var index = this.index;
      var bitindex = this.bitindex;
      /** @type {number} current octet. */

      var current = buffer[index];
      /** @type {number} loop counter. */

      var i;
      /**
       * 32-bit 整数のビット順を逆にする
       * @param {number} n 32-bit integer.
       * @return {number} reversed 32-bit integer.
       * @private
       */

      function rev32_(n) {
        return Zlib.BitStream.ReverseTable[n & 0xFF] << 24 | Zlib.BitStream.ReverseTable[n >>> 8 & 0xFF] << 16 | Zlib.BitStream.ReverseTable[n >>> 16 & 0xFF] << 8 | Zlib.BitStream.ReverseTable[n >>> 24 & 0xFF];
      }

      if (reverse && n > 1) {
        number = n > 8 ? rev32_(number) >> 32 - n : Zlib.BitStream.ReverseTable[number] >> 8 - n;
      } // Byte 境界を超えないとき


      if (n + bitindex < 8) {
        current = current << n | number;
        bitindex += n; // Byte 境界を超えるとき
      } else {
        for (i = 0; i < n; ++i) {
          current = current << 1 | number >> n - i - 1 & 1; // next byte

          if (++bitindex === 8) {
            bitindex = 0;
            buffer[index++] = Zlib.BitStream.ReverseTable[current];
            current = 0; // expand

            if (index === buffer.length) {
              buffer = this.expandBuffer();
            }
          }
        }
      }

      buffer[index] = current;
      this.buffer = buffer;
      this.bitindex = bitindex;
      this.index = index;
    };
    /**
     * ストリームの終端処理を行う
     * @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.
     */


    Zlib.BitStream.prototype.finish = function () {
      var buffer = this.buffer;
      var index = this.index;
      /** @type {!(Array|Uint8Array)} output buffer. */

      var output; // bitindex が 0 の時は余分に index が進んでいる状態

      if (this.bitindex > 0) {
        buffer[index] <<= 8 - this.bitindex;
        buffer[index] = Zlib.BitStream.ReverseTable[buffer[index]];
        index++;
      } // array truncation


      {
        output = buffer.subarray(0, index);
      }

      return output;
    };
    /**
     * 0-255 のビット順を反転したテーブル
     * @const
     * @type {!(Uint8Array|Array.<number>)}
     */


    Zlib.BitStream.ReverseTable = function (table) {
      return table;
    }(function () {
      /** @type {!(Array|Uint8Array)} reverse table. */
      var table = new (Uint8Array )(256);
      /** @type {number} loop counter. */

      var i; // generate

      for (i = 0; i < 256; ++i) {
        table[i] = function (n) {
          var r = n;
          var s = 7;

          for (n >>>= 1; n; n >>>= 1) {
            r <<= 1;
            r |= n & 1;
            --s;
          }

          return (r << s & 0xff) >>> 0;
        }(i);
      }

      return table;
    }());
    /**
     * CRC32 ハッシュ値を取得
     * @param {!(Array.<number>|Uint8Array)} data data byte array.
     * @param {number=} pos data position.
     * @param {number=} length data length.
     * @return {number} CRC32.
     */

    Zlib.CRC32.calc = function (data, pos, length) {
      return Zlib.CRC32.update(data, 0, pos, length);
    };
    /**
     * CRC32ハッシュ値を更新
     * @param {!(Array.<number>|Uint8Array)} data data byte array.
     * @param {number} crc CRC32.
     * @param {number=} pos data position.
     * @param {number=} length data length.
     * @return {number} CRC32.
     */


    Zlib.CRC32.update = function (data, crc, pos, length) {
      var table = Zlib.CRC32.Table;
      var i = typeof pos === 'number' ? pos : pos = 0;
      var il = typeof length === 'number' ? length : data.length;
      crc ^= 0xffffffff; // loop unrolling for performance

      for (i = il & 7; i--; ++pos) {
        crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 0xff];
      }

      for (i = il >> 3; i--; pos += 8) {
        crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 1]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 2]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 3]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 4]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 5]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 6]) & 0xff];
        crc = crc >>> 8 ^ table[(crc ^ data[pos + 7]) & 0xff];
      }

      return (crc ^ 0xffffffff) >>> 0;
    };
    /**
     * @param {number} num
     * @param {number} crc
     * @returns {number}
     */


    Zlib.CRC32.single = function (num, crc) {
      return (Zlib.CRC32.Table[(num ^ crc) & 0xff] ^ num >>> 8) >>> 0;
    };
    /**
     * @type {Array.<number>}
     * @const
     * @private
     */


    Zlib.CRC32.Table_ = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d];
    /**
     * @type {!(Array.<number>|Uint32Array)} CRC-32 Table.
     * @const
     */

    Zlib.CRC32.Table = new Uint32Array(Zlib.CRC32.Table_) ;
    /**
     * @fileoverview Deflate (RFC1951) 実装.
     * Deflateアルゴリズム本体は Zlib.RawDeflate で実装されている.
     */

    /**
     * Zlib Deflate
     * @constructor
     * @param {!(Array|Uint8Array)} input 符号化する対象の byte array.
     * @param {Object=} opt_params option parameters.
     */

    Zlib.Deflate = function (input, opt_params) {
      /** @type {!(Array|Uint8Array)} */
      this.input = input;
      /** @type {!(Array|Uint8Array)} */

      this.output = new (Uint8Array )(Zlib.Deflate.DefaultBufferSize);
      /** @type {Zlib.Deflate.CompressionType} */

      this.compressionType = Zlib.Deflate.CompressionType.DYNAMIC;
      /** @type {Zlib.RawDeflate} */

      this.rawDeflate;
      /** @type {Object} */

      var rawDeflateOption = {};
      /** @type {string} */

      var prop; // option parameters

      if (opt_params || !(opt_params = {})) {
        if (typeof opt_params['compressionType'] === 'number') {
          this.compressionType = opt_params['compressionType'];
        }
      } // copy options


      for (prop in opt_params) {
        rawDeflateOption[prop] = opt_params[prop];
      } // set raw-deflate output buffer


      rawDeflateOption['outputBuffer'] = this.output;
      this.rawDeflate = new Zlib.RawDeflate(this.input, rawDeflateOption);
    };
    /**
     * @const
     * @type {number} デフォルトバッファサイズ.
     */


    Zlib.Deflate.DefaultBufferSize = 0x8000;
    /**
     * @enum {number}
     */

    Zlib.Deflate.CompressionType = Zlib.RawDeflate.CompressionType;
    /**
     * 直接圧縮に掛ける.
     * @param {!(Array|Uint8Array)} input target buffer.
     * @param {Object=} opt_params option parameters.
     * @return {!(Array|Uint8Array)} compressed data byte array.
     */

    Zlib.Deflate.compress = function (input, opt_params) {
      return new Zlib.Deflate(input, opt_params).compress();
    };
    /**
     * Deflate Compression.
     * @return {!(Array|Uint8Array)} compressed data byte array.
     */


    Zlib.Deflate.prototype.compress = function () {
      /** @type {Zlib.CompressionMethod} */
      var cm;
      /** @type {number} */

      var cinfo;
      /** @type {number} */

      var cmf;
      /** @type {number} */

      var flg;
      /** @type {number} */

      var fcheck;
      /** @type {number} */

      var fdict;
      /** @type {number} */

      var flevel;
      /** @type {number} */

      var adler;
      /** @type {!(Array|Uint8Array)} */

      var output;
      /** @type {number} */

      var pos = 0;
      output = this.output; // Compression Method and Flags

      cm = Zlib.CompressionMethod.DEFLATE;

      switch (cm) {
        case Zlib.CompressionMethod.DEFLATE:
          cinfo = Math.LOG2E * Math.log(Zlib.RawDeflate.WindowSize) - 8;
          break;

        default:
          throw new Error('invalid compression method');
      }

      cmf = cinfo << 4 | cm;
      output[pos++] = cmf; // Flags

      fdict = 0;

      switch (cm) {
        case Zlib.CompressionMethod.DEFLATE:
          switch (this.compressionType) {
            case Zlib.Deflate.CompressionType.NONE:
              flevel = 0;
              break;

            case Zlib.Deflate.CompressionType.FIXED:
              flevel = 1;
              break;

            case Zlib.Deflate.CompressionType.DYNAMIC:
              flevel = 2;
              break;

            default:
              throw new Error('unsupported compression type');
          }

          break;

        default:
          throw new Error('invalid compression method');
      }

      flg = flevel << 6 | fdict << 5;
      fcheck = 31 - (cmf * 256 + flg) % 31;
      flg |= fcheck;
      output[pos++] = flg; // Adler-32 checksum

      adler = Zlib.Adler32(this.input);
      this.rawDeflate.op = pos;
      output = this.rawDeflate.compress();
      pos = output.length;

      {
        // subarray 分を元にもどす
        output = new Uint8Array(output.buffer); // expand buffer

        if (output.length <= pos + 4) {
          this.output = new Uint8Array(output.length + 4);
          this.output.set(output);
          output = this.output;
        }

        output = output.subarray(0, pos + 4);
      } // adler32


      output[pos++] = adler >> 24 & 0xff;
      output[pos++] = adler >> 16 & 0xff;
      output[pos++] = adler >> 8 & 0xff;
      output[pos++] = adler & 0xff;
      return output;
    };

    const isNode$3 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
    const crossFetch = isNode$3 ? require("node-fetch") : fetch;

    class BrowserLocalFile {
      constructor(blob) {
        this.file = blob;
      }

      async read(position, length) {
        const file = this.file;
        return new Promise(function (fullfill, reject) {
          const fileReader = new FileReader();

          fileReader.onload = function (e) {
            fullfill(fileReader.result);
          };

          fileReader.onerror = function (e) {
            console.err("Error reading local file " + file.name);
            reject(null, fileReader);
          };

          if (position !== undefined) {
            const blob = file.slice(position, position + length);
            fileReader.readAsArrayBuffer(blob);
          } else {
            fileReader.readAsArrayBuffer(file);
          }
        });
      }

    }

    const isNode$2 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
    let fs;
    let fsOpen;
    let fsRead;

    if (isNode$2) {
      const util = require('util');

      fs = require('fs');
      fsOpen = fs && util.promisify(fs.open);
      fsRead = fs && util.promisify(fs.read);
    }

    class NodeLocalFile {
      constructor(args) {
        this.path = args.path;
      }

      async read(position, length) {
        const buffer = Buffer.alloc(length);
        const fd = await fsOpen(this.path, 'r');
        const result = await fsRead(fd, buffer, 0, length, position);
        fs.close(fd, function (error) {// TODO Do something with error
        }); //TODO -- compare result.bytesRead with length

        const b = result.buffer;
        const arrayBuffer = b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
        return arrayBuffer;
      }

    }

    const isNode$1 = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

    class RemoteFile {
      constructor(args) {
        this.config = args;
        this.url = mapUrl(args.path || args.url);
      }

      async read(position, length) {
        length = Math.ceil(length);
        const headers = this.config.headers || {};
        const rangeString = "bytes=" + position + "-" + (position + length - 1);
        headers['Range'] = rangeString;
        let url = this.url.slice(); // slice => copy

        if (isNode$1) {
          headers['User-Agent'] = 'straw';
        } else {
          if (this.config.oauthToken) {
            const token = resolveToken(this.config.oauthToken);
            headers['Authorization'] = `Bearer ${token}`;
          }

          navigator.vendor.indexOf("Apple") == 0 && /\sSafari\//.test(navigator.userAgent);
          const isChrome = navigator.userAgent.indexOf('Chrome') > -1;
          const isAmazonV4Signed = this.url.indexOf("X-Amz-Signature") > -1;

          if (isChrome && !isAmazonV4Signed) {
            url = addParameter(url, "randomSeed", Math.random().toString(36));
          }
        }

        if (this.config.apiKey) {
          url = addParameter(url, "key", this.config.apiKey);
        }

        const response = await crossFetch(url, {
          method: 'GET',
          headers: headers,
          redirect: 'follow',
          mode: 'cors'
        });
        const status = response.status;

        if (status >= 400) {
          console.error(`${status}  ${this.config.url}`);
          const err = Error(response.statusText);
          err.code = status;
          throw err;
        } else {
          return response.arrayBuffer();
        }
        /**
         * token can be a string, a function that returns a string, or a function that returns a Promise for a string
         * @param token
         * @returns {Promise<*>}
         */


        async function resolveToken(token) {
          if (typeof token === 'function') {
            return await Promise.resolve(token()); // Normalize the result to a promise, since we don't know what the function returns
          } else {
            return token;
          }
        }
      }

    }

    function mapUrl(url) {
      if (url.includes("//www.dropbox.com")) {
        return url.replace("//www.dropbox.com", "//dl.dropboxusercontent.com");
      } else if (url.startsWith("ftp://ftp.ncbi.nlm.nih.gov")) {
        return url.replace("ftp://", "https://");
      } else {
        return url;
      }
    }

    function addParameter(url, name, value) {
      const paramSeparator = url.includes("?") ? "&" : "?";
      return url + paramSeparator + name + "=" + value;
    }

    class ThrottledFile {
      constructor(file, rateLimiter) {
        this.file = file;
        this.rateLimiter = rateLimiter;
      }

      async read(position, length) {
        const file = this.file;
        const rateLimiter = this.rateLimiter;
        return new Promise(function (fulfill, reject) {
          rateLimiter.limiter(async function (f) {
            try {
              const result = await f.read(position, length);
              fulfill(result);
            } catch (e) {
              reject(e);
            }
          })(file);
        });
      }

    }

    class RateLimiter {
      constructor(wait) {
        this.wait = wait === undefined ? 100 : wait;
        this.isCalled = false;
        this.calls = [];
      }

      limiter(fn) {
        const self = this;

        let caller = function () {
          if (self.calls.length && !self.isCalled) {
            self.isCalled = true;
            self.calls.shift().call();
            setTimeout(function () {
              self.isCalled = false;
              caller();
            }, self.wait);
          }
        };

        return function () {
          self.calls.push(fn.bind(this, ...arguments));
          caller();
        };
      }

    }

    class BufferedFile {
      constructor(args) {
        this.file = args.file;
        this.size = args.size || 64000;
        this.position = 0;
        this.bufferStart = 0;
        this.bufferLength = 0;
        this.buffer = undefined;
      }

      async read(position, length) {
        const start = position;
        const end = position + length;
        const bufferStart = this.bufferStart;
        const bufferEnd = this.bufferStart + this.bufferLength;

        if (length > this.size) {
          // Request larger than max buffer size,  pass through to underlying file
          //console.log("0")
          this.buffer = undefined;
          this.bufferStart = 0;
          this.bufferLength = 0;
          return this.file.read(position, length);
        }

        if (start >= bufferStart && end <= bufferEnd) {
          // Request within buffer bounds
          //console.log("1")
          const sliceStart = start - bufferStart;
          const sliceEnd = sliceStart + length;
          return this.buffer.slice(sliceStart, sliceEnd);
        } else if (start < bufferStart && end > bufferStart) {
          // Overlap left, here for completness but this is an unexpected case in straw.  We don't adjust the buffer.
          //console.log("2")
          const l1 = bufferStart - start;
          const a1 = await this.file.read(position, l1);
          const l2 = length - l1;

          if (l2 > 0) {
            //this.buffer = await this.file.read(bufferStart, this.size)
            const a2 = this.buffer.slice(0, l2);
            return concatBuffers(a1, a2);
          } else {
            return a1;
          }
        } else if (start < bufferEnd && end > bufferEnd) {
          // Overlap right
          // console.log("3")
          const l1 = bufferEnd - start;
          const sliceStart = this.bufferLength - l1;
          const a1 = this.buffer.slice(sliceStart, this.bufferLength);
          const l2 = length - l1;

          if (l2 > 0) {
            try {
              this.buffer = await this.file.read(bufferEnd, this.size);
              this.bufferStart = bufferEnd;
              this.bufferLength = this.buffer.byteLength;
              const a2 = this.buffer.slice(0, l2);
              return concatBuffers(a1, a2);
            } catch (e) {
              // A "unsatisfiable range" error is expected here if we overlap past the end of file
              if (e.code && e.code === 416) {
                return a1;
              } else {
                throw e;
              }
            }
          } else {
            return a1;
          }
        } else {
          // No overlap with buffer
          // console.log("4")
          this.buffer = await this.file.read(position, this.size);
          this.bufferStart = position;
          this.bufferLength = this.buffer.byteLength;
          return this.buffer.slice(0, length);
        }
      }

    }
    /**
     * concatenates 2 array buffers.
     * Credit: https://gist.github.com/72lions/4528834
     *
     * @private
     * @param {ArrayBuffers} buffer1 The first buffer.
     * @param {ArrayBuffers} buffer2 The second buffer.
     * @return {ArrayBuffers} The new ArrayBuffer created out of the two.
     */


    var concatBuffers = function (buffer1, buffer2) {
      var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
      tmp.set(new Uint8Array(buffer1), 0);
      tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
      return tmp.buffer;
    };

    // TODO -- big endian
    const BinaryParser = function (dataView, littleEndian) {
      this.littleEndian = littleEndian !== undefined ? littleEndian : true;
      this.position = 0;
      this.view = dataView;
      this.length = dataView.byteLength;
    };

    BinaryParser.prototype.available = function () {
      return this.length - this.position;
    };

    BinaryParser.prototype.remLength = function () {
      return this.length - this.position;
    };

    BinaryParser.prototype.hasNext = function () {
      return this.position < this.length - 1;
    };

    BinaryParser.prototype.getByte = function () {
      var retValue = this.view.getUint8(this.position, this.littleEndian);
      this.position++;
      return retValue;
    };

    BinaryParser.prototype.getShort = function () {
      var retValue = this.view.getInt16(this.position, this.littleEndian);
      this.position += 2;
      return retValue;
    };

    BinaryParser.prototype.getUShort = function () {
      // var byte1 = this.getByte(),
      //     byte2 = this.getByte(),
      //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));
      //     return retValue;
      //
      var retValue = this.view.getUint16(this.position, this.littleEndian);
      this.position += 2;
      return retValue;
    };

    BinaryParser.prototype.getInt = function () {
      var retValue = this.view.getInt32(this.position, this.littleEndian);
      this.position += 4;
      return retValue;
    };

    BinaryParser.prototype.getUInt = function () {
      var retValue = this.view.getUint32(this.position, this.littleEndian);
      this.position += 4;
      return retValue;
    };

    BinaryParser.prototype.getLong = function () {
      // DataView doesn't support long. So we'll try manually
      var b = [];
      b[0] = this.view.getUint8(this.position);
      b[1] = this.view.getUint8(this.position + 1);
      b[2] = this.view.getUint8(this.position + 2);
      b[3] = this.view.getUint8(this.position + 3);
      b[4] = this.view.getUint8(this.position + 4);
      b[5] = this.view.getUint8(this.position + 5);
      b[6] = this.view.getUint8(this.position + 6);
      b[7] = this.view.getUint8(this.position + 7);
      var value = 0;

      if (this.littleEndian) {
        for (var i = b.length - 1; i >= 0; i--) {
          value = value * 256 + b[i];
        }
      } else {
        for (var i = 0; i < b.length; i++) {
          value = value * 256 + b[i];
        }
      }

      this.position += 8;
      return value;
    };

    BinaryParser.prototype.getString = function (len) {
      var s = "";
      var c;

      while ((c = this.view.getUint8(this.position++)) != 0) {
        s += String.fromCharCode(c);
        if (len && s.length == len) break;
      }

      return s;
    };

    BinaryParser.prototype.getFixedLengthString = function (len) {
      var s = "";
      var i;
      var c;

      for (i = 0; i < len; i++) {
        c = this.view.getUint8(this.position++);

        if (c > 0) {
          s += String.fromCharCode(c);
        }
      }

      return s;
    };

    BinaryParser.prototype.getFixedLengthTrimmedString = function (len) {
      var s = "";
      var i;
      var c;

      for (i = 0; i < len; i++) {
        c = this.view.getUint8(this.position++);

        if (c > 32) {
          s += String.fromCharCode(c);
        }
      }

      return s;
    };

    BinaryParser.prototype.getFloat = function () {
      var retValue = this.view.getFloat32(this.position, this.littleEndian);
      this.position += 4;
      return retValue;
    };

    BinaryParser.prototype.getDouble = function () {
      var retValue = this.view.getFloat64(this.position, this.littleEndian);
      this.position += 8;
      return retValue;
    };

    BinaryParser.prototype.skip = function (n) {
      this.position += n;
      return this.position;
    };
    /**
     * Return a bgzip (bam and tabix) virtual pointer
     * TODO -- why isn't 8th byte used ?
     * @returns {*}
     */


    BinaryParser.prototype.getVPointer = function () {
      var position = this.position,
          offset = this.view.getUint8(position + 1) << 8 | this.view.getUint8(position),
          byte6 = (this.view.getUint8(position + 6) & 0xff) * 0x100000000,
          byte5 = (this.view.getUint8(position + 5) & 0xff) * 0x1000000,
          byte4 = (this.view.getUint8(position + 4) & 0xff) * 0x10000,
          byte3 = (this.view.getUint8(position + 3) & 0xff) * 0x100,
          byte2 = this.view.getUint8(position + 2) & 0xff,
          block = byte6 + byte5 + byte4 + byte3 + byte2;
      this.position += 8; //       if (block == 0 && offset == 0) {
      //           return null;
      //       } else {

      return new VPointer(block, offset); //       }
    };

    function VPointer(block, offset) {
      this.block = block;
      this.offset = offset;
    }

    VPointer.prototype.isLessThan = function (vp) {
      return this.block < vp.block || this.block === vp.block && this.offset < vp.offset;
    };

    VPointer.prototype.isGreaterThan = function (vp) {
      return this.block > vp.block || this.block === vp.block && this.offset > vp.offset;
    };

    VPointer.prototype.print = function () {
      return "" + this.block + ":" + this.offset;
    };

    class MatrixZoomData {
      constructor(chr1, chr2) {
        this.chr1 = chr1; // chromosome index

        this.chr2 = chr2;
      }

      getKey() {
        return this.chr1.name + "_" + this.chr2.name + "_" + this.zoom.unit + "_" + this.zoom.binSize;
      }

      getBlockNumbers(region1, region2, version) {
        // Verify region chromosomes and swap if neccessary
        if (region1.chr == this.chr2 && region2.chr === this.chr1) {
          const tmp = region1;
          region1 = region2;
          region2 = tmp;
        }

        const sameChr = this.chr1 === this.chr2;
        const binsize = this.zoom.binSize;
        const blockBinCount = this.blockBinCount;
        const blockColumnCount = this.blockColumnCount;
        return version < 9 || !sameChr ? getBlockNumbersV8() : getBlockNumbersV9();

        function getBlockNumbersV8() {
          const x1 = region1.start / binsize;
          const x2 = region1.end / binsize;
          const y1 = region2.start / binsize;
          const y2 = region2.end / binsize;
          const col1 = Math.floor(x1 / blockBinCount);
          const col2 = Math.floor((x2 - 1) / blockBinCount);
          const row1 = Math.floor(y1 / blockBinCount);
          const row2 = Math.floor((y2 - 1) / blockBinCount);
          const blockNumbers = [];

          for (let row = row1; row <= row2; row++) {
            for (let column = col1; column <= col2; column++) {
              let blockNumber;

              if (sameChr && row < column) {
                blockNumber = column * blockColumnCount + row;
              } else {
                blockNumber = row * blockColumnCount + column;
              }

              if (!blockNumbers.includes(blockNumber)) {
                // possible from transposition
                blockNumbers.push(blockNumber);
              }
            }
          }

          return blockNumbers;
        }

        function getBlockNumbersV9() {
          const binX1 = region1.start / binsize;
          const binX2 = region1.end / binsize;
          const binY1 = region2.start / binsize;
          const binY2 = region2.end / binsize; // PAD = positionAlongDiagonal (~projected)
          // Depth is axis perpendicular to diagonal; nearer means closer to diagonal

          const translatedLowerPAD = Math.floor((binX1 + binY1) / 2 / blockBinCount);
          const translatedHigherPAD = Math.floor((binX2 + binY2) / 2 / blockBinCount);
          const translatedNearerDepth = Math.floor(Math.log2(1 + Math.abs(binX1 - binY2) / Math.sqrt(2) / blockBinCount));
          const translatedFurtherDepth = Math.floor(Math.log2(1 + Math.abs(binX2 - binY1) / Math.sqrt(2) / blockBinCount)); // because code above assume above diagonal; but we could be below diagonal

          const containsDiagonal = (binX2 - binY1) * (binX1 - binY2) < 0; // i.e. sign of (x-y) opposite on 2 corners

          const nearerDepth = containsDiagonal ? 0 : Math.min(translatedNearerDepth, translatedFurtherDepth);
          const furtherDepth = Math.max(translatedNearerDepth, translatedFurtherDepth);
          const blockNumbers = [];

          for (let depth = nearerDepth; depth <= furtherDepth; depth++) {
            for (let pad = translatedLowerPAD; pad <= translatedHigherPAD; pad++) {
              const block_number = depth * blockColumnCount + pad;
              blockNumbers.push(block_number);
            }
          }

          return blockNumbers;
        }
      }

      static parseMatrixZoomData(chr1, chr2, dis) {
        const zd = new MatrixZoomData(chr1, chr2);
        const unit = dis.getString();
        const zoomIndex = dis.getInt();
        const sumCounts = dis.getFloat();
        const occupiedCellCount = dis.getFloat();
        const stdDev = dis.getFloat();
        const percent95 = dis.getFloat();
        const binSize = dis.getInt();
        zd.blockBinCount = dis.getInt();
        zd.blockColumnCount = dis.getInt();
        const nBlocks = dis.getInt();
        zd.zoom = {
          index: zoomIndex,
          unit: unit,
          binSize: binSize
        };
        zd.blockIndex = new StaticBlockIndex(nBlocks, dis);
        const nBins1 = chr1.size / binSize;
        const nBins2 = chr2.size / binSize;
        const avgCount = sumCounts / nBins1 / nBins2; // <= trying to avoid overflows

        zd.averageCount = avgCount;
        zd.sumCounts = sumCounts;
        zd.stdDev = stdDev;
        zd.occupiedCellCount = occupiedCellCount;
        zd.percent95 = percent95;
        return zd;
      }

    }

    class StaticBlockIndex {
      constructor(nBlocks, dis) {
        this.blockIndex = {};

        while (nBlocks-- > 0) {
          const blockNumber = dis.getInt();
          const filePosition = dis.getLong();
          const size = dis.getInt();
          this.blockIndex[blockNumber] = {
            filePosition,
            size
          };
        }
      }

      getBlockIndexEntry(blockNumber) {
        return this.blockIndex[blockNumber];
      }

    }

    class Matrix {
      constructor(chr1, chr2, zoomDataList) {
        this.chr1 = chr1;
        this.chr2 = chr2;
        this.bpZoomData = [];
        this.fragZoomData = [];

        for (let zd of zoomDataList) {
          if (zd.zoom.unit === "BP") {
            this.bpZoomData.push(zd);
          } else {
            this.fragZoomData.push(zd);
          }
        }
      }
      /**
       * Find the best zoom level for the given bin size
       * @param binSize
       * @param unit
       * @returns {number}
       */


      findZoomForResolution(binSize, unit) {
        const zdArray = "FRAG" === unit ? this.fragZoomData : this.bpZoomData;

        for (let i = 1; i < zdArray.length; i++) {
          var zd = zdArray[i];

          if (zd.zoom.binSize < binSize) {
            return i - 1;
          }
        }

        return zdArray.length - 1;
      }
      /**
       * Fetch zoom data by bin size.  If no matching level exists return undefined.
       *
       * @param unit
       * @param binSize
       * @param zoom
       * @returns {undefined|*}
       */


      getZoomData(binSize, unit) {
        unit = unit || "BP";
        const zdArray = unit === "BP" ? this.bpZoomData : this.fragZoomData;

        for (let i = 0; i < zdArray.length; i++) {
          var zd = zdArray[i];

          if (binSize === zd.zoom.binSize) {
            return zd;
          }
        }

        return undefined;
      }
      /**
       * Return zoom data by resolution index.
       * @param index
       * @param unit
       * @returns {*}
       */


      getZoomDataByIndex(index, unit) {
        const zdArray = "FRAG" === unit ? this.fragZoomData : this.bpZoomData;
        return zdArray[index];
      }

      static getKey(chrIdx1, chrIdx2) {
        if (chrIdx1 > chrIdx2) {
          const tmp = chrIdx1;
          chrIdx1 = chrIdx2;
          chrIdx2 = tmp;
        }

        return `${chrIdx1}_${chrIdx2}`;
      }

      static parseMatrix(data, chromosomes) {
        const dis = new BinaryParser(new DataView(data));
        const c1 = dis.getInt(); // Should equal chrIdx1

        const c2 = dis.getInt(); // Should equal chrIdx2
        // TODO validate this

        const chr1 = chromosomes[c1];
        const chr2 = chromosomes[c2]; // # of resolution levels (bp and frags)

        let nResolutions = dis.getInt();
        const zdList = [];

        while (nResolutions-- > 0) {
          const zd = MatrixZoomData.parseMatrixZoomData(chr1, chr2, dis);
          zdList.push(zd);
        }

        return new Matrix(c1, c2, zdList);
      }

    }

    class ContactRecord {
      constructor(bin1, bin2, counts) {
        this.bin1 = bin1;
        this.bin2 = bin2;
        this.counts = counts;
      }

      getKey() {
        return "" + this.bin1 + "_" + this.bin2;
      }

    }

    class LRU {
      constructor(max = 10) {
        this.max = max;
        this.map = new Map();
      }

      get(key) {
        let item = this.map.get(key);

        if (item) {
          // refresh key
          this.map.delete(key);
          this.map.set(key, item);
        }

        return item;
      }

      set(key, val) {
        // refresh key
        if (this.map.has(key)) this.map.delete(key); // evict oldest
        else if (this.map.size === this.max) {
          this.map.delete(this.first());
        }
        this.map.set(key, val);
      }

      has(key) {
        return this.map.has(key);
      }

      clear() {
        this.map.clear();
      }

      first() {
        return this.map.keys().next().value;
      }

    } //ref https://stackoverflow.com/questions/996505/lru-cache-implementation-in-javascript

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    const DOUBLE$1 = 8;

    class NormalizationVector {
      constructor(file, filePosition, nValues, dataType) {
        this.file = file;
        this.filePosition = filePosition;
        this.nValues = nValues;
        this.dataType = dataType;
        this.cache = undefined;
      }

      async getValues(start, end) {
        if (!this.cache || start < this.cache.start || end > this.cache.end) {
          const adjustedStart = Math.max(0, start - 1000);
          const adjustedEnd = Math.min(this.nValues, end + 1000);
          const startPosition = this.filePosition + adjustedStart * this.dataType;
          const n = adjustedEnd - adjustedStart;
          const sizeInBytes = n * this.dataType;
          const data = await this.file.read(startPosition, sizeInBytes);

          if (!data) {
            return undefined;
          }

          const parser = new BinaryParser(new DataView(data));
          const values = [];

          for (let i = 0; i < n; i++) {
            values[i] = this.dataType === DOUBLE$1 ? parser.getDouble() : parser.getFloat();
          }

          this.cache = {
            start: adjustedStart,
            end: adjustedEnd,
            values: values
          };
        }

        const sliceStart = start - this.cache.start;
        const sliceEnd = sliceStart + (end - start);
        return this.cache.values.slice(sliceStart, sliceEnd);
      }

      getKey() {
        return NormalizationVector.getKey(this.type, this.chrIdx, this.unit, this.resolution);
      }

      static getNormalizationVectorKey(type, chrIdx, unit, resolution) {
        return type + "_" + chrIdx + "_" + unit + "_" + resolution;
      }

    }

    const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
    const Short_MIN_VALUE = -32768;
    const DOUBLE = 8;
    const FLOAT = 4;
    const INT = 4;
    const GoogleRateLimiter = new RateLimiter(100);

    class HicFile {
      constructor(args) {
        this.config = args;
        this.loadFragData = args.loadFragData;
        this.fragmentSitesCache = {};
        this.normVectorCache = new LRU(10);
        this.normalizationTypes = ['NONE'];
        this.matrixCache = new LRU(10);
        this.blockCache = new BlockCache(); // args may specify an io.File object, a local path (Node only), or a url

        if (args.file) {
          this.file = args.file;
        } else if (args.blob) {
          this.file = new BrowserLocalFile(args.blob);
        } else if (args.url || args.path && !isNode) {
          this.url = args.url || this.path;
          this.remote = true; // Google drive must be rate limited.  Perhaps all remote files should be rate limited?

          const remoteFile = new RemoteFile(args);

          if (isGoogleDrive(this.url)) {
            this.file = new ThrottledFile(remoteFile, GoogleRateLimiter);
          } else {
            this.file = remoteFile;
          }
        } else if (args.path) {
          // path argument, assumed local file
          this.file = new NodeLocalFile({
            path: args.path
          });
        } else {
          throw Error("Arguments must include file, blob, url, or path");
        }
      }

      async init() {
        if (this.initialized) {
          return;
        } else {
          await this.readHeaderAndFooter(); // Footer is read with header
          //await this.readFooter()

          this.initialized = true;
        }
      }

      async getVersion() {
        if (this.version === undefined) {
          const data = await this.file.read(0, 128);

          if (!data) {
            return undefined;
          }

          const binaryParser = new BinaryParser(new DataView(data));
          this.magic = binaryParser.getString();
          this.version = binaryParser.getInt();
          return this.version;
        } else {
          return this.version;
        }
      }

      async getMetaData() {
        await this.init();
        return this.meta;
      }

      async readHeaderAndFooter() {
        // Read initial fields magic, version, and footer position
        let data = await this.file.read(0, 16);

        if (!data || data.byteLength === 0) {
          throw Error("File content is empty");
        }

        let binaryParser = new BinaryParser(new DataView(data));
        this.magic = binaryParser.getString();
        this.version = binaryParser.getInt();

        if (this.version < 5) {
          throw Error("Unsupported hic version: " + this.version);
        }

        this.footerPosition = binaryParser.getLong(); // Read footer and determine file position for body section (i.e. end of header)

        await this.readFooter();
        const bodyPostion = Object.values(this.masterIndex).reduce((min, currentValue) => {
          return Math.min(min, currentValue.start);
        }, Number.MAX_VALUE);
        const remainingSize = bodyPostion - 16;
        data = await this.file.read(16, remainingSize);
        binaryParser = new BinaryParser(new DataView(data));
        this.genomeId = binaryParser.getString();

        if (this.version >= 9) {
          this.normVectorIndexPosition = binaryParser.getLong();
          this.normVectorIndexSize = binaryParser.getLong();
        }

        this.attributes = {};
        let nAttributes = binaryParser.getInt();

        while (nAttributes-- > 0) {
          this.attributes[binaryParser.getString()] = binaryParser.getString();
        }

        this.chromosomes = [];
        this.chromosomeIndexMap = {};
        let nChrs = binaryParser.getInt();
        let i = 0;

        while (nChrs-- > 0) {
          const chr = {
            index: i,
            name: binaryParser.getString(),
            size: this.version < 9 ? binaryParser.getInt() : binaryParser.getLong()
          };

          if (chr.name.toLowerCase() === "all") {
            this.wholeGenomeChromosome = chr;
            this.wholeGenomeResolution = Math.round(chr.size * (1000 / 500)); // Hardcoded in juicer
          }

          this.chromosomes.push(chr);
          this.chromosomeIndexMap[chr.name] = chr.index;
          i++;
        }

        this.bpResolutions = [];
        let nBpResolutions = binaryParser.getInt();

        while (nBpResolutions-- > 0) {
          this.bpResolutions.push(binaryParser.getInt());
        }

        if (this.loadFragData) {
          this.fragResolutions = [];
          let nFragResolutions = binaryParser.getInt();

          if (nFragResolutions > 0) {
            while (nFragResolutions-- > 0) {
              this.fragResolutions.push(binaryParser.getInt());
            } // this.sites = [];
            // for(let i=0; i<this.chromosomes.length - 1; i++) {
            //     const chrSites = [];
            //     this.sites.push(chrSites);
            //     let nSites = binaryParser.getInt();
            //     console.log(nSites);
            //     for(let s=0; s<nSites; s++) {
            //         chrSites.push(binaryParser.getInt());
            //     }
            // }

          }
        } // Build lookup table for well-known chr aliases


        this.chrAliasTable = {};

        for (let chrName of Object.keys(this.chromosomeIndexMap)) {
          if (chrName.startsWith("chr")) {
            this.chrAliasTable[chrName.substr(3)] = chrName;
          } else if (chrName === "MT") {
            this.chrAliasTable["chrM"] = chrName;
          } else {
            this.chrAliasTable["chr" + chrName] = chrName;
          }
        } // Meta data for the API


        this.meta = {
          "version": this.version,
          "genome": this.genomeId,
          "chromosomes": this.chromosomes,
          "resolutions": this.bpResolutions
        };
      }

      async readFooter() {
        const skip = this.version < 9 ? 8 : 12;
        let data = await this.file.read(this.footerPosition, skip);

        if (!data) {
          return null;
        }

        let binaryParser = new BinaryParser(new DataView(data));
        const nBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong(); // Total size, master index + expected values

        let nEntries = binaryParser.getInt(); // Estimate the size of the master index. String length of key is unknown, be conservative (100 bytes)

        const miSize = nEntries * (100 + 64 + 32);
        data = await this.file.read(this.footerPosition + skip, Math.min(miSize, nBytes));
        binaryParser = new BinaryParser(new DataView(data));
        this.masterIndex = {};

        while (nEntries-- > 0) {
          const key = binaryParser.getString();
          const pos = binaryParser.getLong();
          const size = binaryParser.getInt();
          this.masterIndex[key] = {
            start: pos,
            size: size
          };
        }

        this.expectedValueVectors = {}; // Expected values
        // const nExpValues = binaryParser.readInt();
        // while (nExpValues-- > 0) {
        //     type = "NONE";
        //     unit = binaryParser.getString();
        //     binSize = binaryParser.getInt();
        //     nValues = binaryParser.getInt();
        //     values = [];
        //     while (nValues-- > 0) {
        //         values.push(binaryParser.getDouble());
        //     }
        //
        //     nChrScaleFactors = binaryParser.getInt();
        //     normFactors = {};
        //     while (nChrScaleFactors-- > 0) {
        //         normFactors[binaryParser.getInt()] = binaryParser.getDouble();
        //     }
        //
        //     // key = unit + "_" + binSize + "_" + type;
        //     //  NOT USED YET SO DON'T STORE
        //     //  dataset.expectedValueVectors[key] =
        //     //      new ExpectedValueFunction(type, unit, binSize, values, normFactors);
        // }
        // normalized expected values start after expected value.  Add 4 for

        if (this.version > 5) {
          const skip = this.version < 9 ? 4 : 8;
          this.normExpectedValueVectorsPosition = this.footerPosition + skip + nBytes;
        }

        return this;
      }

      async printIndexStats() {
        let totalSize = 0;
        let maxSize = 0;
        let maxKey;
        await await this.init();

        for (let key of Object.keys(this.masterIndex)) {
          const entry = this.masterIndex[key]; //  console.log(`${key}\t${entry.start}\t${entry.size}`)

          totalSize += entry.size;

          if (entry.size > maxSize) {
            maxSize = entry.size;
            maxKey = key;
          }
        } // console.log(`Total size  = ${totalSize}`);


        console.log(`${maxSize}  ${maxKey}  ${this.config.url}`);
      }

      async getMatrix(chrIdx1, chrIdx2) {
        const key = Matrix.getKey(chrIdx1, chrIdx2);

        if (this.matrixCache.has(key)) {
          return this.matrixCache.get(key);
        } else {
          const matrix = await this.readMatrix(chrIdx1, chrIdx2);
          this.matrixCache.set(key, matrix);
          return matrix;
        }
      }

      async readMatrix(chrIdx1, chrIdx2) {
        await this.init();

        if (chrIdx1 > chrIdx2) {
          const tmp = chrIdx1;
          chrIdx1 = chrIdx2;
          chrIdx2 = tmp;
        }

        const key = Matrix.getKey(chrIdx1, chrIdx2);
        const idx = this.masterIndex[key];

        if (!idx) {
          return undefined;
        }

        const data = await this.file.read(idx.start, idx.size);

        if (!data) {
          return undefined;
        }

        return Matrix.parseMatrix(data, this.chromosomes);
      }

      async getContactRecords(normalization, region1, region2, units, binsize, allRecords = false) {
        await this.init();
        const idx1 = this.chromosomeIndexMap[this.getFileChrName(region1.chr)];
        const idx2 = this.chromosomeIndexMap[this.getFileChrName(region2.chr)];
        const transpose = idx1 > idx2 || idx1 === idx2 && region1.start >= region2.end;

        if (transpose) {
          const tmp = region1;
          region1 = region2;
          region2 = tmp;
        }

        const blocks = await this.getBlocks(region1, region2, units, binsize);

        if (!blocks || blocks.length === 0) {
          return [];
        }

        const contactRecords = [];
        const x1 = region1.start / binsize;
        const x2 = region1.end / binsize;
        const y1 = region2.start / binsize;
        const y2 = region2.end / binsize;
        const nvX1 = Math.floor(x1);
        const nvX2 = Math.ceil(x2);
        const nvY1 = Math.floor(y1);
        const nvY2 = Math.ceil(y2);

        for (let block of blocks) {
          if (block) {
            // An undefined block is most likely caused by a base pair range outside the chromosome
            let normVector1;
            let normVector2;
            let isNorm = normalization && normalization !== "NONE";
            const chr1 = this.getFileChrName(region1.chr);
            const chr2 = this.getFileChrName(region2.chr);

            if (isNorm) {
              const nv1 = await this.getNormalizationVector(normalization, chr1, units, binsize);
              const nv2 = chr1 === chr2 ? nv1 : await this.getNormalizationVector(normalization, chr2, units, binsize);

              if (nv1 && nv2) {
                normVector1 = await nv1.getValues(nvX1, nvX2);
                normVector2 = await nv2.getValues(nvY1, nvY2);
              } else {
                isNorm = false; // Raise message and switch pulldown
              }
            }

            for (let rec of block.records) {
              if (allRecords || rec.bin1 >= x1 && rec.bin1 < x2 && rec.bin2 >= y1 && rec.bin2 < y2) {
                if (isNorm) {
                  const x = rec.bin1;
                  const y = rec.bin2;
                  const nvnv = normVector1[x - nvX1] * normVector2[y - nvY1];

                  if (nvnv !== 0 && !isNaN(nvnv)) {
                    const counts = rec.counts / nvnv;
                    contactRecords.push(new ContactRecord(x, y, counts));
                  }
                } else {
                  contactRecords.push(rec);
                }
              }
            }
          }
        }

        return contactRecords;
      }

      async getBlocks(region1, region2, unit, binSize) {
        await this.init();
        const chr1 = this.getFileChrName(region1.chr);
        const chr2 = this.getFileChrName(region2.chr);
        const idx1 = this.chromosomeIndexMap[chr1];
        const idx2 = this.chromosomeIndexMap[chr2];

        if (idx1 === undefined) {
          console.log("No chromosome named: " + region1.chr);
          return [];
        }

        if (idx2 === undefined) {
          console.log("No chromosome named: " + region2.chr);
          return [];
        }

        const matrix = await this.getMatrix(idx1, idx2);

        if (!matrix) {
          console.log("No matrix for " + region1.chr + "-" + region2.chr);
          return [];
        }

        const zd = matrix.getZoomData(binSize, unit);

        if (!zd) {
          let msg = `No data avalailble for resolution: ${binSize}  for map ${region1.chr}-${region2.chr}`;
          throw new Error(msg);
        }

        const blockNumbers = zd.getBlockNumbers(region1, region2, this.version);
        const blocks = [];
        const blockNumbersToQuery = [];

        for (let num of blockNumbers) {
          if (this.blockCache.has(binSize, num)) {
            blocks.push(this.blockCache.get(binSize, num));
          } else {
            blockNumbersToQuery.push(num);
          }
        }

        const promises = blockNumbersToQuery.map(blockNumber => this.readBlock(blockNumber, zd));
        const newBlocks = await Promise.all(promises);

        for (let block of newBlocks) {
          if (block) {
            this.blockCache.set(binSize, block.blockNumber, block);
          }
        }

        return blocks.concat(newBlocks);
      }

      async readBlock(blockNumber, zd) {
        const idx = await zd.blockIndex.getBlockIndexEntry(blockNumber);

        if (!idx) {
          return undefined;
        } else {
          let data = await this.file.read(idx.filePosition, idx.size);

          if (!data) {
            return undefined;
          }

          const inflate = new Zlib.Inflate(new Uint8Array(data));
          const plain = inflate.decompress(); //var plain = zlib.inflateSync(Buffer.from(data))   //.decompress();

          data = plain.buffer;
          const parser = new BinaryParser(new DataView(data));
          const nRecords = parser.getInt();
          const records = [];

          if (this.version < 7) {
            for (let i = 0; i < nRecords; i++) {
              const binX = parser.getInt();
              const binY = parser.getInt();
              const counts = parser.getFloat();
              records.push(new ContactRecord(binX, binY, counts));
            }
          } else {
            const binXOffset = parser.getInt();
            const binYOffset = parser.getInt();
            const useFloatContact = parser.getByte() === 1;
            const useIntXPos = this.version < 9 ? false : parser.getByte() == 1;
            const useIntYPos = this.version < 9 ? false : parser.getByte() == 1;
            const type = parser.getByte();

            if (type === 1) {
              // List-of-rows representation
              const rowCount = useIntYPos ? parser.getInt() : parser.getShort();

              for (let i = 0; i < rowCount; i++) {
                const dy = useIntYPos ? parser.getInt() : parser.getShort();
                const binY = binYOffset + dy;
                const colCount = useIntXPos ? parser.getInt() : parser.getShort();

                for (let j = 0; j < colCount; j++) {
                  const dx = useIntXPos ? parser.getInt() : parser.getShort();
                  const binX = binXOffset + dx;
                  const counts = useFloatContact ? parser.getFloat() : parser.getShort();
                  records.push(new ContactRecord(binX, binY, counts));
                }
              }
            } else if (type == 2) {
              const nPts = parser.getInt();
              const w = parser.getShort();

              for (let i = 0; i < nPts; i++) {
                //int idx = (p.y - binOffset2) * w + (p.x - binOffset1);
                const row = Math.floor(i / w);
                const col = i - row * w;
                const bin1 = binXOffset + col;
                const bin2 = binYOffset + row;

                if (useFloatContact) {
                  const counts = parser.getFloat();

                  if (!isNaN(counts)) {
                    records.push(new ContactRecord(bin1, bin2, counts));
                  }
                } else {
                  const counts = parser.getShort();

                  if (counts != Short_MIN_VALUE) {
                    records.push(new ContactRecord(bin1, bin2, counts));
                  }
                }
              }
            } else {
              throw new Error("Unknown block type: " + type);
            }
          }

          return new Block(blockNumber, zd, records, idx);
        }
      }

      async hasNormalizationVector(type, chr, unit, binSize) {
        await this.init();
        let chrIdx;

        if (Number.isInteger(chr)) {
          chrIdx = chr;
        } else {
          const canonicalName = this.getFileChrName(chr);
          chrIdx = this.chromosomeIndexMap[canonicalName];
        }

        const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);
        const normVectorIndex = await this.getNormVectorIndex();
        return normVectorIndex && normVectorIndex[key];
      }

      async getNormalizationVector(type, chr, unit, binSize) {
        await this.init();
        let chrIdx;

        if (Number.isInteger(chr)) {
          chrIdx = chr;
        } else {
          const canonicalName = this.getFileChrName(chr);
          chrIdx = this.chromosomeIndexMap[canonicalName];
        }

        const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);

        if (this.normVectorCache.has(key)) {
          return this.normVectorCache.get(key);
        }

        const normVectorIndex = await this.getNormVectorIndex();

        if (!normVectorIndex) {
          console.log("Normalization vectors not present in this file");
          return undefined;
        }

        const idx = normVectorIndex[key];

        if (!idx) {
          // TODO -- alert in browsers
          console.log("Normalization option " + type + " not available at this resolution");
          return undefined;
        }

        const data = await this.file.read(idx.filePosition, 8);

        if (!data) {
          return undefined;
        }

        const parser = new BinaryParser(new DataView(data));
        const nValues = this.version < 9 ? parser.getInt() : parser.getLong();
        const dataType = this.version < 9 ? DOUBLE : FLOAT;
        const filePosition = this.version < 9 ? idx.filePosition + 4 : idx.filePosition + 8;
        const nv = new NormalizationVector(this.file, filePosition, nValues, dataType);
        this.normVectorCache.set(key, nv);
        return nv;
      }

      async getNormVectorIndex() {
        if (this.version < 6) {
          return undefined;
        }

        if (!this.normVectorIndex) {
          // If nvi is not supplied, try reading from remote lambda service
          if (!this.config.nvi && this.remote && this.url) {
            const url = new URL(this.url);
            const key = encodeURIComponent(url.hostname + url.pathname);
            const nviResponse = await crossFetch('https://t5dvc6kn3f.execute-api.us-east-1.amazonaws.com/dev/nvi/' + key);

            if (nviResponse.status === 200) {
              const nvi = await nviResponse.text();

              if (nvi) {
                this.config.nvi = nvi;
              }
            }
          }

          if (this.config.nvi) {
            const nviArray = decodeURIComponent(this.config.nvi).split(",");
            const range = {
              start: parseInt(nviArray[0]),
              size: parseInt(nviArray[1])
            };
            return this.readNormVectorIndex(range);
          } else {
            try {
              await this.readNormExpectedValuesAndNormVectorIndex();
              return this.normVectorIndex;
            } catch (e) {
              if (e.code === "416" || e.code === 416) {
                // This is expected if file does not contain norm vectors
                this.normExpectedValueVectorsPosition = undefined;
              } else {
                console.error(e);
              }
            }
          }
        }

        return this.normVectorIndex;
      }

      async getNormalizationOptions() {
        // Normalization options are computed as a side effect of loading the index.  A bit
        // ugly but alternatives are worse.
        await this.getNormVectorIndex();
        return this.normalizationTypes;
      }
      /**
       * Return a promise to load the normalization vector index
       *
       * @param dataset
       * @param range  -- file range {position, size}
       * @returns Promise for the normalization vector index
       */


      async readNormVectorIndex(range) {
        await this.init();
        this.normalizationVectorIndexRange = range;
        const data = await this.file.read(range.start, range.size);
        const binaryParser = new BinaryParser(new DataView(data));
        this.normVectorIndex = {};
        let nEntries = binaryParser.getInt();

        while (nEntries-- > 0) {
          this.parseNormVectorEntry(binaryParser);
        }

        return this.normVectorIndex;
      }
      /**
       * This function is used when the position of the norm vector index is unknown.  We must read through the expected
       * values to find the index
       *
       * @param dataset
       * @returns {Promise}
       */


      async readNormExpectedValuesAndNormVectorIndex() {
        await this.init();

        if (this.normExpectedValueVectorsPosition === undefined) {
          return;
        }

        const nviStart = await this.skipExpectedValues(this.normExpectedValueVectorsPosition);
        let byteCount = INT;
        let data = await this.file.read(nviStart, INT);

        if (data.byteLength === 0) {
          // This is possible if there are no norm vectors.  Its a legal v8 file, though uncommon
          return;
        }

        const binaryParser = new BinaryParser(new DataView(data));
        const nEntries = binaryParser.getInt();
        const sizeEstimate = nEntries * 30;
        const range = {
          start: nviStart + byteCount,
          size: sizeEstimate
        };
        data = await this.file.read(range.start, range.size);
        this.normalizedExpectedValueVectors = {};
        this.normVectorIndex = {}; // Recursively process entries

        await processEntries.call(this, nEntries, data);
        this.config.nvi = nviStart.toString() + "," + byteCount;

        async function processEntries(nEntries, data) {
          const binaryParser = new BinaryParser(new DataView(data));

          while (nEntries-- > 0) {
            if (binaryParser.available() < 100) {
              nEntries++; // Reset counter as entry is not processed

              byteCount += binaryParser.position;
              const sizeEstimate = Math.max(1000, nEntries * 30);
              const range = {
                start: nviStart + byteCount,
                size: sizeEstimate
              };
              const data = await this.file.read(range.start, range.size);
              return processEntries.call(this, nEntries, data);
            }

            this.parseNormVectorEntry(binaryParser);
          }

          byteCount += binaryParser.position;
        }
      }
      /**
       * This function is used when the position of the norm vector index is unknown.  We must read through the
       * normalized expected values to find the index
       *
       * @param dataset
       * @returns {Promise}
       */


      async skipExpectedValues(start) {
        const version = this.version;
        const file = new BufferedFile({
          file: this.file,
          size: 256000
        });
        const range = {
          start: start,
          size: INT
        };
        const data = await file.read(range.start, range.size);
        const binaryParser = new BinaryParser(new DataView(data));
        const nEntries = binaryParser.getInt(); // Total # of expected value chunks

        if (nEntries === 0) {
          return start + INT;
        } else {
          return parseNext(start + INT, nEntries);
        } // Skip 4 bytes for int


        async function parseNext(start, nEntries) {
          let range = {
            start: start,
            size: 500
          };
          let chunkSize = 0;
          let p0 = start;
          let data = await file.read(range.start, range.size);
          let binaryParser = new BinaryParser(new DataView(data));
          binaryParser.getString(); // type

          binaryParser.getString(); // unit

          binaryParser.getInt(); // binSize

          const nValues = version < 9 ? binaryParser.getInt() : binaryParser.getLong();
          chunkSize += binaryParser.position + nValues * (version < 9 ? DOUBLE : FLOAT);
          range = {
            start: start + chunkSize,
            size: INT
          };
          data = await file.read(range.start, range.size);
          binaryParser = new BinaryParser(new DataView(data));
          const nChrScaleFactors = binaryParser.getInt();
          chunkSize += INT + nChrScaleFactors * (INT + (version < 9 ? DOUBLE : FLOAT));
          nEntries--;

          if (nEntries === 0) {
            return p0 + chunkSize;
          } else {
            return parseNext(p0 + chunkSize, nEntries);
          }
        }
      }

      getZoomIndexForBinSize(binSize, unit) {
        unit = unit || "BP";
        let resolutionArray;

        if (unit === "BP") {
          resolutionArray = this.bpResolutions;
        } else if (unit === "FRAG") {
          resolutionArray = this.fragResolutions;
        } else {
          throw new Error("Invalid unit: " + unit);
        }

        for (let i = 0; i < resolutionArray.length; i++) {
          if (resolutionArray[i] === binSize) return i;
        }

        return -1;
      }

      parseNormVectorEntry(binaryParser) {
        const type = binaryParser.getString(); //15

        const chrIdx = binaryParser.getInt(); //4

        const unit = binaryParser.getString(); //3

        const binSize = binaryParser.getInt(); //4

        const filePosition = binaryParser.getLong(); //8

        const sizeInBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong(); //4:8

        const key = type + "_" + chrIdx + "_" + unit + "_" + binSize; // TODO -- why does this not work?  NormalizationVector.getNormalizationVectorKey(type, chrIdx, unit, binSize);

        if (!this.normalizationTypes.includes(type)) {
          this.normalizationTypes.push(type);
        }

        this.normVectorIndex[key] = {
          filePosition: filePosition,
          size: sizeInBytes
        };
      }

      getFileChrName(chrAlias) {
        if (this.chrAliasTable.hasOwnProperty(chrAlias)) {
          return this.chrAliasTable[chrAlias];
        } else {
          return chrAlias;
        }
      } // NOTE sties are not currently used
      // async getSites(chrName) {
      //     let sites = this.fragmentSitesCache[chrName];
      //     if (!sites) {
      //         if (this.fragmentSitesIndex) {
      //             const entry = self.fragmentSitesIndex[chrName];
      //             if (entry && entry.nSites > 0) {
      //                 sites = await this.readSites(entry.position, entry.nSites)
      //                 this.fragmentSitesCache[chrName] = sites;
      //             }
      //         }
      //     }
      //     return sites;
      // }
      //


    }

    function getNormalizationVectorKey(type, chrIdx, unit, resolution) {
      return type + "_" + chrIdx + "_" + unit + "_" + resolution;
    }

    function isGoogleDrive(url) {
      return url.indexOf("drive.google.com") >= 0 || url.indexOf("www.googleapis.com/drive") > 0;
    }

    class Block {
      constructor(blockNumber, zoomData, records, idx) {
        this.blockNumber = blockNumber;
        this.zoomData = zoomData;
        this.records = records;
        this.idx = idx;
      }

    }

    class BlockCache {
      constructor() {
        this.resolution = undefined;
        this.map = new LRU(6);
      }

      set(resolution, key, value) {
        if (this.resolution !== resolution) {
          this.map.clear();
        }

        this.resolution = resolution;
        this.map.set(key, value);
      }

      get(resolution, key) {
        return this.resolution === resolution ? this.map.get(key) : undefined;
      }

      has(resolution, key) {
        return this.resolution === resolution && this.map.has(key);
      }

    }

    class Straw {
      constructor(config) {
        this.config = config;
        this.hicFile = new HicFile(config);
      }

      async getMetaData() {
        return await this.hicFile.getMetaData();
      } //straw <NONE/VC/VC_SQRT/KR> <ile> <chr1>[:x1:x2] <chr2>[:y1:y2] <BP/FRAG> <binsize>


      async getContactRecords(normalization, region1, region2, units, binsize) {
        return this.hicFile.getContactRecords(normalization, region1, region2, units, binsize);
      }

      async getNormalizationOptions() {
        return this.hicFile.getNormalizationOptions();
      }

      async getNVI() {
        await this.hicFile.getNormVectorIndex();
        return this.hicFile.config.nvi;
      }

      async printIndexStats() {
        await this.hicFile.printIndexStats();
      }

      getFileChrName(chrAlias) {
        if (this.hicFile.chrAliasTable.hasOwnProperty(chrAlias)) {
          return this.hicFile.chrAliasTable[chrAlias];
        } else {
          return chrAlias;
        }
      }

    }

    /*
     * @author Jim Robinson Dec-2020
     */

    class IGVRemoteFile {
      constructor(args) {
        this.config = args;
        this.url = args.path || args.url;
      }

      async read(position, length) {
        const range = {
          start: position,
          size: length
        };
        return igvxhr.loadArrayBuffer(this.url, {
          range
        });
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2020 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    const knownGenomes = {
      "hg19": [249250621, 243199373, 198022430],
      "hg38": [248956422, 242193529, 198295559],
      "mm10": [195471971, 182113224, 160039680],
      "mm9": [197195432, 181748087, 159599783],
      "dm6": [23513712, 25286936, 28110227]
    };

    class Dataset {
      constructor(config) {
        this.straw = new Straw(config);
      }

      async init() {
        this.hicFile = this.straw.hicFile;
        await this.hicFile.init();
        this.normalizationTypes = ['NONE'];
        this.genomeId = this.hicFile.genomeId;
        this.chromosomes = this.hicFile.chromosomes;
        this.bpResolutions = this.hicFile.bpResolutions;
        this.wholeGenomeChromosome = this.hicFile.wholeGenomeChromosome;
        this.wholeGenomeResolution = this.hicFile.wholeGenomeResolution; // Attempt to determine genomeId if not recognized
        // if (!Object.keys(knownGenomes).includes(this.genomeId)) {

        const tmp = matchGenome(this.chromosomes);
        if (tmp) this.genomeId = tmp; //  }
      }

      async getContactRecords(normalization, region1, region2, units, binsize) {
        return this.straw.getContactRecords(normalization, region1, region2, units, binsize);
      }

      async hasNormalizationVector(type, chr, unit, binSize) {
        return this.straw.hicFile.hasNormalizationVector(type, chr, unit, binSize);
      }

      clearCaches() {
        this.colorScaleCache = {};
      }

      async getMatrix(chr1, chr2) {
        return this.hicFile.getMatrix(chr1, chr2);
      }

      getZoomIndexForBinSize(binSize, unit) {
        var i, resolutionArray;
        unit = unit || "BP";

        if (unit === "BP") {
          resolutionArray = this.bpResolutions;
        } else if (unit === "FRAG") {
          resolutionArray = this.fragResolutions;
        } else {
          throw new Error("Invalid unit: " + unit);
        }

        for (i = 0; i < resolutionArray.length; i++) {
          if (resolutionArray[i] === binSize) return i;
        }

        return -1;
      }

      getBinSizeForZoomIndex(zoomIndex, unit) {
        var resolutionArray;
        unit = unit || "BP";

        if (unit === "BP") {
          resolutionArray = this.bpResolutions;
        } else if (unit === "FRAG") {
          resolutionArray = this.fragResolutions;
        } else {
          throw new Error("Invalid unit: " + unit);
        }

        return resolutionArray[zoomIndex];
      }

      getChrIndexFromName(chrName) {
        var i;

        for (i = 0; i < this.chromosomes.length; i++) {
          if (chrName === this.chromosomes[i].name) return i;
        }

        return undefined;
      }

      compareChromosomes(otherDataset) {
        const chrs = this.chromosomes;
        const otherChrs = otherDataset.chromosomes;

        if (chrs.length !== otherChrs.length) {
          return false;
        }

        for (let i = 0; i < chrs.length; i++) {
          if (chrs[i].size !== otherChrs[i].size) {
            return false;
          }
        }

        return true;
      }

      isWholeGenome(chrIndex) {
        return this.wholeGenomeChromosome != null && this.wholeGenomeChromosome.index === chrIndex;
      }

      async getNormVectorIndex() {
        return this.hicFile.getNormVectorIndex();
      }

      async getNormalizationOptions() {
        return this.hicFile.getNormalizationOptions();
      }
      /**
       * Compare 2 datasets for compatibility.  Compatibility is defined as from the same assembly, even if
       * different IDs are used (e.g. GRCh38 vs hg38).
       *
       * Trust the ID for well-known assemblies (hg19, etc).  However, for others compare chromosome lengths
       * as its been observed that uniqueness of ID is not guaranteed.
       *
       * @param d1
       * @param d2
       */


      isCompatible(d2) {
        const id1 = this.genomeId;
        const id2 = d2.genomeId;
        return (id1 === "hg38" || id1 === "GRCh38") && (id2 === "hg38" || id2 === "GRCh38") || (id1 === "hg19" || id1 === "GRCh37") && (id2 === "hg19" || id2 === "GRCh37") || (id1 === "mm10" || id1 === "GRCm38") && (id2 === "mm10" || id2 === "GRCm38") || this.compareChromosomes(d2);
      }

      static async loadDataset(config) {
        // If this is a local file, use the "blob" field for straw
        if (config.url instanceof File) {
          config.blob = config.url;
          delete config.url;
        } else {
          // If this is a google url, add api KEY
          if (isGoogleURL(config.url)) {
            if (isGoogleDriveURL(config.url)) {
              config.url = driveDownloadURL(config.url);
            }

            const copy = Object.assign({}, config);
            config.file = new IGVRemoteFile(copy);
          }
        }

        const dataset = new Dataset(config);
        await dataset.init();
        dataset.url = config.url;
        return dataset;
      }

    }

    function matchGenome(chromosomes) {
      if (chromosomes.length < 4) return undefined;
      const keys = Object.keys(knownGenomes); // Find a candidate

      let candidate;

      for (let chr of chromosomes) {
        for (let key of keys) {
          if (knownGenomes[key].includes(chr.size)) {
            candidate = key;
            break;
          }
        }
      } // Confirm candidate


      if (candidate) {
        const chrSizes = new Set(chromosomes.map(chr => chr.size));

        for (let sz of knownGenomes[candidate]) {
          if (!chrSizes.has(sz)) {
            return undefined;
          }
        }

        return candidate;
      } else {
        return undefined;
      }
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    /**
     * @author Jim Robinson
     */

    /**
     *
     * @param id
     * @param chromosomes -- an array of hic.Chromosome objects.
     * @constructor
     */
    class Genome {
      constructor(id, chromosomes) {
        this.id = id;
        this.chromosomes = chromosomes;
        this.wgChromosomeNames = [];
        this.chromosomeLookupTable = {}; // Alias for size for igv compatibility

        this.genomeLength = 0;

        for (let c of this.chromosomes) {
          c.bpLength = c.size;

          if ('all' !== c.name.toLowerCase()) {
            this.genomeLength += c.size;
            this.wgChromosomeNames.push(c.name);
          }
        }
        /**
         * Maps chr aliases to the offical name.  Deals with
         * 1 <-> chr1,  chrM <-> MT,  IV <-> chr4, etc.
         * @param str
         */


        var chrAliasTable = {}; // The standard mappings

        for (let chromosome of chromosomes) {
          const name = chromosome.name;

          if (name.startsWith("arm_")) {
            //Special rule for aidenlab ad-hoc names for dMel
            const officialName = name.substring(4);
            chrAliasTable[officialName] = name;
            chrAliasTable["chr" + officialName] = name;
          } else {
            const alias = name.startsWith("chr") ? name.substring(3) : "chr" + name;
            chrAliasTable[alias] = name;
            if (name === "chrM") chrAliasTable["MT"] = "chrM";
            if (name === "MT") chrAliasTable["chrmM"] = "MT";
          }

          this.chromosomeLookupTable[name.toLowerCase()] = chromosome;
        }

        this.chrAliasTable = chrAliasTable;
      }

      getChromosomeName(str) {
        var chr = this.chrAliasTable[str];
        return chr ? chr : str;
      }

      getChromosome(str) {
        var chrname = this.getChromosomeName(str).toLowerCase();
        return this.chromosomeLookupTable[chrname];
      }

      /**
       * Return the genome coordinate for the give chromosome and position.
       */
      getGenomeCoordinate(chr, bp) {
        return this.getCumulativeOffset(chr.name) + bp;
      }

      getChromsosomeForCoordinate(bp) {
        var i = 0,
            offset = 0,
            l;

        for (i = 1; i < this.chromosomes.length; i++) {
          l = this.chromosomes[i].size;
          if (offset + l > bp) return this.chromosomes[i];
          offset += l;
        }

        return this.chromosomes[this.chromosomes.length - 1];
      }
      /**
       * Return the offset in genome coordinates (kb) of the start of the given chromosome
       */


      getCumulativeOffset(chr) {
        const queryChr = this.getChromosomeName(chr);

        if (this.cumulativeOffsets === undefined) {
          computeCumulativeOffsets.call(this);
        }

        return this.cumulativeOffsets[queryChr];
      } // Required for igv.js


      getGenomeLength() {
        return this.genomeLength;
      }

    }

    function computeCumulativeOffsets() {
      const cumulativeOffsets = {};
      let offset = 0; // Skip first chromosome (its chr all).

      for (let chromosome of this.chromosomes) {
        if (chromosome.name === 'all') continue;
        cumulativeOffsets[chromosome.name] = Math.floor(offset);
        offset += chromosome.size;
      }

      this.cumulativeOffsets = cumulativeOffsets;
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    class State {
      constructor(chr1, chr2, zoom, x, y, width, height, pixelSize, normalization) {
        if (Number.isNaN(pixelSize)) {
          pixelSize = 1;
        }

        if (chr1 !== undefined) {
          if (chr1 <= chr2) {
            this.chr1 = chr1;
            this.chr2 = chr2;
            this.x = x;
            this.y = y;
          } else {
            // Transpose
            this.chr1 = chr2;
            this.chr2 = chr1;
            this.x = y;
            this.y = x;
          }

          this.zoom = zoom;
          this.pixelSize = pixelSize;
          this.width = width;
          this.height = height;

          if ("undefined" === normalization) {
            console.log("No normalization defined !!!");
            normalization = undefined;
          }

          this.normalization = normalization;
        }
      }

      stringify() {
        if (this.normalization) {
          return `${this.chr1},${this.chr2},${this.zoom},${this.x},${this.y},${this.width},${this.height},${this.pixelSize},${this.normalization}`;
        } else {
          return `${this.chr1},${this.chr2},${this.zoom},${this.x},${this.y},${this.width},${this.height},${this.pixelSize}`;
        }
      }

      clone() {
        return Object.assign(new State(), this);
      }

      equals(state) {
        var s1 = JSON.stringify(this);
        var s2 = JSON.stringify(state);
        return s1 === s2;
      }

      static parse(string) {
        const tokens = string.split(",");

        if (tokens.length <= 7) {
          // Backwards compatibility
          return new State(parseInt(tokens[0]), // chr1
          parseInt(tokens[1]), // chr2
          parseFloat(tokens[2]), // zoom
          parseFloat(tokens[3]), // x
          parseFloat(tokens[4]), // y
          defaultSize.width, // width
          defaultSize.height, // height
          parseFloat(tokens[5]), // pixelSize
          tokens.length > 6 ? tokens[6] : "NONE" // normalization
          );
        } else {
          return new State(parseInt(tokens[0]), // chr1
          parseInt(tokens[1]), // chr2
          parseFloat(tokens[2]), // zoom
          parseFloat(tokens[3]), // x
          parseFloat(tokens[4]), // y
          parseInt(tokens[5]), // width
          parseInt(tokens[6]), // height
          parseFloat(tokens[7]), // pixelSize
          tokens.length > 8 ? tokens[8] : "NONE" // normalization
          );
        }
      }

      static default(configOrUndefined) {
        if (configOrUndefined) {
          return new State(0, 0, 0, 0, 0, configOrUndefined.width, configOrUndefined.height, 1, "NONE");
        } else {
          return new State(0, 0, 0, 0, 0, defaultSize.width, defaultSize.height, 1, "NONE");
        }
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    async function geneSearch(genomeId, featureName) {
      // Hardcode this for now
      const searchServiceURL = "https://portals.broadinstitute.org/webservices/igv/locus?genome=" + genomeId + "&name=" + featureName;
      const data = await igvxhr.loadString(searchServiceURL);
      var results = parseSearchResults(data);

      if (results.length === 0) {
        //alert('No feature found with name "' + feature + '"');
        return undefined;
      } else {
        // Just take first result for now
        return results[0];
      }
    }

    function parseSearchResults(data) {
      const lines = splitLines(data);
      const linesTrimmed = [];
      const results = [];

      for (let item of lines) {
        if ("" === item) ; else {
          linesTrimmed.push(item);
        }
      }

      for (let line of linesTrimmed) {
        // Example result -  EGFR	chr7:55,086,724-55,275,031	refseq
        const tokens = line.split("\t");

        if (tokens.length >= 3) {
          results.push(tokens[1]);
        }
      }

      return results;
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    class LocusGoto {
      constructor(browser, $hic_navbar_container) {
        this.browser = browser;
        const $parent = $hic_navbar_container.find("div[id$='upper-hic-nav-bar-widget-container']");
        this.$container = $("<div>", {
          class: 'hic-chromosome-goto-container',
          title: 'Chromosome Goto'
        });
        $parent.append(this.$container);
        this.$resolution_selector = $('<input type="text" placeholder="chr-x-axis chr-y-axis">');
        this.$container.append(this.$resolution_selector);
        this.$resolution_selector.on('change', function (e) {
          browser.parseGotoInput($(this).val());
          $(this).blur();
        });
        this.browser.eventBus.subscribe("LocusChange", this);
      }

      receiveEvent(event) {
        if (event.type === "LocusChange") {
          let xy;
          const state = event.data.state || this.browser.state;
          const isWholeGenome = this.browser.dataset.isWholeGenome(state.chr1);

          if (isWholeGenome) {
            xy = 'All';
          } else {
            const chr1 = this.browser.dataset.chromosomes[state.chr1];
            const chr2 = this.browser.dataset.chromosomes[state.chr2];
            const bpPerBin = this.browser.dataset.bpResolutions[state.zoom];
            const dimensionsPixels = this.browser.contactMatrixView.getViewDimensions();
            const pixelsPerBin = state.pixelSize;
            const startBP1 = 1 + Math.round(state.x * bpPerBin);
            const startBP2 = 1 + Math.round(state.y * bpPerBin);
            const endBP1 = Math.min(chr1.size, Math.round(dimensionsPixels.width / pixelsPerBin * bpPerBin) + startBP1 - 1);
            const endBP2 = Math.min(chr2.size, Math.round(dimensionsPixels.height / pixelsPerBin * bpPerBin) + startBP2 - 1);
            xy = chr1.name + ":" + numberFormatter(startBP1) + "-" + numberFormatter(endBP1) + " " + chr2.name + ":" + numberFormatter(startBP2) + "-" + numberFormatter(endBP2);
          }

          this.$resolution_selector.val(xy);
        }
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    class ResolutionSelector {
      constructor(browser, $hic_navbar_container) {
        this.browser = browser;
        const $parent = $hic_navbar_container.find("div[id$='upper-hic-nav-bar-widget-container']");
        this.$container = $("<div>", {
          class: 'hic-resolution-selector-container',
          title: 'Resolution'
        });
        $parent.append(this.$container); // label container

        this.$label_container = $('<div id="hic-resolution-label-container">');
        this.$container.append(this.$label_container); // Resolution (kb)

        this.$label = $("<div>");
        this.$label_container.append(this.$label);
        this.$label.text('Resolution (kb)');
        this.$label.hide(); // lock/unlock

        this.$resolution_lock = $('<i id="hic-resolution-lock" class="fa fa-unlock" aria-hidden="true">');
        this.$label_container.append(this.$resolution_lock);
        this.$label_container.on('click', () => {
          this.browser.resolutionLocked = !this.browser.resolutionLocked;
          this.setResolutionLock(this.browser.resolutionLocked);
        });
        this.$resolution_selector = $('<select name="select">');
        this.$container.append(this.$resolution_selector);
        this.$resolution_selector.attr('name', 'resolution_selector');
        this.$resolution_selector.on('change', () => {
          const zoomIndex = parseInt(this.$resolution_selector.val());
          this.browser.setZoom(zoomIndex);
        });
        this.browser.eventBus.subscribe("LocusChange", this);
        this.browser.eventBus.subscribe("MapLoad", this);
        this.browser.eventBus.subscribe("ControlMapLoad", this);
      }

      setResolutionLock(resolutionLocked) {
        this.$resolution_lock.removeClass(true === resolutionLocked ? 'fa-unlock' : 'fa-lock');
        this.$resolution_lock.addClass(true === resolutionLocked ? 'fa-lock' : 'fa-unlock');
      }

      receiveEvent(event) {
        const browser = this.browser;

        if (event.type === "LocusChange") {
          if (true === event.data.resolutionChanged) {
            browser.resolutionLocked = false;
            this.setResolutionLock(browser.resolutionLocked);
          }

          if (event.data.chrChanged !== false) {
            // Default true
            const isWholeGenome = browser.dataset.isWholeGenome(event.data.state.chr1);
            this.$label.text(isWholeGenome ? 'Resolution (mb)' : 'Resolution (kb)');
            updateResolutions.call(this, browser.state.zoom);
          } else {
            const selectedIndex = browser.state.zoom;
            this.$resolution_selector.find('option').filter(function (index) {
              return index === selectedIndex;
            }).prop('selected', true);
          }
        } else if (event.type === "MapLoad") {
          browser.resolutionLocked = false;
          this.setResolutionLock(false);
          updateResolutions.call(this, browser.state.zoom);
        } else if (event.type === "ControlMapLoad") {
          updateResolutions.call(this, browser.state.zoom);
        }

        async function updateResolutions(zoomIndex) {
          const resolutions = browser.isWholeGenome() ? [{
            index: 0,
            binSize: browser.dataset.wholeGenomeResolution
          }] : browser.getResolutions();
          let htmlString = '';

          for (let resolution of resolutions) {
            const binSize = resolution.binSize;
            const index = resolution.index;
            let divisor;
            let unit;

            if (binSize >= 1e6) {
              divisor = 1e6;
              unit = 'mb';
            } else if (binSize >= 1e3) {
              divisor = 1e3;
              unit = 'kb';
            } else {
              divisor = 1;
              unit = 'bp';
            }

            const pretty = numberFormatter(Math.round(binSize / divisor)) + ' ' + unit;
            const selected = zoomIndex === resolution.index;
            htmlString += '<option' + ' data-resolution=' + binSize.toString() + ' value=' + index + (selected ? ' selected' : '') + '>' + pretty + '</option>';
          }

          this.$resolution_selector.empty();
          this.$resolution_selector.append(htmlString);
        }
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    const defaultColorScaleConfig = {
      threshold: 2000,
      r: 255,
      g: 0,
      b: 0
    };

    class ColorScale {
      constructor(scale) {
        this.threshold = scale.threshold;
        this.r = scale.r;
        this.g = scale.g;
        this.b = scale.b;
        this.cache = [];
        this.nbins = 2000;
        this.binsize = this.threshold / this.nbins;
      }

      setThreshold(threshold) {
        this.threshold = threshold;
        this.cache = [];
        this.binsize = this.threshold / this.nbins;
      }

      getThreshold() {
        return this.threshold;
      }

      setColorComponents(components) {
        this.r = components.r;
        this.g = components.g;
        this.b = components.b;
        this.cache = [];
      }

      getColorComponents() {
        return {
          r: this.r,
          g: this.g,
          b: this.b
        };
      }

      equals(cs) {
        return JSON.stringify(this) === JSON.stringify(cs);
      }

      getColor(value) {
        const low = 0;
        const bin = Math.floor(Math.min(this.threshold, value) / this.binsize);

        if (undefined === this.cache[bin]) {
          const alpha = Math.floor(255 * (IGVMath.clamp(value, low, this.threshold) - low) / (this.threshold - low));
          this.cache[bin] = {
            red: this.r,
            green: this.g,
            blue: this.b,
            alpha,
            rgbaString: `rgba(${this.r},${this.g},${this.b}, ${alpha})`
          };
        }

        return this.cache[bin];
      }

      stringify() {
        return "" + this.threshold + ',' + this.r + ',' + this.g + ',' + this.b;
      }

      static parse(string) {
        var pnstr, ratioCS;

        if (string.startsWith("R:")) {
          pnstr = string.substring(2).split(":");
          ratioCS = new RatioColorScale(Number.parseFloat(pnstr[0]));
          ratioCS.positiveScale = foo(pnstr[1]);
          ratioCS.negativeScale = foo(pnstr[2]);
          return ratioCS;
        } else {
          return foo(string);
        }

        function foo(str) {
          var cs, tokens;
          tokens = str.split(",");
          cs = {
            threshold: tokens[0],
            r: tokens[1],
            g: tokens[2],
            b: tokens[3]
          };
          return new ColorScale(cs);
        }
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    const defaultRatioColorScaleConfig = {
      threshold: 5,
      positive: {
        r: 255,
        g: 0,
        b: 0
      },
      negative: {
        r: 0,
        g: 0,
        b: 255
      }
    };

    class RatioColorScale {
      constructor(threshold) {
        this.threshold = threshold;
        this.positiveScale = new ColorScale({
          threshold: Math.log(threshold),
          r: 255,
          g: 0,
          b: 0
        });
        this.negativeScale = new ColorScale({
          threshold: Math.log(threshold),
          r: 0,
          g: 0,
          b: 255
        });
      }

      setThreshold(threshold) {
        this.threshold = threshold;
        this.positiveScale.setThreshold(Math.log(threshold));
        this.negativeScale.setThreshold(Math.log(threshold));
      }

      getThreshold() {
        return this.threshold;
      }

      setColorComponents(components, plusOrMinus) {
        if ('-' === plusOrMinus) {
          return this.negativeScale.setColorComponents(components);
        } else {
          return this.positiveScale.setColorComponents(components);
        }
      }

      getColorComponents(plusOrMinus) {
        if ('-' === plusOrMinus) {
          return this.negativeScale.getColorComponents();
        } else {
          return this.positiveScale.getColorComponents();
        }
      }

      getColor(score) {
        var logScore = Math.log(score);

        if (logScore < 0) {
          return this.negativeScale.getColor(-logScore);
        } else {
          return this.positiveScale.getColor(logScore);
        }
      }

      stringify() {
        return "R:" + this.threshold + ":" + this.positiveScale.stringify() + ":" + this.negativeScale.stringify();
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    const DRAG_THRESHOLD = 2;
    const DOUBLE_TAP_DIST_THRESHOLD = 20;
    const DOUBLE_TAP_TIME_THRESHOLD = 300;
    const imageTileDimension = 685;

    class ContactMatrixView {
      constructor(browser, $viewport, sweepZoom, scrollbarWidget, colorScale, ratioColorScale, backgroundColor) {
        this.browser = browser;
        this.$viewport = $viewport;
        this.sweepZoom = sweepZoom;
        this.scrollbarWidget = scrollbarWidget; // Set initial color scales.  These might be overriden / adjusted via parameters

        this.colorScale = colorScale;
        this.ratioColorScale = ratioColorScale; // this.diffColorScale = new RatioColorScale(100, false);

        this.backgroundColor = backgroundColor;
        this.backgroundRGBString = IGVColor.rgbColor(backgroundColor.r, backgroundColor.g, backgroundColor.b);
        this.$canvas = $viewport.find('canvas');
        this.ctx = this.$canvas.get(0).getContext('2d');
        this.$fa_spinner = $viewport.find('.fa-spinner');
        this.spinnerCount = 0;
        this.$x_guide = $viewport.find("div[id$='-x-guide']");
        this.$y_guide = $viewport.find("div[id$='-y-guide']");
        this.displayMode = 'A';
        this.imageTileCache = {};
        this.imageTileCacheKeys = [];
        this.imageTileCacheLimit = 8; //8 is the minimum number required to support A/B cycling

        this.colorScaleThresholdCache = {};
        this.browser.eventBus.subscribe("NormalizationChange", this);
        this.browser.eventBus.subscribe("TrackLoad2D", this);
        this.browser.eventBus.subscribe("TrackState2D", this);
        this.browser.eventBus.subscribe("MapLoad", this);
        this.browser.eventBus.subscribe("ControlMapLoad", this);
        this.browser.eventBus.subscribe("ColorChange", this);
        this.drawsInProgress = new Set();
      }

      setBackgroundColor(rgb) {
        this.backgroundColor = rgb;
        this.backgroundRGBString = IGVColor.rgbColor(rgb.r, rgb.g, rgb.b);
        this.repaint();
      }

      stringifyBackgroundColor() {
        return `${this.backgroundColor.r},${this.backgroundColor.g},${this.backgroundColor.b}`;
      }

      static parseBackgroundColor(rgbString) {
        const [r, g, b] = rgbString.split(",").map(str => parseInt(str));
        return {
          r,
          g,
          b
        };
      }

      setColorScale(colorScale) {
        switch (this.displayMode) {
          case 'AOB':
          case 'BOA':
            this.ratioColorScale = colorScale;
            break;

          case 'AMB':
            this.diffColorScale = colorScale;
            break;

          default:
            this.colorScale = colorScale;
        }

        this.colorScaleThresholdCache[colorScaleKey(this.browser.state, this.displayMode)] = colorScale.threshold;
      }

      async setColorScaleThreshold(threshold) {
        this.getColorScale().setThreshold(threshold);
        this.colorScaleThresholdCache[colorScaleKey(this.browser.state, this.displayMode)] = threshold;
        this.imageTileCache = {};
        await this.update();
      }

      getColorScale() {
        switch (this.displayMode) {
          case 'AOB':
          case 'BOA':
            return this.ratioColorScale;

          case 'AMB':
            return this.diffColorScale;

          default:
            return this.colorScale;
        }
      }

      async setDisplayMode(mode) {
        this.displayMode = mode;
        this.clearImageCaches();
        await this.update();
      }

      clearImageCaches() {
        this.imageTileCache = {};
        this.imageTileCacheKeys = [];
      }

      getViewDimensions() {
        return {
          width: this.$viewport.width(),
          height: this.$viewport.height()
        };
      }

      async receiveEvent(event) {
        if ("MapLoad" === event.type || "ControlMapLoad" === event.type) {
          // Don't enable mouse actions until we have a dataset.
          if (!this.mouseHandlersEnabled) {
            this.addTouchHandlers(this.$viewport);
            this.addMouseHandlers(this.$viewport);
            this.mouseHandlersEnabled = true;
          }

          this.clearImageCaches();
          this.colorScaleThresholdCache = {};
        } else {
          if (!("LocusChange" === event.type)) {
            this.clearImageCaches();
          }

          this.update();
        }
      }

      async update() {
        if (this.disableUpdates) return; // This flag is set during browser startup

        await this.repaint();
      }

      async repaint() {
        if (!this.browser.dataset) {
          return;
        }

        const viewportWidth = this.$viewport.width();
        const viewportHeight = this.$viewport.height();
        const canvasWidth = this.$canvas.width();
        const canvasHeight = this.$canvas.height();

        if (canvasWidth !== viewportWidth || canvasHeight !== viewportHeight) {
          this.$canvas.width(viewportWidth);
          this.$canvas.height(viewportHeight);
          this.$canvas.attr('width', this.$viewport.width());
          this.$canvas.attr('height', this.$viewport.height());
        }

        const browser = this.browser;
        const state = browser.state;
        let ds;
        let dsControl;
        let zdControl;
        let zoom;
        let controlZoom;

        switch (this.displayMode) {
          case 'A':
            zoom = state.zoom;
            ds = this.browser.dataset;
            break;

          case 'B':
            zoom = getBZoomIndex(state.zoom);
            ds = this.browser.controlDataset;
            break;

          case 'AOB':
          case 'AMB':
            zoom = state.zoom;
            controlZoom = getBZoomIndex(state.zoom);
            ds = this.browser.dataset;
            dsControl = this.browser.controlDataset;
            break;

          case 'BOA':
            zoom = getBZoomIndex(state.zoom);
            controlZoom = state.zoom;
            ds = this.browser.controlDataset;
            dsControl = this.browser.dataset;
        }

        const matrix = await ds.getMatrix(state.chr1, state.chr2);
        const unit = "BP"; // FRAG is not supported

        const zd = matrix.getZoomDataByIndex(zoom, unit);

        if (dsControl) {
          const matrixControl = await dsControl.getMatrix(state.chr1, state.chr2);
          zdControl = matrixControl.getZoomDataByIndex(controlZoom, unit);
        }

        const pixelSizeInt = Math.max(1, Math.floor(state.pixelSize));
        const widthInBins = this.$viewport.width() / pixelSizeInt;
        const heightInBins = this.$viewport.height() / pixelSizeInt;
        const blockCol1 = Math.floor(state.x / imageTileDimension);
        const blockCol2 = Math.floor((state.x + widthInBins) / imageTileDimension);
        const blockRow1 = Math.floor(state.y / imageTileDimension);
        const blockRow2 = Math.floor((state.y + heightInBins) / imageTileDimension);

        if ("NONE" !== state.normalization) {
          if (!ds.hasNormalizationVector(state.normalization, zd.chr1.name, zd.zoom.unit, zd.zoom.binSize)) {
            Alert.presentAlert("Normalization option " + normalization + " unavailable at this resolution.");
            this.browser.eventBus.post(new HICEvent("NormalizationExternalChange", "NONE"));
            state.normalization = "NONE";
          }
        }

        await this.checkColorScale(ds, zd, blockRow1, blockRow2, blockCol1, blockCol2, state.normalization);
        this.ctx.clearRect(0, 0, viewportWidth, viewportHeight);

        for (let r = blockRow1; r <= blockRow2; r++) {
          for (let c = blockCol1; c <= blockCol2; c++) {
            const tile = await this.getImageTile(ds, dsControl, zd, zdControl, r, c, state);

            if (tile.image) {
              this.paintTile(tile);
            }
          }
        } // Record genomic extent of current canvas


        this.genomicExtent = {
          chr1: state.chr1,
          chr2: state.chr2,
          x: state.x * zd.zoom.binSize,
          y: state.y * zd.zoom.binSize,
          w: viewportWidth * zd.zoom.binSize / state.pixelSize,
          h: viewportHeight * zd.zoom.binSize / state.pixelSize
        };

        function getBZoomIndex(zoom) {
          const binSize = browser.dataset.getBinSizeForZoomIndex(zoom);

          if (!binSize) {
            throw Error("Invalid zoom (resolution) index: " + zoom);
          }

          const bZoom = browser.controlDataset.getZoomIndexForBinSize(binSize);

          if (bZoom < 0) {
            throw Error(`Invalid binSize for "B" map: ${binSize}`);
          }

          return bZoom;
        }
      }
      /**
       * This is where the image tile is actually drawn, if not in the cache
       *
       * @param ds
       * @param dsControl
       * @param zd
       * @param zdControl
       * @param row
       * @param column
       * @param state
       * @returns {Promise<{image: HTMLCanvasElement, column: *, row: *, blockBinCount}|{image, inProgress: boolean, column: *, row: *, blockBinCount}|*>}
       */


      async getImageTile(ds, dsControl, zd, zdControl, row, column, state) {
        const key = `${zd.chr1.name}_${zd.chr2.name}_${zd.zoom.binSize}_${zd.zoom.unit}_${row}_${column}_${state.normalization}_${this.displayMode}`;

        if (this.imageTileCache.hasOwnProperty(key)) {
          return this.imageTileCache[key];
        } else {
          if (this.drawsInProgress.has(key)) {
            //console.log("In progress")
            const imageSize = imageTileDimension;
            const image = inProgressTile(imageSize);
            return {
              row: row,
              column: column,
              blockBinCount: imageTileDimension,
              image: image,
              inProgress: true
            }; // TODO return an image at a coarser resolution if avaliable
          }

          this.drawsInProgress.add(key);

          try {
            this.startSpinner();
            const sameChr = zd.chr1.index === zd.chr2.index;
            const transpose = sameChr && row < column;
            const averageCount = zd.averageCount;
            const ctrlAverageCount = zdControl ? zdControl.averageCount : 1;
            const averageAcrossMapAndControl = (averageCount + ctrlAverageCount) / 2;
            const imageSize = imageTileDimension;
            const image = document.createElement('canvas');
            image.width = imageSize;
            image.height = imageSize;
            const ctx = image.getContext('2d'); //ctx.clearRect(0, 0, image.width, image.height);
            // Get blocks

            const widthInBP = imageTileDimension * zd.zoom.binSize;
            const x0bp = column * widthInBP;
            const region1 = {
              chr: zd.chr1.name,
              start: x0bp,
              end: x0bp + widthInBP
            };
            const y0bp = row * widthInBP;
            const region2 = {
              chr: zd.chr2.name,
              start: y0bp,
              end: y0bp + widthInBP
            };
            const records = await ds.getContactRecords(state.normalization, region1, region2, zd.zoom.unit, zd.zoom.binSize);
            let cRecords;

            if (zdControl) {
              cRecords = await dsControl.getContactRecords(state.normalization, region1, region2, zdControl.zoom.unit, zdControl.zoom.binSize);
            }

            if (records.length > 0) {
              const controlRecords = {};

              if ('AOB' === this.displayMode || 'BOA' === this.displayMode || 'AMB' === this.displayMode) {
                for (let record of cRecords) {
                  controlRecords[record.getKey()] = record;
                }
              }

              let id = ctx.getImageData(0, 0, image.width, image.height);
              const x0 = transpose ? row * imageTileDimension : column * imageTileDimension;
              const y0 = transpose ? column * imageTileDimension : row * imageTileDimension;

              for (let i = 0; i < records.length; i++) {
                const rec = records[i];
                let x = Math.floor(rec.bin1 - x0);
                let y = Math.floor(rec.bin2 - y0);

                if (transpose) {
                  const t = y;
                  y = x;
                  x = t;
                }

                let rgba;

                switch (this.displayMode) {
                  case 'AOB':
                  case 'BOA':
                    let key = rec.getKey();
                    let controlRec = controlRecords[key];

                    if (!controlRec) {
                      continue; // Skip
                    }

                    let score = rec.counts / averageCount / (controlRec.counts / ctrlAverageCount);
                    rgba = this.ratioColorScale.getColor(score);
                    break;

                  case 'AMB':
                    key = rec.getKey();
                    controlRec = controlRecords[key];

                    if (!controlRec) {
                      continue; // Skip
                    }

                    score = averageAcrossMapAndControl * (rec.counts / averageCount - controlRec.counts / ctrlAverageCount);
                    rgba = this.diffColorScale.getColor(score);
                    break;

                  default:
                    // Either 'A' or 'B'
                    rgba = this.colorScale.getColor(rec.counts);
                } // TODO -- verify that this bitblting is faster than fillRect


                setPixel(id, x, y, rgba.red, rgba.green, rgba.blue, rgba.alpha);

                if (sameChr && row === column) {
                  setPixel(id, y, x, rgba.red, rgba.green, rgba.blue, rgba.alpha);
                }
              }

              ctx.putImageData(id, 0, 0);
            } else {//console.log("No block for " + blockNumber);
            } //Draw 2D tracks


            ctx.save();
            ctx.lineWidth = 2;

            for (let track2D of this.browser.tracks2D) {
              if (track2D.isVisible) {
                const chr1Name = zd.chr1.name;
                const chr2Name = zd.chr2.name;
                const features = track2D.getFeatures(chr1Name, chr2Name);

                if (features) {
                  for (let {
                    chr1,
                    x1,
                    x2,
                    y1,
                    y2,
                    color
                  } of features) {
                    // Chr name order
                    const flip = chr1Name !== chr1;
                    const fx1 = transpose || flip ? y1 : x1;
                    const fx2 = transpose || flip ? y2 : x2;
                    const fy1 = transpose || flip ? x1 : y1;
                    const fy2 = transpose || flip ? x2 : y2;
                    let px1 = (fx1 - x0bp) / zd.zoom.binSize;
                    let px2 = (fx2 - x0bp) / zd.zoom.binSize;
                    let py1 = (fy1 - y0bp) / zd.zoom.binSize;
                    let py2 = (fy2 - y0bp) / zd.zoom.binSize;
                    let w = px2 - px1;
                    let h = py2 - py1;
                    const dim = Math.max(image.width, image.height);

                    if (px2 > 0 && px1 < dim && py2 > 0 && py1 < dim) {
                      //console.log(`${row} ${column}    ${x1} ${x2}`)
                      ctx.strokeStyle = track2D.color ? track2D.color : color;
                      ctx.strokeRect(px1, py1, w, h);

                      if (sameChr && row === column) {
                        ctx.strokeRect(py1, px1, h, w);
                      }
                    }
                  }
                }
              }
            }

            ctx.restore(); // Uncomment to reveal tile boundaries for debugging.
            //  ctx.fillStyle = "rgb(255,255,255)";
            //  ctx.strokeRect(0, 0, image.width - 1, image.height - 1)

            var imageTile = {
              row: row,
              column: column,
              blockBinCount: imageTileDimension,
              image: image
            };

            if (this.imageTileCacheLimit > 0) {
              if (this.imageTileCacheKeys.length > this.imageTileCacheLimit) {
                delete this.imageTileCache[this.imageTileCacheKeys[0]];
                this.imageTileCacheKeys.shift();
              }

              this.imageTileCache[key] = imageTile;
            }

            return imageTile;
          } finally {
            //console.log("Finish load for " + key)
            this.drawsInProgress.delete(key);
            this.stopSpinner();
          }
        }

        function setPixel(imageData, x, y, r, g, b, a) {
          const index = (x + y * imageData.width) * 4;
          imageData.data[index + 0] = r;
          imageData.data[index + 1] = g;
          imageData.data[index + 2] = b;
          imageData.data[index + 3] = a;
        }
      }

      /**
       * Return a promise to adjust the color scale, if needed.  This function might need to load the contact
       * data to computer scale.
       *
       * @param zd
       * @param row1
       * @param row2
       * @param col1
       * @param col2
       * @param normalization
       * @returns {*}
       */
      async checkColorScale(ds, zd, row1, row2, col1, col2, normalization) {
        const colorKey = colorScaleKey(this.browser.state, this.displayMode); // This doesn't feel right, state should be an argument

        if ('AOB' === this.displayMode || 'BOA' === this.displayMode) {
          return this.ratioColorScale; // Don't adjust color scale for A/B.
        }

        if (this.colorScaleThresholdCache[colorKey]) {
          const changed = this.colorScale.threshold !== this.colorScaleThresholdCache[colorKey];
          this.colorScale.setThreshold(this.colorScaleThresholdCache[colorKey]);

          if (changed) {
            this.browser.eventBus.post(HICEvent("ColorScale", this.colorScale));
          }

          return this.colorScale;
        } else {
          try {
            const widthInBP = imageTileDimension * zd.zoom.binSize;
            const x0bp = col1 * widthInBP;
            const xWidthInBP = (col2 - col1 + 1) * widthInBP;
            const region1 = {
              chr: zd.chr1.name,
              start: x0bp,
              end: x0bp + xWidthInBP
            };
            const y0bp = row1 * widthInBP;
            const yWidthInBp = (row2 - row1 + 1) * widthInBP;
            const region2 = {
              chr: zd.chr2.name,
              start: y0bp,
              end: y0bp + yWidthInBp
            };
            const records = await ds.getContactRecords(normalization, region1, region2, zd.zoom.unit, zd.zoom.binSize, true);
            let s = computePercentile(records, 95);

            if (!isNaN(s)) {
              // Can return NaN if all blocks are empty
              if (0 === zd.chr1.index) s *= 4; // Heuristic for whole genome view

              this.colorScale = new ColorScale(this.colorScale);
              this.colorScale.setThreshold(s);
              this.computeColorScale = false;
              this.browser.eventBus.post(HICEvent("ColorScale", this.colorScale));
              this.colorScaleThresholdCache[colorKey] = s;
            }

            return this.colorScale;
          } finally {
            this.stopSpinner();
          }
        }
      }

      async zoomIn() {
        const state = this.browser.state;
        const viewportWidth = this.$viewport.width();
        const viewportHeight = this.$viewport.height();
        const matrices = await getMatrices.call(this, state.chr1, state.chr2);
        var matrix = matrices[0];

        if (matrix) {
          const unit = "BP";
          const zd = await matrix.getZoomDataByIndex(state.zoom, unit);
          const newGenomicExtent = {
            x: state.x * zd.zoom.binSize,
            y: state.y * zd.zoom.binSize,
            w: viewportWidth * zd.zoom.binSize / state.pixelSize,
            h: viewportHeight * zd.zoom.binSize / state.pixelSize
          }; // Zoom out not supported

          if (newGenomicExtent.w > this.genomicExtent.w) return;
          const sx = (newGenomicExtent.x - this.genomicExtent.x) / this.genomicExtent.w * viewportWidth;
          const sy = (newGenomicExtent.y - this.genomicExtent.y) / this.genomicExtent.w * viewportHeight;
          const sWidth = newGenomicExtent.w / this.genomicExtent.w * viewportWidth;
          const sHeight = newGenomicExtent.h / this.genomicExtent.h * viewportHeight;
          const img = this.$canvas[0];
          const backCanvas = document.createElement('canvas');
          backCanvas.width = img.width;
          backCanvas.height = img.height;
          const backCtx = backCanvas.getContext('2d');
          backCtx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, viewportWidth, viewportHeight);
          this.ctx.clearRect(0, 0, viewportWidth, viewportHeight);
          this.ctx.drawImage(backCanvas, 0, 0);
        }
      }

      paintTile(_ref) {
        let {
          image,
          row,
          column,
          blockBinCount
        } = _ref;
        const x0 = blockBinCount * column;
        const y0 = blockBinCount * row;
        const {
          x,
          y,
          pixelSize
        } = this.browser.state; //const pixelSizeInt = Math.max(1, Math.floor(pixelSize))

        const offsetX = (x0 - x) * pixelSize;
        const offsetY = (y0 - y) * pixelSize;
        const scale = pixelSize; // / pixelSizeInt

        const scaledWidth = image.width * scale;
        const scaledHeight = image.height * scale;
        const viewportWidth = this.$viewport.width();
        const viewportHeight = this.$viewport.height();

        if (offsetX <= viewportWidth && offsetX + scaledWidth >= 0 && offsetY <= viewportHeight && offsetY + scaledHeight >= 0) {
          this.ctx.fillStyle = this.backgroundRGBString;
          this.ctx.fillRect(offsetX, offsetY, scaledWidth, scaledHeight);

          if (scale === 1) {
            this.ctx.drawImage(image, offsetX, offsetY);
          } else {
            this.ctx.drawImage(image, offsetX, offsetY, scaledWidth, scaledHeight);
          } // Debugging aid, uncomment to see tile boundaries
          //this.ctx.strokeRect(offsetX, offsetY, scaledWidth, scaledHeight)
          //this.ctx.strokeText(`${row} ${column}`, offsetX, offsetY);

        }
      }

      startSpinner() {
        if (true === this.browser.isLoadingHICFile && this.browser.$user_interaction_shield) {
          this.browser.$user_interaction_shield.show();
        }

        this.$fa_spinner.css("display", "inline-block");
        this.spinnerCount++;
      }

      stopSpinner() {
        this.spinnerCount--;

        if (0 === this.spinnerCount) {
          this.$fa_spinner.css("display", "none");
        }

        this.spinnerCount = Math.max(0, this.spinnerCount); // This should not be neccessary
      }

      addMouseHandlers($viewport) {
        let isMouseDown = false;
        let isSweepZooming = false;
        let mouseDown;
        let mouseLast;
        let mouseOver;

        const panMouseUpOrMouseOut = e => {
          if (true === this.isDragging) {
            this.isDragging = false;
            this.browser.eventBus.post(HICEvent("DragStopped"));
          }

          isMouseDown = false;
          mouseDown = mouseLast = undefined;
        }; // function shiftCurrentImage(self, dx, dy) {
        //     var canvasWidth = self.$canvas.width(),
        //         canvasHeight = self.$canvas.height(),
        //         imageData;
        //
        //     imageData = self.ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        //     self.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        //     self.ctx.putImageData(imageData, dx, dy);
        // }
        //
        // function mouseWheelHandler(e) {
        //     e.preventDefault();
        //     e.stopPropagation();
        //
        //     const t = Date.now();
        //     if (lastWheelTime === undefined || (t - lastWheelTime > 1000)) {
        //         // cross-browser wheel delta  -- Firefox returns a "detail" object that is opposite in sign to wheelDelta
        //         var direction = e.deltaY < 0 ? 1 : -1,
        //             coords = DOMUtils.translateMouseCoordinates(e, $viewport[0]),
        //             x = coords.x,
        //             y = coords.y;
        //         self.browser.wheelClickZoom(direction, x, y);
        //         lastWheelTime = t;
        //     }
        // }


        this.isDragging = false;

        if (!this.browser.isMobile) {
          $viewport.dblclick(e => {
            e.preventDefault();
            e.stopPropagation();
            const mouseX = e.offsetX || e.layerX;
            const mouseY = e.offsetY || e.layerX;
            this.browser.zoomAndCenter(1, mouseX, mouseY);
          });
          $viewport.on('mouseover', e => mouseOver = true);
          $viewport.on('mouseout', e => mouseOver = undefined);
          $viewport.on('mousedown', e => {
            e.preventDefault();
            e.stopPropagation();

            if (this.browser.$menu.is(':visible')) {
              this.browser.hideMenu();
            }

            mouseLast = {
              x: e.offsetX,
              y: e.offsetY
            };
            mouseDown = {
              x: e.offsetX,
              y: e.offsetY
            };
            isSweepZooming = true === e.altKey;

            if (isSweepZooming) {
              const eFixed = $.event.fix(e);
              this.sweepZoom.initialize({
                x: eFixed.pageX,
                y: eFixed.pageY
              });
            }

            isMouseDown = true;
          });
          $viewport.on('mousemove', e => {
            e.preventDefault();
            e.stopPropagation();
            const coords = {
              x: e.offsetX,
              y: e.offsetY
            }; // Sets pageX and pageY for browsers that don't support them

            const eFixed = $.event.fix(e);
            const xy = {
              x: eFixed.pageX - $viewport.offset().left,
              y: eFixed.pageY - $viewport.offset().top
            };
            const {
              width,
              height
            } = $viewport.get(0).getBoundingClientRect();
            xy.xNormalized = xy.x / width;
            xy.yNormalized = xy.y / height;
            this.browser.eventBus.post(HICEvent("UpdateContactMapMousePosition", xy, false));

            if (true === this.willShowCrosshairs) {
              this.browser.updateCrosshairs(xy);
              this.browser.showCrosshairs();
            }

            if (isMouseDown) {
              // Possibly dragging
              if (isSweepZooming) {
                this.sweepZoom.update({
                  x: eFixed.pageX,
                  y: eFixed.pageY
                });
              } else if (mouseDown.x && Math.abs(coords.x - mouseDown.x) > DRAG_THRESHOLD) {
                this.isDragging = true;
                const dx = mouseLast.x - coords.x;
                const dy = mouseLast.y - coords.y; // If matrix data is updating shift current map image while we wait
                //if (this.updating) {
                //    shiftCurrentImage(this, -dx, -dy);
                //}

                this.browser.shiftPixels(dx, dy);
              }

              mouseLast = coords;
            }
          });
          $viewport.on('mouseup', panMouseUpOrMouseOut);
          $viewport.on('mouseleave', () => {
            this.browser.layoutController.xAxisRuler.unhighlightWholeChromosome();
            this.browser.layoutController.yAxisRuler.unhighlightWholeChromosome();
            panMouseUpOrMouseOut();
          }); // Mousewheel events -- ie exposes event only via addEventListener, no onwheel attribute
          // NOte from spec -- trackpads commonly map pinch to mousewheel + ctrl
          // $viewport[0].addEventListener("wheel", mouseWheelHandler, 250, false);
          // document level events

          $(document).on('keydown.contact_matrix_view', e => {
            if (undefined === this.willShowCrosshairs && true === mouseOver && true === e.shiftKey) {
              this.willShowCrosshairs = true;
              this.browser.eventBus.post(HICEvent('DidShowCrosshairs', 'DidShowCrosshairs', false));
            }
          });
          $(document).on('keyup.contact_matrix_view', e => {
            this.browser.hideCrosshairs();
            this.willShowCrosshairs = undefined;
            this.browser.eventBus.post(HICEvent('DidHideCrosshairs', 'DidHideCrosshairs', false));
          }); // for sweep-zoom allow user to sweep beyond viewport extent
          // sweep area clamps since viewport mouse handlers stop firing
          // when the viewport boundary is crossed.

          $(document).on('mouseup.contact_matrix_view', e => {
            e.preventDefault();
            e.stopPropagation();

            if (isSweepZooming) {
              isSweepZooming = false;
              this.sweepZoom.commit();
            }
          });
        }
      }
      /**
       * Add touch handlers.  Touches are mapped to one of the following application level events
       *  - double tap, equivalent to double click
       *  - move
       *  - pinch
       *
       * @param $viewport
       */


      addTouchHandlers($viewport) {
        let lastTouch, pinch;
        const viewport = $viewport[0];
        /**
         * Touch start -- 3 possibilities
         *   (1) beginning of a drag (pan)
         *   (2) first tap of a double tap
         *   (3) beginning of a pinch
         */

        viewport.ontouchstart = ev => {
          ev.preventDefault();
          ev.stopPropagation();
          var touchCoords = translateTouchCoordinates(ev.targetTouches[0], viewport),
              offsetX = touchCoords.x,
              offsetY = touchCoords.y,
              count = ev.targetTouches.length,
              timeStamp = ev.timeStamp || Date.now(),
              resolved = false,
              dx,
              dy,
              dist,
              direction;

          if (count === 2) {
            touchCoords = translateTouchCoordinates(ev.targetTouches[0], viewport);
            offsetX = (offsetX + touchCoords.x) / 2;
            offsetY = (offsetY + touchCoords.y) / 2;
          } // NOTE: If the user makes simultaneous touches, the browser may fire a
          // separate touchstart event for each touch point. Thus if there are
          // two simultaneous touches, the first touchstart event will have
          // targetTouches length of one and the second event will have a length
          // of two.  In this case replace previous touch with this one and return


          if (lastTouch && timeStamp - lastTouch.timeStamp < DOUBLE_TAP_TIME_THRESHOLD && ev.targetTouches.length > 1 && lastTouch.count === 1) {
            lastTouch = {
              x: offsetX,
              y: offsetY,
              timeStamp: timeStamp,
              count: ev.targetTouches.length
            };
            return;
          }

          if (lastTouch && timeStamp - lastTouch.timeStamp < DOUBLE_TAP_TIME_THRESHOLD) {
            direction = lastTouch.count === 2 || count === 2 ? -1 : 1;
            dx = lastTouch.x - offsetX;
            dy = lastTouch.y - offsetY;
            dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < DOUBLE_TAP_DIST_THRESHOLD) {
              this.browser.zoomAndCenter(direction, offsetX, offsetY);
              lastTouch = undefined;
              resolved = true;
            }
          }

          if (!resolved) {
            lastTouch = {
              x: offsetX,
              y: offsetY,
              timeStamp: timeStamp,
              count: ev.targetTouches.length
            };
          }
        };

        viewport.ontouchmove = throttle(ev => {
          var touchCoords1, touchCoords2, t;
          ev.preventDefault();
          ev.stopPropagation();

          if (ev.targetTouches.length === 2) {
            // Update pinch  (assuming 2 finger movement is a pinch)
            touchCoords1 = translateTouchCoordinates(ev.targetTouches[0], viewport);
            touchCoords2 = translateTouchCoordinates(ev.targetTouches[1], viewport);
            t = {
              x1: touchCoords1.x,
              y1: touchCoords1.y,
              x2: touchCoords2.x,
              y2: touchCoords2.y
            };

            if (pinch) {
              pinch.end = t;
            } else {
              pinch = {
                start: t
              };
            }
          } else {
            // Assuming 1 finger movement is a drag
            var touchCoords = translateTouchCoordinates(ev.targetTouches[0], viewport),
                offsetX = touchCoords.x,
                offsetY = touchCoords.y;

            if (lastTouch) {
              var dx = lastTouch.x - offsetX,
                  dy = lastTouch.y - offsetY;

              if (!isNaN(dx) && !isNaN(dy)) {
                this.isDragging = true;
                this.browser.shiftPixels(lastTouch.x - offsetX, lastTouch.y - offsetY);
              }
            }

            lastTouch = {
              x: offsetX,
              y: offsetY,
              timeStamp: ev.timeStamp || Date.now(),
              count: ev.targetTouches.length
            };
          }
        }, 50);

        viewport.ontouchend = ev => {
          ev.preventDefault();
          ev.stopPropagation();

          if (pinch && pinch.end !== undefined) {
            var startT = pinch.start,
                endT = pinch.end,
                dxStart = startT.x2 - startT.x1,
                dyStart = startT.y2 - startT.y1,
                dxEnd = endT.x2 - endT.x1,
                dyEnd = endT.y2 - endT.y1,
                distStart = Math.sqrt(dxStart * dxStart + dyStart * dyStart),
                distEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd),
                scale = distEnd / distStart;
                (endT.x1 + endT.x2) / 2 - (startT.x1 + startT.x2) / 2;
                (endT.y1 + endT.y2) / 2 - (startT.y1 + startT.y2) / 2;
                var anchorPx = (startT.x1 + startT.x2) / 2,
                anchorPy = (startT.y1 + startT.y2) / 2;

            if (scale < 0.8 || scale > 1.2) {
              lastTouch = undefined;
              this.browser.pinchZoom(anchorPx, anchorPy, scale);
            }
          } else if (this.isDragging) {
            this.isDragging = false;
            this.browser.eventBus.post(HICEvent("DragStopped"));
          } // a touch end always ends a pinch


          pinch = undefined;
        };

        function translateTouchCoordinates(e, target) {
          var $target = $(target),
              posx,
              posy;
          posx = e.pageX - $target.offset().left;
          posy = e.pageY - $target.offset().top;
          return {
            x: posx,
            y: posy
          };
        }
      }

    }

    ContactMatrixView.defaultBackgroundColor = {
      r: 255,
      g: 255,
      b: 255
    };

    function colorScaleKey(state, displayMode) {
      return "" + state.chr1 + "_" + state.chr2 + "_" + state.zoom + "_" + state.normalization + "_" + displayMode;
    }
    /**
     * Returns a promise for an image tile
     *
     * @param zd
     * @param row
     * @param column
     * @param state
     * @returns {*}
     */


    const inProgressCache = {};

    function inProgressTile(imageSize) {
      let image = inProgressCache[imageSize];

      if (!image) {
        image = document.createElement('canvas');
        image.width = imageSize;
        image.height = imageSize;
        const ctx = image.getContext('2d');
        ctx.font = '24px sans-serif';
        ctx.fillStyle = 'rgb(230, 230, 230)';
        ctx.fillRect(0, 0, image.width, image.height);
        ctx.fillStyle = 'black';

        for (let i = 100; i < imageSize; i += 300) {
          for (let j = 100; j < imageSize; j += 300) {
            ctx.fillText('Loading...', i, j);
          }
        }

        inProgressCache[imageSize] = image;
      }

      return image;
    }

    function getMatrices(chr1, chr2) {
      var promises = [];

      if ('B' === this.displayMode && this.browser.controlDataset) {
        promises.push(this.browser.controlDataset.getMatrix(chr1, chr2));
      } else {
        promises.push(this.browser.dataset.getMatrix(chr1, chr2));

        if (this.displayMode && 'A' !== this.displayMode && this.browser.controlDataset) {
          promises.push(this.browser.controlDataset.getMatrix(chr1, chr2));
        }
      }

      return Promise.all(promises);
    }

    function computePercentile(records, p) {
      const counts = records.map(r => r.counts);
      counts.sort(function (a, b) {
        return a - b;
      });
      const idx = Math.floor(p / 100 * records.length);
      return counts[idx]; // return HICMath.percentile(array, p);
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    class ColorScaleWidget {
      constructor(browser, $hic_navbar_container) {
        this.browser = browser;
        const $container = $hic_navbar_container.find("div[id$='lower-hic-nav-bar-widget-container']");
        this.$container = $('<div class="hic-colorscale-widget-container">');
        $container.append(this.$container); // contact map background color picker

        const {
          r: _r,
          g: _g,
          b: _b
        } = ContactMatrixView.defaultBackgroundColor;
        this.$mapBackgroundColorpickerButton = colorSwatch(IGVColor.rgbColor(_r, _g, _b));
        this.$container.append(this.$mapBackgroundColorpickerButton);
        this.backgroundColorpicker = createColorPicker(browser, this.$mapBackgroundColorpickerButton, undefined); // '-' color swatch

        const {
          r: nr,
          g: ng,
          b: nb
        } = defaultRatioColorScaleConfig.negative;
        this.$minusButton = colorSwatch(IGVColor.rgbColor(nr, ng, nb));
        this.$container.append(this.$minusButton);
        this.minusColorPicker = createColorPicker(browser, this.$minusButton, '-');
        this.$minusButton.hide(); // '+' color swatch

        const {
          r,
          g,
          b
        } = defaultRatioColorScaleConfig.positive;
        this.$plusButton = colorSwatch(IGVColor.rgbColor(r, g, b));
        this.$container.append(this.$plusButton);
        this.plusColorPicker = createColorPicker(browser, this.$plusButton, '+');
        this.$minusButton.on('click', () => presentColorPicker(this.minusColorPicker, this.plusColorPicker, this.backgroundColorpicker));
        this.$plusButton.on('click', () => presentColorPicker(this.plusColorPicker, this.minusColorPicker, this.backgroundColorpicker));
        this.$mapBackgroundColorpickerButton.on('click', () => presentColorPicker(this.backgroundColorpicker, this.minusColorPicker, this.plusColorPicker)); // threshold

        this.$high_colorscale_input = $('<input>', {
          'type': 'text',
          'placeholder': '',
          'title': 'color scale input'
        });
        this.$container.append(this.$high_colorscale_input);
        this.$high_colorscale_input.on('change', function (e) {
          var numeric;
          numeric = numberUnFormatter($(this).val());

          if (isNaN(numeric)) ; else {
            browser.setColorScaleThreshold(numeric);
          }
        }); // threshold -

        let $fa = $("<i>", {
          class: 'fa fa-minus',
          'aria-hidden': 'true',
          'title': 'negative threshold'
        });
        $fa.on('click', () => this.$high_colorscale_input.val(updateThreshold(browser, 0.5)));
        this.$container.append($fa); // threshold +

        $fa = $("<i>", {
          class: 'fa fa-plus',
          'aria-hidden': 'true',
          'title': 'positive threshold'
        });
        $fa.on('click', () => this.$high_colorscale_input.val(updateThreshold(browser, 2.0)));
        this.$container.append($fa);

        const handleColorScaleEvent = event => {
          if (event.data instanceof ColorScale) {
            const {
              threshold
            } = event.data;
            this.$high_colorscale_input.val(threshold);
            paintSwatch(this.$plusButton, event.data);
          } else if (event.data instanceof RatioColorScale) {
            const {
              threshold,
              negativeScale,
              positiveScale
            } = event.data;
            this.$high_colorscale_input.val(threshold);
            paintSwatch(this.$minusButton, negativeScale);
            paintSwatch(this.$plusButton, positiveScale);
          }
        };

        this.browser.eventBus.subscribe("ColorScale", handleColorScaleEvent);

        const handleDisplayModeEvent = event => {
          if ("AOB" === event.data || "BOA" === event.data) {
            this.$minusButton.show();
            const {
              negativeScale,
              positiveScale
            } = this.browser.contactMatrixView.ratioColorScale;
            paintSwatch(this.$minusButton, negativeScale);
            paintSwatch(this.$plusButton, positiveScale);
          } else {
            this.$minusButton.hide();
            paintSwatch(this.$plusButton, this.browser.contactMatrixView.colorScale);
          }
        };

        this.browser.eventBus.subscribe("DisplayMode", handleDisplayModeEvent);
        this.browser.eventBus.subscribe("MapLoad", ignore => {
          paintSwatch(this.$mapBackgroundColorpickerButton, this.browser.contactMatrixView.backgroundColor);
        });
      }

    }

    function paintSwatch($swatch, _ref) {
      let {
        r,
        g,
        b
      } = _ref;
      $swatch.get(0).style.backgroundColor = IGVColor.rgbToHex(IGVColor.rgbColor(r, g, b));
    }

    const updateThreshold = (browser, scaleFactor) => {
      const colorScale = browser.getColorScale();
      browser.setColorScaleThreshold(colorScale.getThreshold() * scaleFactor);
      return numberFormatter(colorScale.getThreshold());
    };

    function createColorPicker(browser, $parent, type) {
      let defaultColors;
      let colorHandler;

      if (undefined === type) {
        const {
          r,
          g,
          b
        } = ContactMatrixView.defaultBackgroundColor;
        defaultColors = [IGVColor.rgbToHex(IGVColor.rgbColor(r, g, b))];

        colorHandler = hexString => {
          $parent.get(0).style.backgroundColor = hexString;
          const [r, g, b] = IGVColor.hexToRgb(hexString).split('(').pop().split(')').shift().split(',').map(str => parseInt(str, 10));
          browser.contactMatrixView.setBackgroundColor({
            r,
            g,
            b
          });
        };
      } else {
        defaultColors = [defaultRatioColorScaleConfig.negative, defaultRatioColorScaleConfig.positive].map(_ref2 => {
          let {
            r,
            g,
            b
          } = _ref2;
          return IGVColor.rgbToHex(IGVColor.rgbColor(r, g, b));
        });

        colorHandler = hexString => {
          $parent.get(0).style.backgroundColor = hexString;
          const [r, g, b] = IGVColor.hexToRgb(hexString).split('(').pop().split(')').shift().split(',').map(str => parseInt(str, 10));
          browser.getColorScale().setColorComponents({
            r,
            g,
            b
          }, type);
          browser.repaintMatrix();
        };
      }

      const config = {
        parent: $parent.get(0),
        top: 64,
        left: 64,
        width: 432,
        defaultColors,
        colorHandler
      };
      return new ColorPicker(config);
    }

    function presentColorPicker(presentable, hideableA, hideableB) {
      hideableA.hide();
      hideableB.hide();
      presentable.show();
    }

    function colorSwatch(rgbString) {
      const swatch = div$1({
        class: 'igv-ui-color-swatch'
      });
      swatch.style.backgroundColor = IGVColor.rgbToHex(rgbString);
      return $(swatch);
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    class ControlMapWidget {
      constructor(browser, $hic_navbar_container) {
        this.browser = browser;
        const $parent = $hic_navbar_container.find("div[id$='lower-hic-nav-bar-widget-container']");
        this.$container = $('<div class="hic-control-map-selector-container">');
        this.$container.hide();
        $parent.append(this.$container); // select

        this.$select = $('<select>');
        this.$select.attr('name', 'control_map_selector');
        this.$container.append(this.$select); // a-b toggle icon

        const $toggle_container = $('<div>');
        this.$container.append($toggle_container); // cycle button

        const $cycle_container = $('<div>');
        this.$container.append($cycle_container);
        this.controlMapHash = new ControlMapHash(browser, this.$select, $toggle_container, $cycle_container, toggle_arrows_up(), toggle_arrows_down());
        const self = this;
        browser.eventBus.subscribe("ControlMapLoad", function (event) {
          self.controlMapHash.updateOptions(browser.getDisplayMode());
          self.$container.show();
        });
        browser.eventBus.subscribe("MapLoad", function (event) {
          if (!browser.controlDataset) {
            self.$container.hide();
          }
        });
        browser.eventBus.subscribe("DisplayMode", function (event) {
          self.controlMapHash.updateOptions(event.data);
        });
      }

      toggleDisplayMode() {
        this.controlMapHash.toggleDisplayMode();
      }

      toggleDisplayModeCycle() {
        this.controlMapHash.toggleDisplayModeCycle();
      }

      getDisplayModeCycle() {
        return this.controlMapHash.cycleID;
      }

    }

    class ControlMapHash {
      constructor(browser, $select, $toggle, $cycle, $img_a, $img_b) {
        const self = this;
        this.browser = browser;
        this.$select = $select;
        this.$toggle = $toggle;
        this.$cycle = $cycle; // a arrow

        this.$img_a = $img_a;
        this.$toggle.append(this.$img_a); // b arrow

        this.$img_b = $img_b;
        this.$toggle.append(this.$img_b);
        const A = {
          title: 'A',
          value: 'A',
          other: 'B',
          $hidden: $img_b,
          $shown: $img_a
        };
        const B = {
          title: 'B',
          value: 'B',
          other: 'A',
          $hidden: $img_a,
          $shown: $img_b
        };
        const AOB = {
          title: 'A/B',
          value: 'AOB',
          other: 'BOA',
          $hidden: $img_b,
          $shown: $img_a
        };
        const BOA = {
          title: 'B/A',
          value: 'BOA',
          other: 'AOB',
          $hidden: $img_a,
          $shown: $img_b
        };
        this.hash = {
          'A': A,
          'B': B,
          'AOB': AOB,
          'BOA': BOA
        };
        this.$select.on('change', function (e) {
          let value;
          self.disableDisplayModeCycle();
          value = $(this).val();
          self.setDisplayMode(value);
        });
        this.$toggle.on('click', function (e) {
          self.disableDisplayModeCycle();
          self.toggleDisplayMode();
        }); // cycle outline

        this.$cycle_outline = cycle_outline();
        $cycle.append(this.$cycle_outline); // cycle solid

        this.$cycle_solid = cycle_solid();
        $cycle.append(this.$cycle_solid);
        this.$cycle_solid.hide();
        $cycle.on('click', function () {
          self.toggleDisplayModeCycle();
        });
        $cycle.hide();
      }

      disableDisplayModeCycle() {
        if (this.cycleID) {
          clearTimeout(this.cycleID);
          this.cycleID = undefined;
          this.$cycle_solid.hide();
          this.$cycle_outline.show();
        }
      }

      toggleDisplayModeCycle() {
        let self = this;

        if (this.cycleID) {
          this.disableDisplayModeCycle();
        } else {
          doToggle();
          this.$cycle_solid.show();
          this.$cycle_outline.hide();
        }

        function doToggle() {
          self.cycleID = setTimeout(async function () {
            await self.toggleDisplayMode();
            doToggle();
          }, 2500);
        }
      }

      async toggleDisplayMode() {
        let displayModeOld, displayModeNew, str;
        displayModeOld = this.browser.getDisplayMode(); // render new display mode

        displayModeNew = this.hash[displayModeOld].other;
        await this.browser.setDisplayMode(displayModeNew); // update exchange icon

        this.hash[displayModeNew].$hidden.hide();
        this.hash[displayModeNew].$shown.show(); // update select element

        str = 'option[value=' + displayModeNew + ']';
        this.$select.find(str).prop('selected', true);
      }

      setDisplayMode(displayMode) {
        setDisplayModeHelper.call(this, displayMode);
        this.browser.setDisplayMode(displayMode);
      }

      updateOptions(displayMode) {
        let self = this;
        this.$img_a.hide();
        this.$img_b.hide();
        this.$select.empty();
        Object.keys(this.hash).forEach(function (key) {
          let item, option;
          item = self.hash[key];
          option = $('<option>').attr('title', item.title).attr('value', item.value).text(item.title);

          if (displayMode === item.value) {
            option.attr('selected', true);
            item.$shown.show();
            setDisplayModeHelper.call(self, displayMode);
          }

          self.$select.append(option);
        });
      }

    }

    function setDisplayModeHelper(displayMode) {
      this.hash[displayMode].$hidden.hide();
      this.hash[displayMode].$shown.show();
      this.$cycle.show();
      this.$toggle.show(); // if ('A' === displayMode || 'B' === displayMode) {
      //     this.$cycle.show();
      //     this.$toggle.show();
      // } else {
      //     this.$cycle.hide();
      //     this.$toggle.hide();
      // }
    }

    function toggle_arrows_up() {
      let str, a;
      str = '<svg width="34px" height="34px" viewBox="0 0 34 34" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n' + '    <!-- Generator: Sketch 51 (57462) - http://www.bohemiancoding.com/sketch -->\n' + '    <title>Toggle Maps</title>\n' + '    <desc>Created with Sketch.</desc>\n' + '    <defs></defs>\n' + '    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n' + '        <g id="Group">\n' + '            <rect id="Rectangle" stroke="#A6A6A6" stroke-width="1.25201381" fill="#F8F8F8" x="0.626006904" y="0.626006904" width="32.7479862" height="32.7479862" rx="3.91254315"></rect>\n' + '            <g id="arrows" transform="translate(6.533947, 7.003452)" fill-rule="nonzero" stroke="#5F5F5F" stroke-width="0.626006904">\n' + '                <path d="M25.9411017,8.76431329 L11.8559464,8.76431329 L11.8559464,6.88629258 C11.8559464,6.05237313 10.8440845,5.63114873 10.2529383,6.22229488 L7.12290378,9.3523294 C6.75622024,9.71905207 6.75622024,10.3136021 7.12290378,10.6802857 L10.2529383,13.8103202 C10.8409153,14.3982581 11.8559464,13.9850935 11.8559464,13.1463616 L11.8559464,11.2683409 L25.9411017,11.2683409 C26.4597093,11.2683409 26.8801121,10.8479381 26.8801121,10.3293306 L26.8801121,9.70332365 C26.8801121,9.18471605 26.4597093,8.76431329 25.9411017,8.76431329 Z" id="down-arrow" fill="#F8F8F8" transform="translate(16.864002, 10.016110) rotate(-90.000000) translate(-16.864002, -10.016110) "></path>\n' + '                <path d="M13.1470856,8.76431329 L-0.938069748,8.76431329 L-0.938069748,6.88629258 C-0.938069748,6.05237313 -1.94993166,5.63114873 -2.5410778,6.22229488 L-5.67111233,9.3523294 C-6.03779587,9.71905207 -6.03779587,10.3136021 -5.67111233,10.6802857 L-2.5410778,13.8103202 C-1.95310082,14.3982581 -0.938069748,13.9850935 -0.938069748,13.1463616 L-0.938069748,11.2683409 L13.1470856,11.2683409 C13.6656932,11.2683409 14.086096,10.8479381 14.086096,10.3293306 L14.086096,9.70332365 C14.086096,9.18471605 13.6656932,8.76431329 13.1470856,8.76431329 Z" id="up-arrow" fill="#5F5F5F" transform="translate(4.069985, 10.016110) scale(1, -1) rotate(-90.000000) translate(-4.069985, -10.016110) "></path>\n' + '            </g>\n' + '        </g>\n' + '    </g>\n' + '</svg>';
      a = str.split('\n').join(' ');
      return $(a);
    }

    function toggle_arrows_down() {
      let str, b;
      str = '<svg width="34px" height="34px" viewBox="0 0 34 34" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n' + '    <!-- Generator: Sketch 51 (57462) - http://www.bohemiancoding.com/sketch -->\n' + '    <title>Toggle Maps</title>\n' + '    <desc>Created with Sketch.</desc>\n' + '    <defs></defs>\n' + '    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n' + '        <g id="Group">\n' + '            <rect id="Rectangle" stroke="#A6A6A6" stroke-width="1.25201381" fill="#F8F8F8" x="0.626006904" y="0.626006904" width="32.7479862" height="32.7479862" rx="3.91254315"></rect>\n' + '            <g id="arrows" transform="translate(6.533947, 7.003452)" fill-rule="nonzero" stroke="#5F5F5F" stroke-width="0.626006904">\n' + '                <path d="M25.9411017,8.76431329 L11.8559464,8.76431329 L11.8559464,6.88629258 C11.8559464,6.05237313 10.8440845,5.63114873 10.2529383,6.22229488 L7.12290378,9.3523294 C6.75622024,9.71905207 6.75622024,10.3136021 7.12290378,10.6802857 L10.2529383,13.8103202 C10.8409153,14.3982581 11.8559464,13.9850935 11.8559464,13.1463616 L11.8559464,11.2683409 L25.9411017,11.2683409 C26.4597093,11.2683409 26.8801121,10.8479381 26.8801121,10.3293306 L26.8801121,9.70332365 C26.8801121,9.18471605 26.4597093,8.76431329 25.9411017,8.76431329 Z" id="down-arrow" fill="#5F5F5F" transform="translate(16.864002, 10.016110) rotate(-90.000000) translate(-16.864002, -10.016110) "></path>\n' + '                <path d="M13.1470856,8.76431329 L-0.938069748,8.76431329 L-0.938069748,6.88629258 C-0.938069748,6.05237313 -1.94993166,5.63114873 -2.5410778,6.22229488 L-5.67111233,9.3523294 C-6.03779587,9.71905207 -6.03779587,10.3136021 -5.67111233,10.6802857 L-2.5410778,13.8103202 C-1.95310082,14.3982581 -0.938069748,13.9850935 -0.938069748,13.1463616 L-0.938069748,11.2683409 L13.1470856,11.2683409 C13.6656932,11.2683409 14.086096,10.8479381 14.086096,10.3293306 L14.086096,9.70332365 C14.086096,9.18471605 13.6656932,8.76431329 13.1470856,8.76431329 Z" id="up-arrow" fill="#F8F8F8" transform="translate(4.069985, 10.016110) scale(1, -1) rotate(-90.000000) translate(-4.069985, -10.016110) "></path>\n' + '            </g>\n' + '        </g>\n' + '    </g>\n' + '</svg>';
      b = str.split('\n').join(' ');
      return $(b);
    }

    function cycle_outline() {
      let str, b;
      str = '<svg width="34px" height="34px" viewBox="0 0 34 34" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n' + '    <!-- Generator: Sketch 51 (57462) - http://www.bohemiancoding.com/sketch -->\n' + '    <title>Cycle Maps</title>\n' + '    <desc>Created with Sketch.</desc>\n' + '    <defs></defs>\n' + '    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n' + '        <g id="Group" fill="#F8F8F8">\n' + '            <rect id="Rectangle" stroke="#A6A6A6" stroke-width="1.25201381" x="0.626006904" y="0.626006904" width="32.7479862" height="32.7479862" rx="3.91254315"></rect>\n' + '            <g id="circle-notch-group" transform="translate(5.947066, 6.103567)" fill-rule="nonzero" stroke="#5F5F5F" stroke-width="0.75">\n' + '                <path d="M12.5012159,1.07356655 L12.5012159,1.81734411 C12.5012159,2.29971235 12.8262916,2.71738683 13.2908449,2.84717621 C16.7518005,3.81392183 19.2875784,6.98762275 19.2875784,10.7595067 C19.2875784,15.2996349 15.6133435,18.9745898 11.072508,18.9745898 C6.53238683,18.9745898 2.85743758,15.3003493 2.85743758,10.7595067 C2.85743758,6.98815851 5.39276905,3.81401113 8.85408182,2.84717621 C9.31872442,2.71738683 9.64380011,2.29962306 9.64380011,1.81721016 L9.64380011,1.07392373 C9.64380011,0.372561009 8.98150471,-0.138381443 8.30233269,0.0365908983 C3.5094195,1.27117502 -0.0270343765,5.6342771 0.00015572077,10.8189768 C0.0323016485,16.9379636 4.97728293,21.8448684 11.0963496,21.8319654 C17.2005487,21.819107 22.1449942,16.8667067 22.1449942,10.7595067 C22.1449942,5.5968181 18.611621,1.2595221 13.831209,0.0336441837 C13.1565464,-0.139363681 12.5012159,0.377070376 12.5012159,1.07356655 Z" id="circle-notch---solid"></path>\n' + '            </g>\n' + '        </g>\n' + '    </g>\n' + '</svg>';
      b = str.split('\n').join(' ');
      return $(b);
    }

    function cycle_solid() {
      let str, b;
      str = '<svg width="34px" height="34px" viewBox="0 0 34 34" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n' + '    <!-- Generator: Sketch 51 (57462) - http://www.bohemiancoding.com/sketch -->\n' + '    <title>Cycle Maps</title>\n' + '    <desc>Created with Sketch.</desc>\n' + '    <defs></defs>\n' + '    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n' + '        <g id="Group">\n' + '            <rect id="Rectangle" stroke="#A6A6A6" stroke-width="1.25201381" fill="#F8F8F8" x="0.626006904" y="0.626006904" width="32.7479862" height="32.7479862" rx="3.91254315"></rect>\n' + '            <g id="circle-notch-group" transform="translate(5.947066, 6.103567)" fill="#5F5F5F" fill-rule="nonzero">\n' + '                <path d="M12.5012159,1.07356655 L12.5012159,1.81734411 C12.5012159,2.29971235 12.8262916,2.71738683 13.2908449,2.84717621 C16.7518005,3.81392183 19.2875784,6.98762275 19.2875784,10.7595067 C19.2875784,15.2996349 15.6133435,18.9745898 11.072508,18.9745898 C6.53238683,18.9745898 2.85743758,15.3003493 2.85743758,10.7595067 C2.85743758,6.98815851 5.39276905,3.81401113 8.85408182,2.84717621 C9.31872442,2.71738683 9.64380011,2.29962306 9.64380011,1.81721016 L9.64380011,1.07392373 C9.64380011,0.372561009 8.98150471,-0.138381443 8.30233269,0.0365908983 C3.5094195,1.27117502 -0.0270343765,5.6342771 0.00015572077,10.8189768 C0.0323016485,16.9379636 4.97728293,21.8448684 11.0963496,21.8319654 C17.2005487,21.819107 22.1449942,16.8667067 22.1449942,10.7595067 C22.1449942,5.5968181 18.611621,1.2595221 13.831209,0.0336441837 C13.1565464,-0.139363681 12.5012159,0.377070376 12.5012159,1.07356655 Z" id="circle-notch---solid"></path>\n' + '            </g>\n' + '        </g>\n' + '    </g>\n' + '</svg>';
      b = str.split('\n').join(' ');
      return $(b);
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    var labels = {
      NONE: 'None',
      VC: 'Coverage',
      VC_SQRT: 'Coverage - Sqrt',
      KR: 'Balanced',
      INTER_VC: 'Interchromosomal Coverage',
      INTER_VC_SQRT: 'Interchromosomal Coverage - Sqrt',
      INTER_KR: 'Interchromosomal Balanced',
      GW_VC: 'Genome-wide Coverage',
      GW_VC_SQRT: 'Genome-wide Coverage - Sqrt',
      GW_KR: 'Genome-wide Balanced'
    };

    class NormalizationWidget {
      constructor(browser, $hic_navbar_container) {
        this.browser = browser;
        const $parent = $hic_navbar_container.find("div[id$='lower-hic-nav-bar-widget-container']");
        this.$container = $("<div>", {
          class: 'hic-normalization-selector-container',
          title: 'Normalization'
        });
        $parent.append(this.$container);
        let $label = $('<div>');
        $label.text('Norm');
        this.$container.append($label); // $label.hide();

        this.$normalization_selector = $('<select name="select">');
        this.$normalization_selector.attr('name', 'normalization_selector');
        this.$normalization_selector.on('change', () => {
          this.browser.setNormalization(this.$normalization_selector.val());
        });
        this.$container.append(this.$normalization_selector);
        this.$spinner = $('<div>');
        this.$spinner.text('Loading ...');
        this.$container.append(this.$spinner);
        this.$spinner.hide();
        this.browser.eventBus.subscribe("MapLoad", this);
        this.browser.eventBus.subscribe("NormVectorIndexLoad", this);
        this.browser.eventBus.subscribe("NormalizationFileLoad", this);
        this.browser.eventBus.subscribe("NormalizationExternalChange", this);
      }

      startNotReady() {
        this.$normalization_selector.hide();
        this.$spinner.show();
      }

      stopNotReady() {
        this.$spinner.hide();
        this.$normalization_selector.show();
      }

      receiveEvent(event) {
        if ("NormVectorIndexLoad" === event.type) {
          updateOptions.call(this); // TODO -- end norm widget "not ready" state

          this.stopNotReady();
        } else if ("NormalizationFileLoad" === event.type) {
          if (event.data === "start") {
            this.startNotReady();
          } else {
            this.stopNotReady();
          }
        } else if ("NormalizationExternalChange" === event.type) {
          this.$normalization_selector.find('option').filter(function (index) {
            var s1 = this.value;
            var s2 = event.data;
            return s1 === s2;
          }).prop('selected', true);
        }

        async function updateOptions() {
          const norm = this.browser.state.normalization;
          const normalizationTypes = await this.browser.getNormalizationOptions();

          if (normalizationTypes) {
            const elements = normalizationTypes.map(function (normalization) {
              const label = labels[normalization] || normalization;
              const isSelected = norm === normalization;
              const titleString = label === undefined ? '' : ' title = "' + label + '" ';
              const valueString = ' value=' + normalization + (isSelected ? ' selected' : '');
              const labelPresentation = '&nbsp &nbsp' + label + '&nbsp &nbsp';
              return '<option' + titleString + valueString + '>' + labelPresentation + '</option>';
            });
            this.$normalization_selector.empty();
            this.$normalization_selector.append(elements.join(''));
          }
        }
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    /**
     * Created by dat on 3/22/17.
     */
    class ChromosomeSelectorWidget {
      constructor(browser, $container) {
        this.browser = browser;
        this.$x_axis_selector = $container.find("select[name='x-axis-selector']");
        this.$y_axis_selector = $container.find("select[name='y-axis-selector']");
        this.$x_axis_selector.on('change', () => {
          const str = this.$x_axis_selector.val();

          if (0 === parseInt(str, 10)) {
            this.$y_axis_selector.val(str);
          } else if (0 === parseInt(this.$y_axis_selector.val(), 10)) {
            this.$y_axis_selector.val(str);
          }
        });
        this.$y_axis_selector.on('change', () => {
          const str = this.$y_axis_selector.val();

          if (0 === parseInt(str, 10)) {
            this.$x_axis_selector.val(str);
          } else if (0 === parseInt(this.$x_axis_selector.val(), 10)) {
            this.$x_axis_selector.val(str);
          }
        });
        this.$y_axis_selector.next('div').on('click', async () => {
          const chr1Index = parseInt(this.$x_axis_selector.find('option:selected').val(), 10);
          const chr2Index = parseInt(this.$y_axis_selector.find('option:selected').val(), 10);
          await browser.setChromosomes(chr1Index, chr2Index);
        });
        this.dataLoadConfig = {
          receiveEvent: event => {
            if (event.type === "MapLoad") {
              this.respondToDataLoadWithDataset(event.data);
            }
          }
        };
        browser.eventBus.subscribe("MapLoad", this.dataLoadConfig);
        this.locusChangeConfig = {
          receiveEvent: event => {
            if (event.type === "LocusChange") {
              this.respondToLocusChangeWithState(event.data.state);
            }
          }
        };
        browser.eventBus.subscribe("LocusChange", this.locusChangeConfig);
      }

      respondToDataLoadWithDataset(dataset) {
        var elements, str, $xFound, $yFound;
        this.$x_axis_selector.empty();
        this.$y_axis_selector.empty();
        elements = dataset.chromosomes.map((_ref, index) => {
          let {
            name
          } = _ref;
          return `<option value=${index.toString()}>${name}</option>`;
        });
        this.$x_axis_selector.append(elements.join(''));
        this.$y_axis_selector.append(elements.join(''));
        str = 'option[value=' + this.browser.state.chr1.toString() + ']';
        $xFound = this.$x_axis_selector.find(str);
        $xFound.prop('selected', true);
        str = 'option[value=' + this.browser.state.chr2.toString() + ']';
        $yFound = this.$y_axis_selector.find(str);
        $yFound.prop('selected', true);
      }

      respondToLocusChangeWithState(state) {
        var ssx,
            ssy,
            $xFound,
            $yFound;
        $xFound = this.$x_axis_selector.find('option');
        $yFound = this.$y_axis_selector.find('option'); // this happens when the first dataset is loaded.

        if (0 === $xFound.length || 0 === $yFound.length) {
          return;
        }

        $xFound = this.$x_axis_selector.find('option:selected');
        $yFound = this.$y_axis_selector.find('option:selected');
        $xFound.prop('selected', false);
        $yFound.prop('selected', false); // chr1 = parseInt($xFound.val(), 10);
        // chr2 = parseInt($yFound.val(), 10);
        // // It is the pair of chromosomes that is important,  1-2 == 2-1,  so update only if the pair does not match
        // if (false === ((chr1 === state.chr1 && chr2 === state.chr2) || (chr1 === state.chr2 && chr2 === state.chr1))) {
        //     ssx = 'option[value=' + state.chr1.toString() + ']';
        //     this.$x_axis_selector.find(ssx).attr('selected', 'selected');
        //
        //     ssx = 'option[value=' + state.chr2.toString() + ']';
        //     this.$y_axis_selector.find(ssx).attr('selected', 'selected');
        // }

        ssx = 'option[value=' + state.chr1.toString() + ']';
        ssy = 'option[value=' + state.chr2.toString() + ']';
        this.$x_axis_selector.find(ssx).prop('selected', true);
        this.$y_axis_selector.find(ssy).prop('selected', true);
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    class AnnotationWidget {
      constructor(browser, $container, _ref, trackListRetrievalCallback) {
        let {
          title,
          alertMessage
        } = _ref;
        this.browser = browser;
        this.trackListRetrievalCallback = trackListRetrievalCallback;
        annotationPresentationButton.call(this, $container, alertMessage);
        annotationPanel.call(this, this.browser.$root, title);
      }

      updateBody(tracks) {
        var self = this,
            trackPairs,
            isTrack2D,
            zi;
        self.$annotationPanel.find('.hic-annotation-row-container').remove();
        isTrack2D = tracks[0] instanceof Track2D;

        if (isTrack2D) {
          // Reverse list to present layers in "z" order.
          for (zi = tracks.length - 1; zi >= 0; zi--) {
            annotationPanelRow.call(self, self.$annotationPanel, tracks[zi]);
          }
        } else {
          trackPairs = tracks;

          for (let trackRenderer of trackPairs) {
            annotationPanelRow.call(self, self.$annotationPanel, trackRenderer);
          }
        }
      }

    }

    function annotationPresentationButton($parent, alertMessage) {
      const $button = $parent.find("button");
      $button.on('click', () => {
        const list = this.trackListRetrievalCallback();

        if (list.length > 0) {
          this.updateBody(this.trackListRetrievalCallback());
          this.$annotationPanel.toggle();
        } else {
          Alert$1.presentAlert(alertMessage);
        }

        this.browser.hideMenu();
      });
    }

    function annotationPanel($parent, title) {
      var self = this,
          $panel_header,
          $div,
          $fa;
      this.$annotationPanel = $('<div>', {
        class: 'hic-annotation-panel-container'
      });
      $parent.append(this.$annotationPanel); // close button container

      $panel_header = $('<div>', {
        class: 'hic-annotation-panel-header'
      });
      this.$annotationPanel.append($panel_header); // panel title

      $div = $('<div>');
      $div.text(title);
      $panel_header.append($div); // close button

      $div = $('<div>', {
        class: 'hic-menu-close-button'
      });
      $panel_header.append($div);
      $fa = $("<i>", {
        class: 'fa fa-times'
      });
      $div.append($fa);
      $fa.on('click', function (e) {
        self.$annotationPanel.toggle();
      }); // TODO: Continue changes for load functions added to side panel
      // load container
      // $load_container = $('<div>', { class:'hic-annotation-panel-load-container' });
      // this.$annotationPanel.append($load_container);
      //
      // // Load
      // $div = $('<div>');
      // $load_container.append($div);
      // $div.text('Load:');
      //
      // // Blah
      // $div = $('<div>');
      // $load_container.append($div);
      // $div.text('Blah');
      //this.$annotationPanel.draggable();

      makeDraggable$1(this.$annotationPanel.get(0), $panel_header.get(0));
      this.$annotationPanel.hide();
    }

    function annotationPanelRow($container, track) {
      var self = this,
          $colorpickerContainer,
          $colorpickerButton,
          $row_container,
          $row,
          $hideShowTrack,
          $deleteTrack,
          $upTrack,
          $downTrack,
          $e,
          $o,
          hidden_color = '#f7f7f7',
          str,
          isTrack2D,
          trackList,
          xyTrackRendererPair,
          trackRenderer,
          track1D,
          index,
          upp,
          dwn;
      isTrack2D = track instanceof Track2D;
      trackList = this.trackListRetrievalCallback();

      if (false === isTrack2D) {
        xyTrackRendererPair = track;
        track1D = xyTrackRendererPair.x.track;
        trackRenderer = xyTrackRendererPair.x.track.trackView;
      } // row container


      $row_container = $('<div>', {
        class: 'hic-annotation-row-container'
      });
      $container.append($row_container); // one row

      $row = $('<div>', {
        class: 'hic-annotation-modal-row'
      });
      $row_container.append($row); // track name

      $e = $("<div>");
      $e.text(isTrack2D ? track.config.name : track1D.config.name);
      $row.append($e); // track hide/show

      if (isTrack2D) {
        str = true === track.isVisible ? 'fa fa-eye fa-lg' : 'fa fa-eye-slash fa-lg';
        $hideShowTrack = $("<i>", {
          class: str,
          'aria-hidden': 'true'
        });
        $row.append($hideShowTrack);
        $hideShowTrack.on('click', function (e) {
          if ($hideShowTrack.hasClass('fa-eye')) {
            $hideShowTrack.addClass('fa-eye-slash');
            $hideShowTrack.removeClass('fa-eye');
            track.isVisible = false;
          } else {
            $hideShowTrack.addClass('fa-eye');
            $hideShowTrack.removeClass('fa-eye-slash');
            track.isVisible = true;
          }

          self.browser.contactMatrixView.clearImageCaches();
          self.browser.contactMatrixView.update();
        });
      }

      if (isTrack2D) {
        // matrix diagonal widget
        const $matrix_diagonal_div = $('<div>', {
          class: 'matrix-diagonal-widget-container matrix-diagonal-widget-all'
        });
        $row.append($matrix_diagonal_div);
        $matrix_diagonal_div.on('click.matrix_diagonal_div', e => {
          e.preventDefault();
          matrixDiagionalWidgetHandler($matrix_diagonal_div, track);
        });
      } // color swatch selector button


      $colorpickerButton = annotationColorSwatch(isTrack2D ? track.getColor() : track1D.color);
      $row.append($colorpickerButton); // color swatch selector

      $colorpickerContainer = createAnnotationPanelColorpickerContainer($row_container, {
        width: 29 * 24 + 1 + 1
      }, function () {
        $row.next('.hic-color-swatch-container').toggle();
      });
      $colorpickerButton.on('click', function (e) {
        $row.next('.hic-color-swatch-container').toggle();
      });
      $colorpickerContainer.hide();

      const colorHandler = color => {
        var $swatch;
        $swatch = $row.find('.fa-square');
        $swatch.css({
          'color': color
        });

        if (isTrack2D) {
          track.color = color;
          self.browser.eventBus.post(HICEvent('TrackState2D', track));
        } else {
          trackRenderer.setColor(color);
        }
      };

      createColorSwatchSelector($colorpickerContainer.get(0), colorHandler); // track up/down

      $e = $('<div>', {
        class: 'up-down-arrow-container'
      });
      $row.append($e);
      $upTrack = $("<i>", {
        class: 'fa fa-arrow-up',
        'aria-hidden': 'true'
      });
      $e.append($upTrack);
      $downTrack = $("<i>", {
        class: 'fa fa-arrow-down',
        'aria-hidden': 'true'
      });
      $e.append($downTrack);

      if (1 === trackList.length) {
        $upTrack.css('color', hidden_color);
        $downTrack.css('color', hidden_color);
      } else if (track === trackList[0]) {
        $o = isTrack2D ? $downTrack : $upTrack;
        $o.css('color', hidden_color);
      } else if (track === trackList[trackList.length - 1]) {
        $o = isTrack2D ? $upTrack : $downTrack;
        $o.css('color', hidden_color);
      }

      index = trackList.indexOf(track);

      upp = function (e) {
        track = trackList[index + 1];
        trackList[index + 1] = trackList[index];
        trackList[index] = track;

        if (isTrack2D) {
          self.browser.eventBus.post(HICEvent('TrackState2D', trackList));
          self.updateBody(trackList);
        } else {
          self.browser.updateLayout();
          self.updateBody(trackList);
        }
      };

      dwn = function (e) {
        track = trackList[index - 1];
        trackList[index - 1] = trackList[index];
        trackList[index] = track;

        if (isTrack2D) {
          self.browser.eventBus.post(HICEvent('TrackState2D', trackList));
          self.updateBody(trackList);
        } else {
          self.browser.updateLayout();
          self.updateBody(trackList);
        }
      };

      $upTrack.on('click', isTrack2D ? upp : dwn);
      $downTrack.on('click', isTrack2D ? dwn : upp); // track delete

      $deleteTrack = $("<i>", {
        class: 'fa fa-trash-o fa-lg',
        'aria-hidden': 'true'
      });
      $row.append($deleteTrack);
      $deleteTrack.on('click', function (e) {
        var index;

        if (isTrack2D) {
          index = trackList.indexOf(track);
          trackList.splice(index, 1);
          self.browser.contactMatrixView.clearImageCaches();
          self.browser.contactMatrixView.update();
          self.browser.eventBus.post(HICEvent('TrackLoad2D', trackList));
        } else {
          self.browser.layoutController.removeTrackXYPair(trackRenderer.trackRenderPair);
        }

        self.updateBody(trackList);
      });
    }

    function matrixDiagionalWidgetHandler($icon, track2D) {
      if ($icon.hasClass('matrix-diagonal-widget-all')) {
        $icon.removeClass('matrix-diagonal-widget-all');
        $icon.addClass('matrix-diagonal-widget-lower');
        track2D.displayMode = Track2DDisplaceModes.displayLowerMatrix;
      } else if ($icon.hasClass('matrix-diagonal-widget-lower')) {
        $icon.removeClass('matrix-diagonal-widget-lower');
        $icon.addClass('matrix-diagonal-widget-upper');
        track2D.displayMode = Track2DDisplaceModes.displayUpperMatrix;
      } else if ($icon.hasClass('matrix-diagonal-widget-upper')) {
        $icon.removeClass('matrix-diagonal-widget-upper');
        $icon.addClass('matrix-diagonal-widget-all');
        track2D.displayMode = Track2DDisplaceModes.displayAllMatrix;
      } else {
        $icon.addClass('matrix-diagonal-widget-all');
        track2D.displayMode = Track2DDisplaceModes.displayAllMatrix;
      }
    }

    function annotationColorSwatch(rgbString) {
      var $swatch, $fa;
      $swatch = $('<div>', {
        class: 'igv-color-swatch'
      });
      $fa = $('<i>', {
        class: 'fa fa-square fa-lg',
        'aria-hidden': 'true'
      });
      $swatch.append($fa);
      $fa.css({
        color: rgbString
      });
      return $swatch;
    }

    function createAnnotationPanelColorpickerContainer($parent, config, closeHandler) {
      var $container, $header, $fa;
      $container = $('<div>', {
        class: 'hic-color-swatch-container'
      });
      $parent.append($container); // width

      if (config && config.width) {
        $container.width(config.width);
      } // height


      if (config && config.height) {
        $container.height(config.height);
      } // header


      $header = $('<div>');
      $container.append($header); // close button

      $fa = $("<i>", {
        class: 'fa fa-times'
      });
      $header.append($fa);
      $fa.on('click', function (e) {
        closeHandler();
      });
      return $container;
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    /**
     * Created by dat on 3/14/17.
     */
    class SweepZoom {
      constructor(browser, $target) {
        this.browser = browser;
        this.$target = $target;
        this.$rulerSweeper = $target.find("div[id$='-sweep-zoom-container']");
        this.$rulerSweeper.hide();
        this.sweepRect = {};
      }

      initialize(pageCoords) {
        this.anchor = pageCoords;
        this.coordinateFrame = this.$rulerSweeper.parent().offset();
        this.aspectRatio = this.$target.width() / this.$target.height();
        this.sweepRect.x = {
          x: pageCoords.x,
          y: pageCoords.y,
          width: 1,
          height: 1
        };
        this.clipped = {
          value: false
        };
      }

      update(pageCoords) {
        var anchor = this.anchor,
            dx = Math.abs(pageCoords.x - anchor.x),
            dy = Math.abs(pageCoords.y - anchor.y); // Adjust deltas to conform to aspect ratio

        if (dx / dy > this.aspectRatio) {
          dy = dx / this.aspectRatio;
        } else {
          dx = dy * this.aspectRatio;
        }

        this.sweepRect.width = dx;
        this.sweepRect.height = dy;
        this.sweepRect.x = anchor.x < pageCoords.x ? anchor.x : anchor.x - dx;
        this.sweepRect.y = anchor.y < pageCoords.y ? anchor.y : anchor.y - dy;
        this.$rulerSweeper.width(this.sweepRect.width);
        this.$rulerSweeper.height(this.sweepRect.height);
        this.$rulerSweeper.offset({
          left: this.sweepRect.x,
          top: this.sweepRect.y
        });
        this.$rulerSweeper.show();
      }

      commit() {
        this.$rulerSweeper.hide();
        const state = this.browser.state; // bp-per-bin

        const resolution = this.browser.resolution(); // Convert page -> offset coordinates

        const posX = this.sweepRect.x - this.$target.offset().left;
        const posY = this.sweepRect.y - this.$target.offset().top; // bp = ((bin + pixel/pixel-per-bin) / bp-per-bin)

        const x = (state.x + posX / state.pixelSize) * resolution;
        const y = (state.y + posY / state.pixelSize) * resolution; // bp = ((bin + pixel/pixel-per-bin) / bp-per-bin)

        const width = this.sweepRect.width / state.pixelSize * resolution;
        const height = this.sweepRect.height / state.pixelSize * resolution; // bp = bp + bp

        const xMax = x + width;
        const yMax = y + height;
        const minimumResolution = this.browser.dataset.bpResolutions[this.browser.dataset.bpResolutions.length - 1];
        this.browser.goto(state.chr1, x, xMax, state.chr2, y, yMax, minimumResolution);
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    class ScrollbarWidget {
      constructor(browser, $x_axis_scrollbar_container, $y_axis_scrollbar_container) {
        this.browser = browser;
        this.isDragging = false; // x-axis

        this.$x_axis_scrollbar_container = $x_axis_scrollbar_container;
        this.$x_axis_scrollbar = this.$x_axis_scrollbar_container.find("div[id$='-x-axis-scrollbar']");
        this.$x_label = this.$x_axis_scrollbar.find('div');
        this.$x_label.text(''); // y-axis

        this.$y_axis_scrollbar_container = $y_axis_scrollbar_container;
        this.$y_axis_scrollbar = this.$y_axis_scrollbar_container.find("div[id$='-y-axis-scrollbar']");
        this.$y_label = this.$y_axis_scrollbar.find('.scrollbar-label-rotation-in-place');
        this.$y_label.text('');
        this.browser.eventBus.subscribe("LocusChange", this);
      }

      css2Bin(chromosome, $element, attribute) {
        var numer, denom, percentage;
        numer = $element.css(attribute).slice(0, -2);
        denom = $element.parent().css('left' === attribute ? 'width' : 'height').slice(0, -2);
        percentage = parseInt(numer, 10) / parseInt(denom, 10);
        return percentage * chromosome.size / this.browser.dataset.bpResolutions[this.browser.state.zoom];
      }

      receiveEvent(event) {
        var self = this,
            chromosomeLengthsBin,
            chromosomeLengthsPixel,
            pixels,
            bins,
            percentage,
            percentages;

        if (!this.isDragging && event.type === "LocusChange") {
          var state = event.data.state,
              dataset = self.browser.dataset;

          if (0 === state.chr1) {
            this.$x_axis_scrollbar.hide();
            this.$y_axis_scrollbar.hide();
          } else {
            this.$x_axis_scrollbar.show();
            this.$y_axis_scrollbar.show();
            this.$x_axis_scrollbar_container.show();
            this.$y_axis_scrollbar_container.show();
            const {
              chr1,
              chr2,
              zoom,
              pixelSize,
              x,
              y
            } = state; // bp / bp-per-bin -> bin

            chromosomeLengthsBin = [chr1, chr2].map(chr => {
              return dataset.chromosomes[chr].size / dataset.bpResolutions[zoom];
            });
            chromosomeLengthsPixel = chromosomeLengthsBin.map(bin => bin * pixelSize);
            pixels = [this.browser.contactMatrixView.getViewDimensions().width, this.browser.contactMatrixView.getViewDimensions().height]; // pixel / pixel-per-bin -> bin

            bins = [pixels[0] / pixelSize, pixels[pixels.length - 1] / pixelSize]; // bin / bin -> percentage

            percentages = bins.map((bin, i) => {
              const binPercentage = Math.min(bin, chromosomeLengthsBin[i]) / chromosomeLengthsBin[i];
              const pixelPercentage = Math.min(chromosomeLengthsPixel[i], pixels[i]) / pixels[i];
              return Math.max(1, Math.round(100 * binPercentage * pixelPercentage));
            });
            this.$x_axis_scrollbar.css('width', `${percentages[0]}%`);
            this.$y_axis_scrollbar.css('height', `${percentages[percentages.length - 1]}%`); // bin / bin -> percentage

            percentage = Math.round(100 * x / chromosomeLengthsBin[0]);
            this.$x_axis_scrollbar.css('left', `${percentage}%`); // bin / bin -> percentage

            percentage = Math.round(100 * y / chromosomeLengthsBin[chromosomeLengthsBin.length - 1]);
            this.$y_axis_scrollbar.css('top', `${percentage}%`);
            this.$x_label.text(dataset.chromosomes[chr1].name);
            this.$y_label.text(dataset.chromosomes[chr2].name);
          }
        }
      }

    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    const DEFAULT_PIXEL_SIZE = 1;
    const MAX_PIXEL_SIZE = 12;
    const DEFAULT_ANNOTATION_COLOR$1 = "rgb(22, 129, 198)";

    class HICBrowser {
      constructor($app_container, config) {
        this.config = config;
        this.figureMode = config.figureMode || config.miniMode; // Mini mode for backward compatibility

        this.resolutionLocked = false;
        this.eventBus = new EventBus();
        this.showTrackLabelAndGutter = true;
        this.id = `browser_${guid()}`;
        this.trackPairs = [];
        this.tracks2D = [];
        this.normVectorFiles = [];
        this.synchable = config.synchable !== false;
        this.synchedBrowsers = [];
        this.isMobile = isMobile();
        this.$root = $('<div class="hic-root unselect">');

        if (config.width) {
          this.$root.css("width", String(config.width));
        }

        if (config.height) {
          this.$root.css("height", String(config.height + getNavbarHeight()));
        }

        $app_container.append(this.$root);
        this.layoutController = new LayoutController(this, this.$root); // nav bar related objects

        this.locusGoto = new LocusGoto(this, getNavbarContainer(this));
        this.resolutionSelector = new ResolutionSelector(this, getNavbarContainer(this));
        this.resolutionSelector.setResolutionLock(this.resolutionLocked);
        this.colorscaleWidget = new ColorScaleWidget(this, getNavbarContainer(this));
        this.controlMapWidget = new ControlMapWidget(this, getNavbarContainer(this));
        this.normalizationSelector = new NormalizationWidget(this, getNavbarContainer(this));
        this.inputDialog = new InputDialog($app_container.get(0), this); // contact map container related objects

        const sweepZoom = new SweepZoom(this, this.layoutController.getContactMatrixViewport());
        const scrollbarWidget = new ScrollbarWidget(this, this.layoutController.getXAxisScrollbarContainer(), this.layoutController.getYAxisScrollbarContainer());
        const colorScale = new ColorScale(defaultColorScaleConfig);
        const ratioColorScale = new RatioColorScale(defaultRatioColorScaleConfig.threshold);
        ratioColorScale.setColorComponents(defaultRatioColorScaleConfig.negative, '-');
        ratioColorScale.setColorComponents(defaultRatioColorScaleConfig.positive, '+');
        const backgroundColor = config.backgroundColor || ContactMatrixView.defaultBackgroundColor;
        this.contactMatrixView = new ContactMatrixView(this, this.layoutController.getContactMatrixViewport(), sweepZoom, scrollbarWidget, colorScale, ratioColorScale, backgroundColor);
        this.$menu = this.createMenu(this.$root);
        this.$menu.hide();
        this.chromosomeSelector = new ChromosomeSelectorWidget(this, this.$menu.find('.hic-chromosome-selector-widget-container'));
        const annotation2DWidgetConfig = {
          title: '2D Annotations',
          alertMessage: 'No 2D annotations currently loaded for this map'
        };
        this.annotation2DWidget = new AnnotationWidget(this, this.$menu.find(".hic-annotation-presentation-button-container"), annotation2DWidgetConfig, () => this.tracks2D); // prevent user interaction during lengthy data loads

        this.$user_interaction_shield = $('<div>', {
          class: 'hic-root-prevent-interaction'
        });
        this.$root.append(this.$user_interaction_shield);
        this.$user_interaction_shield.hide();
        this.hideCrosshairs(); //this.eventBus.subscribe("LocusChange", this);
      }

      async init(config) {
        this.state = config.state ? config.state : State.default();
        this.pending = new Map();
        this.eventBus.hold();
        this.contactMatrixView.disableUpdates = true;

        try {
          this.contactMatrixView.startSpinner();
          this.$user_interaction_shield.show(); // if (!config.name) config.name = await extractName(config)
          // const prefix = hasControl ? "A: " : "";
          // browser.$contactMaplabel.text(prefix + config.name);
          // browser.$contactMaplabel.attr('title', config.name);

          await this.loadHicFile(config, true);

          if (config.controlUrl) {
            await this.loadHicControlFile({
              url: config.controlUrl,
              name: config.controlName,
              nvi: config.controlNvi,
              isControl: true
            }, true);
          }

          if (config.cycle) {
            config.displayMode = "A";
          }

          if (config.displayMode) {
            this.contactMatrixView.displayMode = config.displayMode;
            this.eventBus.post({
              type: "DisplayMode",
              data: config.displayMode
            });
          }

          if (config.colorScale) {
            // This must be done after dataset load
            this.contactMatrixView.setColorScale(config.colorScale);
            this.eventBus.post({
              type: "ColorScale",
              data: this.contactMatrixView.getColorScale()
            });
          }

          if (config.locus) {
            await this.parseGotoInput(config.locus);
          }

          var promises = [];

          if (config.tracks) {
            promises.push(this.loadTracks(config.tracks));
          }

          if (config.normVectorFiles) {
            config.normVectorFiles.forEach(function (nv) {
              promises.push(this.loadNormalizationFile(nv));
            });
          }

          await Promise.all(promises);
          const tmp = this.contactMatrixView.colorScaleThresholdCache;
          this.eventBus.release();
          this.contactMatrixView.colorScaleThresholdCache = tmp;

          if (config.cycle) {
            this.controlMapWidget.toggleDisplayModeCycle();
          } else {
            await this.update();
          }
        } finally {
          this.contactMatrixView.stopSpinner();
          this.$user_interaction_shield.hide();
          this.contactMatrixView.disableUpdates = false;
          this.contactMatrixView.update();
        }
      }

      createMenu($root) {
        const html = `<div class="hic-menu" style="display: none;">
            <div class="hic-menu-close-button">
                <i class="fa fa-times"></i>
            </div>
	        <div class="hic-chromosome-selector-widget-container">
		        <div>Chromosomes</div>
                <div>
                    <select name="x-axis-selector"></select>
                    <select name="y-axis-selector"></select>
                    <div></div>
                </div>
	        </div>
	        <div class="hic-annotation-presentation-button-container">
		        <button type="button">2D Annotations</button>
	        </div>
        </div>`;
        $root.append($(html));
        const $menu = $root.find(".hic-menu");
        const $fa = $root.find(".fa-times");
        $fa.on('click', () => this.toggleMenu());
        return $menu;
      }

      toggleTrackLabelAndGutterState() {
        this.showTrackLabelAndGutter = !this.showTrackLabelAndGutter;
      }

      toggleMenu() {
        if (this.$menu.is(':visible')) {
          this.hideMenu();
        } else {
          this.showMenu();
        }
      }

      showMenu() {
        this.$menu.show();
      }

      hideMenu() {
        this.$menu.hide();
      }

      startSpinner() {
        this.contactMatrixView.startSpinner();
      }

      stopSpinner() {
        this.contactMatrixView.stopSpinner();
      }

      async setDisplayMode(mode) {
        await this.contactMatrixView.setDisplayMode(mode);
        this.eventBus.post(HICEvent("DisplayMode", mode));
      }

      getDisplayMode() {
        return this.contactMatrixView ? this.contactMatrixView.displayMode : undefined;
      }

      toggleDisplayMode() {
        this.controlMapWidget.toggleDisplayMode();
      }

      async getNormalizationOptions() {
        if (!this.dataset) return [];
        const baseOptions = await this.dataset.getNormalizationOptions();

        if (this.controlDataset) {
          let controlOptions = await this.controlDataset.getNormalizationOptions();
          controlOptions = new Set(controlOptions);
          return baseOptions.filter(base => controlOptions.has(base));
        } else {
          return baseOptions;
        }
      }
      /**
       * Return usable resolutions, that is the union of resolutions between dataset and controlDataset.
       * @returns {{index: *, binSize: *}[]|Array}
       */


      getResolutions() {
        if (!this.dataset) return [];
        const baseResolutions = this.dataset.bpResolutions.map(function (resolution, index) {
          return {
            index: index,
            binSize: resolution
          };
        });

        if (this.controlDataset) {
          let controlResolutions = new Set(this.controlDataset.bpResolutions);
          return baseResolutions.filter(base => controlResolutions.has(base.binSize));
        } else {
          return baseResolutions;
        }
      }

      isWholeGenome() {
        return this.dataset && this.state && this.dataset.isWholeGenome(this.state.chr1);
      }

      getColorScale() {
        if (!this.contactMatrixView) return undefined;

        switch (this.getDisplayMode()) {
          case 'AOB':
          case 'BOA':
            return this.contactMatrixView.ratioColorScale;

          case 'AMB':
            return this.contactMatrixView.diffColorScale;

          default:
            return this.contactMatrixView.colorScale;
        }
      }

      setColorScaleThreshold(threshold) {
        this.contactMatrixView.setColorScaleThreshold(threshold);
      }

      updateCrosshairs(_ref) {
        let {
          x,
          y,
          xNormalized,
          yNormalized
        } = _ref;
        const xGuide = y < 0 ? {
          left: 0
        } : {
          top: y,
          left: 0
        };
        this.contactMatrixView.$x_guide.css(xGuide);
        this.layoutController.$x_track_guide.css(xGuide);
        const yGuide = x < 0 ? {
          top: 0
        } : {
          top: 0,
          left: x
        };
        this.contactMatrixView.$y_guide.css(yGuide);
        this.layoutController.$y_track_guide.css(yGuide);

        if (this.customCrosshairsHandler) {
          const {
            x: stateX,
            y: stateY,
            pixelSize
          } = this.state;
          const resolution = this.resolution();
          const xBP = (stateX + x / pixelSize) * resolution;
          const yBP = (stateY + y / pixelSize) * resolution;
          let {
            startBP: startXBP,
            endBP: endXBP
          } = this.genomicState('x');
          let {
            startBP: startYBP,
            endBP: endYBP
          } = this.genomicState('y');
          this.customCrosshairsHandler({
            xBP,
            yBP,
            startXBP,
            startYBP,
            endXBP,
            endYBP,
            interpolantX: xNormalized,
            interpolantY: yNormalized
          });
        }
      }

      setCustomCrosshairsHandler(crosshairsHandler) {
        this.customCrosshairsHandler = crosshairsHandler;
      }

      hideCrosshairs() {
        this.contactMatrixView.$x_guide.hide();
        this.layoutController.$x_track_guide.hide();
        this.contactMatrixView.$y_guide.hide();
        this.layoutController.$y_track_guide.hide();
      }

      showCrosshairs() {
        this.contactMatrixView.$x_guide.show();
        this.layoutController.$x_track_guide.show();
        this.contactMatrixView.$y_guide.show();
        this.layoutController.$y_track_guide.show();
      }

      genomicState(axis) {
        let width = this.contactMatrixView.getViewDimensions().width;
        let resolution = this.dataset.bpResolutions[this.state.zoom];
        const bpp = this.dataset.chromosomes[this.state.chr1].name.toLowerCase() === "all" ? this.genome.getGenomeLength() / width : resolution / this.state.pixelSize;
        const gs = {
          bpp: bpp
        };

        if (axis === "x") {
          gs.chromosome = this.dataset.chromosomes[this.state.chr1];
          gs.startBP = this.state.x * resolution;
          gs.endBP = gs.startBP + bpp * width;
        } else {
          gs.chromosome = this.dataset.chromosomes[this.state.chr2];
          gs.startBP = this.state.y * resolution;
          gs.endBP = gs.startBP + bpp * this.contactMatrixView.getViewDimensions().height;
        }

        return gs;
      }
      /**
       * Load a list of 1D genome tracks (wig, etc).
       *
       * NOTE: public API function
       *
       * @param configs
       */


      async loadTracks(configs) {
        // If loading a single track remember its name, for error message
        const errorPrefix = 1 === configs.length ? "Error loading track " + configs[0].name : "Error loading tracks";

        try {
          this.contactMatrixView.startSpinner();
          const tracks = [];
          const promises2D = [];

          for (let config of
          /*trackConfigurations*/
          configs) {
            const fileName = await getFilenameExtended(config.url);

            if (!config.format) {
              config.format = inferFileFormat(fileName);
            }

            if ("annotation" === config.type && config.color === DEFAULT_ANNOTATION_COLOR$1) {
              delete config.color;
            }

            if (config.max === undefined) {
              config.autoscale = true;
            } // config.height = ("annotation" === config.type) ? annotationTrackHeight : wigTrackHeight;


            config.height = trackHeight;

            if (undefined === config.format || "bedpe" === config.format || "interact" === config.format) {
              // Assume this is a 2D track
              promises2D.push(Track2D.loadTrack2D(config, this.genome));
            } else {
              const track = await igv.createTrack(config, this);
              tracks.push(track);
            }
          }

          if (tracks.length > 0) {
            this.layoutController.tracksLoaded(tracks);
            const $gear_container = $('.hic-igv-right-hand-gutter');

            if (true === this.showTrackLabelAndGutter) {
              $gear_container.show();
            } else {
              $gear_container.hide();
            }

            await this.updateLayout();
          }

          if (promises2D.length > 0) {
            const tracks2D = await Promise.all(promises2D);

            if (tracks2D && tracks2D.length > 0) {
              this.tracks2D = this.tracks2D.concat(tracks2D);
              this.eventBus.post(HICEvent("TrackLoad2D", this.tracks2D));
            }
          }
        } catch (error) {
          presentError(errorPrefix, error);
          console.error(error);
        } finally {
          this.contactMatrixView.stopSpinner();
        }
      }

      async loadNormalizationFile(url) {
        if (!this.dataset) return;
        this.eventBus.post(HICEvent("NormalizationFileLoad", "start"));
        const normVectors = await this.dataset.hicFile.readNormalizationVectorFile(url, this.dataset.chromosomes);

        for (let type of normVectors['types']) {
          if (!this.dataset.normalizationTypes) {
            this.dataset.normalizationTypes = [];
          }

          if (!this.dataset.normalizationTypes.includes(type)) {
            this.dataset.normalizationTypes.push(type);
          }

          this.eventBus.post(HICEvent("NormVectorIndexLoad", this.dataset));
        }

        return normVectors;
      }
      /**
       * Render the XY pair of tracks.
       *
       * @param xy
       */


      async renderTrackXY(xy) {
        try {
          this.startSpinner();
          await xy.updateViews();
        } finally {
          this.stopSpinner();
        }
      }

      reset() {
        this.layoutController.removeAllTrackXYPairs();
        this.contactMatrixView.clearImageCaches();
        this.tracks2D = [];
        this.tracks = [];
        this.$contactMaplabel.text("");
        this.$contactMaplabel.attr('title', "");
        this.$controlMaplabel.text("");
        this.$controlMaplabel.attr('title', "");
        this.dataset = undefined;
        this.controlDataset = undefined;
        this.unsyncSelf();
      }

      clearSession() {
        // Clear current datasets.
        this.dataset = undefined;
        this.controlDataset = undefined;
        this.setDisplayMode('A');
        this.unsyncSelf();
      }
      /**
       * Remove reference to self from all synchedBrowsers lists.
       */


      unsyncSelf() {
        const allBrowsers = getAllBrowsers();

        for (let b of allBrowsers) {
          b.unsync(this);
        }
      }
      /**
       * Remove the reference browser from this collection of synched browsers
       * @param browser
       */


      unsync(browser) {
        this.synchedBrowsers = this.synchedBrowsers.filter(b => b != browser);
      }
      /**
       * Load a .hic file
       *
       * NOTE: public API function
       *
       * @return a promise for a dataset
       * @param config
       * @param noUpdates
       */


      async loadHicFile(config, noUpdates) {
        if (!config.url) {
          console.log("No .hic url specified");
          return undefined;
        }

        this.clearSession();

        try {
          this.contactMatrixView.startSpinner();

          if (!noUpdates) {
            this.$user_interaction_shield.show();
          }

          const name = extractName(config);
          const prefix = this.controlDataset ? "A: " : "";
          this.$contactMaplabel.text(prefix + name);
          this.$contactMaplabel.attr('title', name);
          config.name = name;
          this.dataset = await Dataset.loadDataset(config);
          this.dataset.name = name;
          const previousGenomeId = this.genome ? this.genome.id : undefined;
          this.genome = new Genome(this.dataset.genomeId, this.dataset.chromosomes); // TODO -- this is not going to work with browsers on different assemblies on the same page.
          //igv.browser.genome = this.genome;

          if (this.genome.id !== previousGenomeId) {
            EventBus.globalBus.post(HICEvent("GenomeChange", this.genome.id));
          }

          this.eventBus.post(HICEvent("MapLoad", this.dataset));

          if (config.state) {
            if (!config.state.hasOwnProperty("chr1")) {
              config.state = State.parse(config.state);
            }

            await this.setState(config.state);
          } else if (config.synchState && this.canBeSynched(config.synchState)) {
            this.syncState(config.synchState);
          } else {
            await this.setState(State.default(this.config));
          } // Initiate loading of the norm vector index, but don't block if the "nvi" parameter is not available.
          // Let it load in the background


          const eventBus = this.eventBus; // If nvi is not supplied, try reading it from remote lambda service

          if (!config.nvi && typeof config.url === "string") {
            const url = new URL(config.url);
            const key = encodeURIComponent(url.hostname + url.pathname);
            const nviResponse = await fetch('https://t5dvc6kn3f.execute-api.us-east-1.amazonaws.com/dev/nvi/' + key);

            if (nviResponse.status === 200) {
              const nvi = await nviResponse.text();

              if (nvi) {
                config.nvi = nvi;
              }
            }
          }

          if (config.nvi) {
            await this.dataset.getNormVectorIndex(config);
            eventBus.post(HICEvent("NormVectorIndexLoad", this.dataset));
          } else {
            const dataset = this.dataset;
            dataset.getNormVectorIndex(config).then(function (normVectorIndex) {
              if (!config.isControl) {
                eventBus.post(HICEvent("NormVectorIndexLoad", dataset));
              }
            });
          }

          syncBrowsers(); // Find a browser to sync with, if any

          const compatibleBrowsers = getAllBrowsers().filter(b => b != this && b.dataset && b.dataset.isCompatible(this.dataset));

          if (compatibleBrowsers.length > 0) {
            this.syncState(compatibleBrowsers[0].getSyncState());
          }
        } catch (error) {
          this.$contactMaplabel.text('');
          this.$contactMaplabel.attr('');
          config.name = name;
          throw error;
        } finally {
          this.stopSpinner();

          if (!noUpdates) {
            this.$user_interaction_shield.hide();
          }
        }
      }
      /**
       * Load a .hic file for a control map
       *
       * NOTE: public API function
       *
       * @return a promise for a dataset
       * @param config
       */


      async loadHicControlFile(config, noUpdates) {
        try {
          this.$user_interaction_shield.show();
          this.contactMatrixView.startSpinner();
          this.controlUrl = config.url;
          const name = extractName(config);
          config.name = name;
          const controlDataset = await Dataset.loadDataset(config);
          controlDataset.name = name;

          if (!this.dataset || this.dataset.isCompatible(controlDataset)) {
            this.controlDataset = controlDataset;

            if (this.dataset) {
              this.$contactMaplabel.text("A: " + this.dataset.name);
            }

            this.$controlMaplabel.text("B: " + controlDataset.name);
            this.$controlMaplabel.attr('title', controlDataset.name); //For the control dataset, block until the norm vector index is loaded

            await controlDataset.getNormVectorIndex(config);
            this.eventBus.post(HICEvent("ControlMapLoad", this.controlDataset));

            if (!noUpdates) {
              this.update();
            }
          } else {
            Alert$1.presentAlert('"B" map genome (' + controlDataset.genomeId + ') does not match "A" map genome (' + this.genome.id + ')');
          }
        } finally {
          this.$user_interaction_shield.hide();
          this.stopSpinner();
        }
      }

      async parseGotoInput(string) {
        let xLocus;
        let yLocus;
        const loci = string.split(' ');

        if (loci.length === 1) {
          xLocus = this.parseLocusString(loci[0]);
          yLocus = xLocus;
        } else {
          xLocus = this.parseLocusString(loci[0]);
          yLocus = this.parseLocusString(loci[1]);
          if (yLocus === undefined) yLocus = xLocus;
        }

        if (xLocus === undefined) {
          // Try a gene name search.
          const result = await geneSearch(this.genome.id, loci[0].trim());

          if (result) {
            Globals.selectedGene = loci[0].trim();
            xLocus = this.parseLocusString(result);
            yLocus = xLocus;
            this.state.selectedGene = Globals.selectedGene;
            this.goto(xLocus.chr, xLocus.start, xLocus.end, yLocus.chr, yLocus.start, yLocus.end, 5000);
          } else {
            alert('No feature found with name "' + loci[0] + '"');
          }
        } else {
          if (xLocus.wholeChr && yLocus.wholeChr) {
            await this.setChromosomes(xLocus.chr, yLocus.chr);
          } else {
            this.goto(xLocus.chr, xLocus.start, xLocus.end, yLocus.chr, yLocus.start, yLocus.end);
          }
        }
      }

      /**
       * Find the closest matching zoom index (index into the dataset resolutions array) for the target resolution.
       *
       * resolutionAraay can be either
       *   (1) an array of bin sizes
       *   (2) an array of objects with index and bin size
       * @param targetResolution
       * @param resolutionArray
       * @returns {number}
       */
      findMatchingZoomIndex(targetResolution, resolutionArray) {
        const isObject = resolutionArray.length > 0 && resolutionArray[0].index !== undefined;

        for (let z = resolutionArray.length - 1; z > 0; z--) {
          const binSize = isObject ? resolutionArray[z].binSize : resolutionArray[z];
          const index = isObject ? resolutionArray[z].index : z;

          if (binSize >= targetResolution) {
            return index;
          }
        }

        return 0;
      }

      parseLocusString(locus) {
        const locusObject = {};
        const parts = locus.trim().split(':');
        const chromosome = this.genome.getChromosome(parts[0].toLowerCase());

        if (!chromosome) {
          return undefined;
        } else {
          locusObject.chr = chromosome.index;
        }

        if (parts.length === 1) {
          // Chromosome name only
          locusObject.start = 0;
          locusObject.end = this.dataset.chromosomes[locusObject.chr].size;
          locusObject.wholeChr = true;
        } else {
          const extent = parts[1].split("-");
          let numeric = extent[0].replace(/\,/g, '');
          locusObject.start = isNaN(numeric) ? undefined : parseInt(numeric, 10) - 1;

          if (extent.length == 2) {
            numeric = extent[1].replace(/\,/g, '');
            locusObject.end = isNaN(numeric) ? undefined : parseInt(numeric, 10);
          }
        }

        return locusObject;
      }

      /**
       * @param scaleFactor Values range from greater then 1 to decimal values less then one
       *                    Value > 1 are magnification (zoom in)
       *                    Decimal values (.9, .75, .25, etc.) are minification (zoom out)
       * @param anchorPx -- anchor position in pixels (should not move after transformation)
       * @param anchorPy
       */
      async pinchZoom(anchorPx, anchorPy, scaleFactor) {
        if (this.state.chr1 === 0) {
          await this.zoomAndCenter(1, anchorPx, anchorPy);
        } else {
          try {
            this.startSpinner();
            const bpResolutions = this.getResolutions();
            const currentResolution = bpResolutions[this.state.zoom];
            let newBinSize;
            let newZoom;
            let newPixelSize;
            let zoomChanged;

            if (this.resolutionLocked || this.state.zoom === bpResolutions.length - 1 && scaleFactor > 1 || this.state.zoom === 0 && scaleFactor < 1) {
              // Can't change resolution level, must adjust pixel size
              newBinSize = currentResolution.binSize;
              newPixelSize = Math.min(MAX_PIXEL_SIZE, this.state.pixelSize * scaleFactor);
              newZoom = this.state.zoom;
              zoomChanged = false;
            } else {
              const targetBinSize = currentResolution.binSize / this.state.pixelSize / scaleFactor;
              newZoom = this.findMatchingZoomIndex(targetBinSize, bpResolutions);
              newBinSize = bpResolutions[newZoom].binSize;
              zoomChanged = newZoom !== this.state.zoom;
              newPixelSize = Math.min(MAX_PIXEL_SIZE, newBinSize / targetBinSize);
            }

            const z = await this.minZoom(this.state.chr1, this.state.chr2);

            if (!this.resolutionLocked && scaleFactor < 1 && newZoom < z) {
              // Zoom out to whole genome
              this.setChromosomes(0, 0);
            } else {
              const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, newZoom);
              const state = this.state;
              newPixelSize = Math.max(newPixelSize, minPS); // Genomic anchor  -- this position should remain at anchorPx, anchorPy after state change

              const gx = (state.x + anchorPx / state.pixelSize) * currentResolution.binSize;
              const gy = (state.y + anchorPy / state.pixelSize) * currentResolution.binSize;
              state.x = gx / newBinSize - anchorPx / newPixelSize;
              state.y = gy / newBinSize - anchorPy / newPixelSize;
              state.zoom = newZoom;
              state.pixelSize = newPixelSize;
              this.clamp();
              this.contactMatrixView.zoomIn(anchorPx, anchorPy, 1 / scaleFactor);
              let event = HICEvent("LocusChange", {
                state: state,
                resolutionChanged: zoomChanged,
                chrChanged: false
              });
              this.update(event); //this.eventBus.post(event);
            }
          } finally {
            this.stopSpinner();
          }
        }
      } // TODO -- apparently not used.  Where is this handled?
      // async wheelClickZoom(direction, centerPX, centerPY) {
      //     if (this.resolutionLocked || this.state.chr1 === 0) {   // Resolution locked OR whole genome view
      //         this.zoomAndCenter(direction, centerPX, centerPY);
      //     } else {
      //         const z = await minZoom.call(this, this.state.chr1, this.state.chr2)
      //         var newZoom = this.state.zoom + direction;
      //         if (direction < 0 && newZoom < z) {
      //             this.setChromosomes(0, 0);
      //         } else {
      //             this.zoomAndCenter(direction, centerPX, centerPY);
      //         }
      //
      //     }
      // }
      // Zoom in response to a double-click

      /**
       * Zoom and center on bins at given screen coordinates.  Supports double-click zoom, pinch zoom.
       * @param direction
       * @param centerPX  screen coordinate to center on
       * @param centerPY  screen coordinate to center on
       * @returns {Promise<void>}
       */


      async zoomAndCenter(direction, centerPX, centerPY) {
        if (!this.dataset) return;

        if (this.dataset.isWholeGenome(this.state.chr1) && direction > 0) {
          // jump from whole genome to chromosome
          const genomeCoordX = centerPX * this.dataset.wholeGenomeResolution / this.state.pixelSize;
          const genomeCoordY = centerPY * this.dataset.wholeGenomeResolution / this.state.pixelSize;
          const chrX = this.genome.getChromsosomeForCoordinate(genomeCoordX);
          const chrY = this.genome.getChromsosomeForCoordinate(genomeCoordY);
          this.setChromosomes(chrX.index, chrY.index);
        } else {
          const resolutions = this.getResolutions();
          const viewDimensions = this.contactMatrixView.getViewDimensions();
          const dx = centerPX === undefined ? 0 : centerPX - viewDimensions.width / 2;
          const dy = centerPY === undefined ? 0 : centerPY - viewDimensions.height / 2;
          this.state.x += dx / this.state.pixelSize;
          this.state.y += dy / this.state.pixelSize;

          if (this.resolutionLocked || direction > 0 && this.state.zoom === resolutions[resolutions.length - 1].index || direction < 0 && this.state.zoom === resolutions[0].index) {
            const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, this.state.zoom);
            const state = this.state;
            const newPixelSize = Math.max(Math.min(MAX_PIXEL_SIZE, state.pixelSize * (direction > 0 ? 2 : 0.5)), minPS);
            const shiftRatio = (newPixelSize - state.pixelSize) / newPixelSize;
            state.pixelSize = newPixelSize;
            state.x += shiftRatio * (viewDimensions.width / state.pixelSize);
            state.y += shiftRatio * (viewDimensions.height / state.pixelSize);
            this.clamp();
            let event = HICEvent("LocusChange", {
              state: state,
              resolutionChanged: false,
              chrChanged: false
            });
            this.update(event); //this.eventBus.post(event);
          } else {
            let i;

            for (i = 0; i < resolutions.length; i++) {
              if (this.state.zoom === resolutions[i].index) break;
            }

            if (i !== undefined) {
              const newZoom = resolutions[i + direction].index;
              this.setZoom(newZoom);
            }
          }
        }
      }
      /**
       * Set the current zoom state and opctionally center over supplied coordinates.
       * @param zoom - index to the datasets resolution array (dataset.bpResolutions)
       * @returns {Promise<void>}
       */


      async setZoom(zoom) {
        try {
          // Shift x,y to maintain center, if possible
          const bpResolutions = this.dataset.bpResolutions;
          const currentResolution = bpResolutions[this.state.zoom];
          const viewDimensions = this.contactMatrixView.getViewDimensions();
          const xCenter = this.state.x + viewDimensions.width / (2 * this.state.pixelSize); // center in bins

          const yCenter = this.state.y + viewDimensions.height / (2 * this.state.pixelSize); // center in bins

          const newResolution = bpResolutions[zoom];
          const newXCenter = xCenter * (currentResolution / newResolution);
          const newYCenter = yCenter * (currentResolution / newResolution);
          const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, zoom);
          const state = this.state;
          const newPixelSize = Math.max(DEFAULT_PIXEL_SIZE, minPS);
          const zoomChanged = state.zoom !== zoom;
          state.zoom = zoom;
          state.x = Math.max(0, newXCenter - viewDimensions.width / (2 * newPixelSize));
          state.y = Math.max(0, newYCenter - viewDimensions.height / (2 * newPixelSize));
          state.pixelSize = newPixelSize;
          this.clamp();
          await this.contactMatrixView.zoomIn();
          let event = HICEvent("LocusChange", {
            state: state,
            resolutionChanged: zoomChanged,
            chrChanged: false
          });
          this.update(event); //this.eventBus.post(event);
        } finally {// this.stopSpinner()
        }
      }

      async setChromosomes(chr1, chr2) {
        try {
          this.startSpinner();
          const z = await this.minZoom(chr1, chr2);
          this.state.chr1 = Math.min(chr1, chr2);
          this.state.chr2 = Math.max(chr1, chr2);
          this.state.x = 0;
          this.state.y = 0;
          this.state.zoom = z;
          const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, this.state.zoom);
          this.state.pixelSize = Math.min(100, Math.max(DEFAULT_PIXEL_SIZE, minPS));
          let event = HICEvent("LocusChange", {
            state: this.state,
            resolutionChanged: true,
            chrChanged: true
          });
          this.update(event); //this.eventBus.post(event);
        } finally {
          this.stopSpinner();
        }
      }
      /**
       * Called on loading tracks
       * @returns {Promise<void>}
       */


      async updateLayout() {
        this.clamp();
        this.trackPairs.forEach(function (xyTrackRenderPair, index) {
          sync(xyTrackRenderPair.x, index);
          sync(xyTrackRenderPair.y, index);
        });

        function sync(trackRenderer, index) {
          trackRenderer.$viewport.css({
            order: index
          });
          trackRenderer.syncCanvas();
        }

        this.layoutController.xAxisRuler.update();
        this.layoutController.yAxisRuler.update();
        await this.update();
      }
      /**
       * Set the matrix state.  Used to restore state from a bookmark
       * @param state  browser state
       */


      async setState(state) {
        const chrChanged = !this.state || this.state.chr1 !== state.chr1 || this.state.chr2 !== state.chr2;
        this.state = state; // Possibly adjust pixel size

        const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, this.state.zoom);
        this.state.pixelSize = Math.max(state.pixelSize, minPS);
        let hicEvent = new HICEvent("LocusChange", {
          state: this.state,
          resolutionChanged: true,
          chrChanged: chrChanged
        });
        this.update(hicEvent);
        this.eventBus.post(hicEvent);
      }
      /**
       * Return a modified state object used for synching.  Other datasets might have different chromosome ordering
       * and resolution arrays
       */


      getSyncState() {
        return {
          chr1Name: this.dataset.chromosomes[this.state.chr1].name,
          chr2Name: this.dataset.chromosomes[this.state.chr2].name,
          binSize: this.dataset.bpResolutions[this.state.zoom],
          binX: this.state.x,
          // TODO -- tranlsate to lower right corner
          binY: this.state.y,
          pixelSize: this.state.pixelSize
        };
      }
      /**
       * Return true if this browser can be synched to the given state
       * @param syncState
       */


      canBeSynched(syncState) {
        if (false === this.synchable) return false; // Explicitly not synchable

        return this.dataset && this.dataset.getChrIndexFromName(syncState.chr1Name) !== undefined && this.dataset.getChrIndexFromName(syncState.chr2Name) !== undefined;
      }
      /**
       * Used to synch state with other browsers
       * @param state  browser state
       */


      syncState(syncState) {
        if (!syncState || false === this.synchable) return;
        if (!this.dataset) return;
        var chr1 = this.genome.getChromosome(syncState.chr1Name),
            chr2 = this.genome.getChromosome(syncState.chr2Name),
            zoom = this.dataset.getZoomIndexForBinSize(syncState.binSize, "BP"),
            x = syncState.binX,
            y = syncState.binY,
            pixelSize = syncState.pixelSize;

        if (!(chr1 && chr2)) {
          return; // Can't be synched.
        }

        if (zoom === undefined) {
          // Get the closest zoom available and adjust pixel size.   TODO -- cache this somehow
          zoom = this.findMatchingZoomIndex(syncState.binSize, this.dataset.bpResolutions); // Compute equivalent in basepairs / pixel

          pixelSize = syncState.pixelSize / syncState.binSize * this.dataset.bpResolutions[zoom]; // Translate bins so that origin is unchanged in basepairs

          x = syncState.binX / syncState.pixelSize * pixelSize;
          y = syncState.binY / syncState.pixelSize * pixelSize;

          if (pixelSize > MAX_PIXEL_SIZE) {
            console.log("Cannot synch map " + this.dataset.name + " (resolution " + syncState.binSize + " not available)");
            return;
          }
        }

        const zoomChanged = this.state.zoom !== zoom;
        const chrChanged = this.state.chr1 !== chr1.index || this.state.chr2 !== chr2.index;
        this.state.chr1 = chr1.index;
        this.state.chr2 = chr2.index;
        this.state.zoom = zoom;
        this.state.x = x;
        this.state.y = y;
        this.state.pixelSize = pixelSize;
        let event = HICEvent("LocusChange", {
          state: this.state,
          resolutionChanged: zoomChanged,
          chrChanged: chrChanged
        }, false);
        this.update(event); //this.eventBus.post(event);
      }

      setNormalization(normalization) {
        this.state.normalization = normalization;
        this.eventBus.post(HICEvent("NormalizationChange", this.state.normalization));
      }

      shiftPixels(dx, dy) {
        if (!this.dataset) return;
        this.state.x += dx / this.state.pixelSize;
        this.state.y += dy / this.state.pixelSize;
        this.clamp();
        const locusChangeEvent = HICEvent("LocusChange", {
          state: this.state,
          resolutionChanged: false,
          dragging: true,
          chrChanged: false
        });
        locusChangeEvent.dragging = true;
        this.update(locusChangeEvent);
        this.eventBus.post(locusChangeEvent);
      }

      goto(chr1, bpX, bpXMax, chr2, bpY, bpYMax, minResolution) {
        const viewDimensions = this.contactMatrixView.getViewDimensions();
        const bpResolutions = this.getResolutions();
        const currentResolution = bpResolutions[this.state.zoom].binSize;
        const viewWidth = viewDimensions.width;

        if (!bpXMax) {
          bpX = Math.max(0, bpX - Math.floor(viewWidth * currentResolution / 2));
          bpXMax = bpX + viewWidth * currentResolution;
        }

        if (!bpYMax) {
          bpY = Math.max(0, bpY - Math.floor(viewDimensions.height * currentResolution / 2));
          bpYMax = bpY + viewDimensions.height * currentResolution;
        }

        let targetResolution = Math.max((bpXMax - bpX) / viewDimensions.width, (bpYMax - bpY) / viewDimensions.height);

        if (minResolution && targetResolution < minResolution) {
          const maxExtent = viewWidth * minResolution;
          const xCenter = (bpX + bpXMax) / 2;
          const yCenter = (bpY + bpYMax) / 2;
          bpX = Math.max(xCenter - maxExtent / 2);
          bpY = Math.max(0, yCenter - maxExtent / 2);
          targetResolution = minResolution;
        }

        let zoomChanged;
        let newZoom;

        if (true === this.resolutionLocked && minResolution === undefined) {
          zoomChanged = false;
          newZoom = this.state.zoom;
        } else {
          newZoom = this.findMatchingZoomIndex(targetResolution, bpResolutions);
          zoomChanged = newZoom !== this.state.zoom;
        }

        const newResolution = bpResolutions[newZoom].binSize;
        const newPixelSize = Math.min(MAX_PIXEL_SIZE, Math.max(1, newResolution / targetResolution));
        const newXBin = bpX / newResolution;
        const newYBin = bpY / newResolution;
        const chrChanged = !this.state || this.state.chr1 !== chr1 || this.state.chr2 !== chr2;
        this.state.chr1 = chr1;
        this.state.chr2 = chr2;
        this.state.zoom = newZoom;
        this.state.x = newXBin;
        this.state.y = newYBin;
        this.state.pixelSize = newPixelSize;
        this.contactMatrixView.clearImageCaches();
        let event = HICEvent("LocusChange", {
          state: this.state,
          resolutionChanged: zoomChanged,
          chrChanged: chrChanged
        });
        this.update(event); //this.eventBus.post(event);
      }

      clamp() {
        var viewDimensions = this.contactMatrixView.getViewDimensions(),
            chr1Length = this.dataset.chromosomes[this.state.chr1].size,
            chr2Length = this.dataset.chromosomes[this.state.chr2].size,
            binSize = this.dataset.bpResolutions[this.state.zoom],
            maxX = chr1Length / binSize - viewDimensions.width / this.state.pixelSize,
            maxY = chr2Length / binSize - viewDimensions.height / this.state.pixelSize; // Negative maxX, maxY indicates pixelSize is not enough to fill view.  In this case we clamp x, y to 0,0

        maxX = Math.max(0, maxX);
        maxY = Math.max(0, maxY);
        this.state.x = Math.min(Math.max(0, this.state.x), maxX);
        this.state.y = Math.min(Math.max(0, this.state.y), maxY);
      }

      receiveEvent(event) {// if ("LocusChange" === event.type) {
        //     if (event.propogate) {
        //         for (let browser of this.synchedBrowsers) {
        //             browser.syncState(this.getSyncState());
        //         }
        //     }
        //     this.update(event);
        // }
      }
      /**
       * Update the maps and tracks.  This method can be called from the browser event thread repeatedly, for example
       * while mouse dragging.  If called while an update is in progress queue the event for processing later.  It
       * is only neccessary to queue the most recent recently received event, so a simple instance variable will suffice
       * for the queue.
       *
       * @param event
       */


      async update(event) {
        if (this.updating) {
          const type = event ? event.type : "NONE";
          this.pending.set(type, event);
        } else {
          this.updating = true;

          try {
            this.startSpinner();

            if (event !== undefined && "LocusChange" === event.type) {
              this.layoutController.xAxisRuler.locusChange(event);
              this.layoutController.yAxisRuler.locusChange(event);
            }

            const promises = [];

            for (let xyTrackRenderPair of this.trackPairs) {
              promises.push(this.renderTrackXY(xyTrackRenderPair));
            }

            promises.push(this.contactMatrixView.update(event));
            await Promise.all(promises);

            if (event && event.propogate) {
              let syncState1 = this.getSyncState();

              for (let browser of this.synchedBrowsers) {
                browser.syncState(syncState1);
              }
            }
          } finally {
            this.updating = false;

            if (this.pending.size > 0) {
              const events = [];

              for (let [k, v] of this.pending) {
                events.push(v);
              }

              this.pending.clear();

              for (let e of events) {
                this.update(e);
              }
            }

            if (event) {
              // possibly, unless update was called from an event post (infinite loop)
              this.eventBus.post(event);
            }

            this.stopSpinner();
          }
        }
      }

      repaintMatrix() {
        this.contactMatrixView.imageTileCache = {};
        this.contactMatrixView.initialImage = undefined;
        this.contactMatrixView.update();
      }

      resolution() {
        return this.dataset.bpResolutions[this.state.zoom];
      }

      toJSON() {
        if (!(this.dataset && this.dataset.url)) return "{}"; // URL is required

        const jsonOBJ = {};
        jsonOBJ.backgroundColor = this.contactMatrixView.stringifyBackgroundColor();
        jsonOBJ.url = this.dataset.url;

        if (this.dataset.name) {
          jsonOBJ.name = this.dataset.name;
        }

        jsonOBJ.state = this.state.stringify();
        jsonOBJ.colorScale = this.contactMatrixView.getColorScale().stringify();

        if (Globals.selectedGene) {
          jsonOBJ.selectedGene = Globals.selectedGene;
        }

        let nviString = getNviString(this.dataset);

        if (nviString) {
          jsonOBJ.nvi = nviString;
        }

        if (this.controlDataset) {
          jsonOBJ.controlUrl = this.controlUrl;

          if (this.controlDataset.name) {
            jsonOBJ.controlName = this.controlDataset.name;
          }

          const displayMode = this.getDisplayMode();

          if (displayMode) {
            jsonOBJ.displayMode = this.getDisplayMode();
          }

          nviString = getNviString(this.controlDataset);

          if (nviString) {
            jsonOBJ.controlNvi = nviString;
          }

          if (this.controlMapWidget.getDisplayModeCycle() !== undefined) {
            jsonOBJ.cycle = true;
          }
        }

        if (this.trackPairs.length > 0 || this.tracks2D.length > 0) {
          let tracks = [];
          jsonOBJ.tracks = tracks;

          for (let trackRenderer of this.trackPairs) {
            const track = trackRenderer.x.track;
            const config = track.config;

            if (typeof config.url === "string") {
              const t = {
                url: config.url
              };

              if (track.name) {
                t.name = track.name;
              }

              if (track.dataRange) {
                t.min = track.dataRange.min;
                t.max = track.dataRange.max;
              }

              if (track.color) {
                t.color = track.color;
              }

              tracks.push(t);
            }
          }

          for (let track of this.tracks2D) {
            var config = track.config;

            if (typeof config.url === "string") {
              const t = {
                url: config.url
              };

              if (track.name) {
                t.name = track.name;
              }

              if (track.color) {
                t.color = track.color;
              }

              tracks.push(t);
            }
          }
        }

        return jsonOBJ;
      }

      async minZoom(chr1, chr2) {
        const viewDimensions = this.contactMatrixView.getViewDimensions();
        const chromosome1 = this.dataset.chromosomes[chr1];
        const chromosome2 = this.dataset.chromosomes[chr2];
        const chr1Length = chromosome1.size;
        const chr2Length = chromosome2.size;
        const binSize = Math.max(chr1Length / viewDimensions.width, chr2Length / viewDimensions.height);
        const matrix = await this.dataset.getMatrix(chr1, chr2);

        if (!matrix) {
          throw new Error(`Data not avaiable for chromosomes ${chromosome1.name} - ${chromosome2.name}`);
        }

        return matrix.findZoomForResolution(binSize);
      }

      async minPixelSize(chr1, chr2, z) {
        const viewDimensions = this.contactMatrixView.getViewDimensions();
        const chr1Length = this.dataset.chromosomes[chr1].size;
        const chr2Length = this.dataset.chromosomes[chr2].size;
        const matrix = await this.dataset.getMatrix(chr1, chr2);
        const zd = matrix.getZoomDataByIndex(z, "BP");
        const binSize = zd.zoom.binSize;
        const nBins1 = chr1Length / binSize;
        const nBins2 = chr2Length / binSize;
        return Math.min(viewDimensions.width / nBins1, viewDimensions.height / nBins2);
      }

    }

    function extractName(config) {
      if (config.name === undefined) {
        const urlOrFile = config.url;

        if (isFilePath(urlOrFile)) {
          return urlOrFile.name;
        } else {
          const str = urlOrFile.split('?').shift();
          const idx = urlOrFile.lastIndexOf("/");
          return idx > 0 ? str.substring(idx + 1) : str;
        }
      } else {
        return config.name;
      }
    }

    function getNviString(dataset) {
      return dataset.hicFile.config.nvi; // if (dataset.hicFile.normalizationVectorIndexRange) {
      //     var range = dataset.hicFile.normalizationVectorIndexRange,
      //         nviString = String(range.start) + "," + String(range.size);
      //     return nviString
      // } else {
      //     return undefined;
      // }
    } // parseUri 1.2.2

    function presentError(prefix, error) {
      const httpMessages = {
        "401": "Access unauthorized",
        "403": "Access forbidden",
        "404": "Not found"
      };
      var msg = error.message;

      if (httpMessages.hasOwnProperty(msg)) {
        msg = httpMessages[msg];
      }

      Alert$1.presentAlert(prefix + ": " + msg);
    }

    /*
     * @author Jim Robinson Dec-2020
     */
    const defaultSize = {
      width: 640,
      height: 640
    };
    let allBrowsers = [];
    let currentBrowser;

    async function createBrowser(hic_container, config, callback) {
      const $hic_container = $(hic_container);
      setDefaults(config);

      if (isString$2(config.state)) {
        config.state = State.parse(config.state);
      }

      if (isString$2(config.colorScale)) {
        config.colorScale = ColorScale.parse(config.colorScale);
      }

      if (isString$2(config.backgroundColor)) {
        config.backgroundColor = ContactMatrixView.parseBackgroundColor(config.backgroundColor);
      }

      const browser = new HICBrowser($hic_container, config);
      await browser.init(config);

      if (typeof callback === "function") {
        callback();
      }

      allBrowsers.push(browser);
      setCurrentBrowser(browser);

      if (allBrowsers.length > 1) {
        allBrowsers.forEach(function (b) {
          b.$browser_panel_delete_button.show();
        });
      }

      return browser;
    }
    /**
     * Create multiple browsers, maintaining order specified in configList.  Called from restore session
     *
     * @param hic_container
     * @param configList
     */


    async function createBrowserList(hic_container, session) {
      const $hic_container = $(hic_container);
      const configList = session.browsers || [session];
      allBrowsers = [];
      const initPromises = [];

      for (let config of configList) {
        setDefaults(config);

        if (isString$2(config.state)) {
          config.state = State.parse(config.state);
        }

        if (isString$2(config.colorScale)) {
          config.colorScale = ColorScale.parse(config.colorScale);
        }

        if (isString$2(config.backgroundColor)) {
          config.backgroundColor = ContactMatrixView.parseBackgroundColor(config.backgroundColor);
        }

        if (false === session.syncDatasets) {
          config.synchable = false;
        }

        const browser = new HICBrowser($hic_container, config);
        allBrowsers.push(browser);
        initPromises.push(browser.init(config));
      }

      await Promise.all(initPromises);
      setCurrentBrowser(allBrowsers[0]);

      if (allBrowsers.length > 1) {
        allBrowsers.forEach(function (b) {
          b.$browser_panel_delete_button.show();
        });
      }
    }

    function deleteAllBrowsers() {
      for (let b of allBrowsers) {
        b.$root.remove();
      }

      allBrowsers = [];
    }

    function setCurrentBrowser(browser) {
      // unselect current browser
      if (undefined === browser) {
        if (currentBrowser) {
          currentBrowser.$root.removeClass('hic-root-selected');
        }

        currentBrowser = browser;
        return;
      }

      if (browser !== currentBrowser) {
        if (currentBrowser) {
          currentBrowser.$root.removeClass('hic-root-selected');
        }

        browser.$root.addClass('hic-root-selected');
        currentBrowser = browser;
        EventBus.globalBus.post(HICEvent("BrowserSelect", browser));
      }
    }

    function deleteBrowser(browser) {
      browser.unsyncSelf();
      browser.$root.remove();
      allBrowsers = allBrowsers.filter(b => b != browser);

      if (allBrowsers.length <= 1) {
        allBrowsers.forEach(function (b) {
          b.$browser_panel_delete_button.hide();
        });
      }
    }

    function getCurrentBrowser() {
      return currentBrowser;
    }

    function syncBrowsers(browsers) {
      const synchableBrowsers = (browsers || allBrowsers).filter(b => false !== b.synchable && b.dataset !== undefined); // Sync compatible maps only

      for (let b1 of synchableBrowsers) {
        for (let b2 of synchableBrowsers) {
          if (b1 === b2) continue;

          if (b1.dataset.isCompatible(b2.dataset)) {
            b1.synchedBrowsers.push(b2);
            b2.synchedBrowsers.push(b1);
          }
        }
      }
    }

    function getAllBrowsers() {
      return allBrowsers;
    } // Set default values for config properties


    function setDefaults(config) {
      if (config.state) {
        if (isString$2(config.state)) {
          config.state = State.parse(config.state);
        } else {
          // copy
          config.state = new State(config.state.chr1, config.state.chr2, config.state.zoom, config.state.x, config.state.y, config.width, config.height, config.state.pixelSize, config.state.normalization);
        }
      }

      if (config.figureMode === true) {
        config.showLocusGoto = false;
        config.showHicContactMapLabel = false;
        config.showChromosomeSelector = false;
      } else {
        if (undefined === config.width) {
          config.width = config.state ? config.state.width : defaultSize.width;
        }

        if (undefined === config.height) {
          config.height = config.state ? config.state.height : defaultSize.height;
        }

        if (undefined === config.showLocusGoto) {
          config.showLocusGoto = true;
        }

        if (undefined === config.showHicContactMapLabel) {
          config.showHicContactMapLabel = true;
        }

        if (undefined === config.showChromosomeSelector) {
          config.showChromosomeSelector = true;
        }
      }
    } // mock igv browser objects for igv.js compatibility

    const version = "2.2.0";
     //, commit}

    function toJSON() {
      const jsonOBJ = {};
      const browserJson = [];
      const allBrowsers = getAllBrowsers();

      for (let browser of allBrowsers) {
        browserJson.push(browser.toJSON());
      }

      jsonOBJ.browsers = browserJson;

      if (Globals.selectedGene) {
        jsonOBJ["selectedGene"] = Globals.selectedGene;
      }

      const captionDiv = document.getElementById('hic-caption');

      if (captionDiv) {
        var captionText = captionDiv.textContent;

        if (captionText) {
          captionText = captionText.trim();

          if (captionText) {
            jsonOBJ.caption = captionText;
          }
        }
      }

      return jsonOBJ;
    }

    function compressedSession() {
      const jsonString = JSON.stringify(toJSON());
      return `session=blob:${compressString(jsonString)}`;
    }

    async function restoreSession(container, session) {
      deleteAllBrowsers();

      if (session.hasOwnProperty("selectedGene")) {
        Globals.selectedGene = session.selectedGene;
      }

      if (session.hasOwnProperty("caption")) {
        const captionText = session.caption;
        var captionDiv = document.getElementById("hic-caption");

        if (captionDiv) {
          captionDiv.textContent = captionText;
        }
      }

      await createBrowserList(container, session);

      if (false !== session.syncDatasets) {
        syncBrowsers();
      }
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    const DEFAULT_ANNOTATION_COLOR = "rgb(22, 129, 198)";
    const urlShortcuts = {
      "*s3e/": "https://hicfiles.s3.amazonaws.com/external/",
      "*s3/": "https://hicfiles.s3.amazonaws.com/",
      "*s3e_/": "http://hicfiles.s3.amazonaws.com/external/",
      "*s3_/": "http://hicfiles.s3.amazonaws.com/",
      "*enc/": "https://www.encodeproject.org/files/"
    };

    async function extractConfig(queryString) {
      let query = extractQuery(queryString);
      let sessionConfig;

      if (query.hasOwnProperty("session")) {
        if (query.session.startsWith("blob:") || query.session.startsWith("data:")) {
          sessionConfig = JSON.parse(uncompressString(query.session.substr(5)));
        }
      }

      if (query.hasOwnProperty("juiceboxURL")) {
        const jbURL = await expandURL(query["juiceboxURL"]); // Legacy bitly urls

        query = extractQuery(jbURL);
      }

      if (query.hasOwnProperty("juicebox") || query.hasOwnProperty("juiceboxData")) {
        let q;

        if (query.hasOwnProperty("juiceboxData")) {
          q = uncompressString(query["juiceboxData"]);
        } else {
          q = query["juicebox"];

          if (q.startsWith("%7B")) {
            q = decodeURIComponent(q);
          }
        }

        q = q.substr(1, q.length - 2); // Strip leading and trailing bracket

        const parts = q.split("},{");
        const browsers = [];

        for (let p of parts) {
          const qObj = extractQuery(decodeURIComponent(p));
          browsers.push(decodeQuery(qObj));
        }

        sessionConfig = {
          browsers
        };
      } // Try query parameter style


      const uriDecode = true;
      const queryConfig = decodeQuery(query, uriDecode);

      if (queryConfig.url) {
        sessionConfig = queryConfig;
      } // Fix certain defaults


      if (sessionConfig) {
        if (sessionConfig.browsers) {
          for (let b of sessionConfig.browsers) {
            fixDefaults(b);
          }
        } else {
          fixDefaults(sessionConfig);
        }
      }

      return sessionConfig;
    }

    function fixDefaults(browserConfig) {
      if (browserConfig.tracks) {
        for (let t of browserConfig.tracks) {
          if (t.color === DEFAULT_ANNOTATION_COLOR) {
            delete t.color;
          }

          if (t.min !== undefined && Number.isNaN(t.min)) {
            delete t.min;
          }

          if (t.max !== undefined && Number.isNaN(t.max)) {
            delete t.max;
          }

          t.displayMode = "COLLAPSED";
        }
      }
    }
    /**
     * Extend config properties with query parameters
     *
     * @param query
     * @param config
     */


    function decodeQuery(query, uriDecode) {
      const config = {};
      let hicUrl = query["hicUrl"];
      const name = query["name"];
      let stateString = query["state"];
      let colorScale = query["colorScale"];
      let trackString = query["tracks"];
      const selectedGene = query["selectedGene"];
      const nvi = query["nvi"];
      let controlUrl = query["controlUrl"];
      const controlName = query["controlName"];
      const displayMode = query["displayMode"];
      const controlNvi = query["controlNvi"];
      const cycle = query["cycle"];

      if (hicUrl) {
        hicUrl = paramDecode(hicUrl, uriDecode);
        Object.keys(urlShortcuts).forEach(function (key) {
          var value = urlShortcuts[key];
          if (hicUrl.startsWith(key)) hicUrl = hicUrl.replace(key, value);
        });
        config.url = hicUrl;
      }

      if (name) {
        config.name = paramDecode(name, uriDecode);
      }

      if (controlUrl) {
        controlUrl = paramDecode(controlUrl, uriDecode);
        Object.keys(urlShortcuts).forEach(function (key) {
          var value = urlShortcuts[key];
          if (controlUrl.startsWith(key)) controlUrl = controlUrl.replace(key, value);
        });
        config.controlUrl = controlUrl;
      }

      if (controlName) {
        config.controlName = paramDecode(controlName, uriDecode);
      }

      if (stateString) {
        stateString = paramDecode(stateString, uriDecode);
        config.state = State.parse(stateString);
      }

      if (colorScale) {
        colorScale = paramDecode(colorScale, uriDecode);
        config.colorScale = ColorScale.parse(colorScale);
      }

      if (displayMode) {
        config.displayMode = paramDecode(displayMode, uriDecode);
      }

      if (trackString) {
        trackString = paramDecode(trackString, uriDecode);
        config.tracks = destringifyTracksV0(trackString); // If an oAuth token is provided append it to track configs.

        if (config.tracks && config.oauthToken) {
          config.tracks.forEach(function (t) {
            t.oauthToken = config.oauthToken;
          });
        }
      }

      if (selectedGene) {
        Globals.selectedGene = selectedGene;
      }

      config.cycle = cycle;

      if (nvi) {
        config.nvi = paramDecode(nvi, uriDecode);
      }

      if (controlNvi) {
        config.controlNvi = paramDecode(controlNvi, uriDecode);
      }

      return config;

      function destringifyTracksV0(tracks) {
        const trackStringList = tracks.split("|||");
        const configList = [];

        for (let trackString of trackStringList) {
          const tokens = trackString.split("|");
          const color = tokens.pop();
          let url = tokens.length > 1 ? tokens[0] : trackString;

          if (url && url.trim().length > 0 && "undefined" !== url) {
            const keys = Object.keys(urlShortcuts);

            for (let key of keys) {
              var value = urlShortcuts[key];

              if (url.startsWith(key)) {
                url = url.replace(key, value);
                break;
              }
            }

            const trackConfig = {
              url: url
            };

            if (tokens.length > 1) {
              trackConfig.name = replaceAll(tokens[1], "$", "|");
            }

            if (tokens.length > 2) {
              const dataRangeString = tokens[2];

              if (dataRangeString.startsWith("-")) {
                const r = dataRangeString.substring(1).split("-");
                trackConfig.min = -parseFloat(r[0]);
                trackConfig.max = parseFloat(r[1]);
              } else {
                const r = dataRangeString.split("-");
                trackConfig.min = parseFloat(r[0]);
                trackConfig.max = parseFloat(r[1]);
              }
            }

            if (color) {
              trackConfig.color = color;
            }

            configList.push(trackConfig);
          }
        }

        return configList;
      }
    }

    function paramDecode(str, uriDecode) {
      if (uriDecode) {
        return decodeURIComponent(str); // Still more backward compatibility
      } else {
        var s = replaceAll(str, '%26', '&');
        s = replaceAll(s, '%20', ' ');
        s = replaceAll(s, '+', ' ');
        s = replaceAll(s, "%7C", "|");
        s = replaceAll(s, "%23", "#");
        s = replaceAll(s, "%3F", "?");
        s = replaceAll(s, "%3D", "=");
        return s;
      }
    }

    function replaceAll(str, target, replacement) {
      return str.split(target).join(replacement);
    }

    function extractQuery(uri) {
      var i1, i2, i, j, s, query, tokens;
      query = {};
      i1 = uri.indexOf("?");
      i2 = uri.lastIndexOf("#");
      const i3 = uri.indexOf("=");
      if (i1 > i3) i1 = -1;
      if (i2 < 0) i2 = uri.length;

      for (i = i1 + 1; i < i2;) {
        j = uri.indexOf("&", i);
        if (j < 0) j = i2;
        s = uri.substring(i, j);
        tokens = s.split("=", 2);

        if (tokens.length === 2) {
          query[tokens[0]] = tokens[1];
        }

        i = j + 1;
      }

      return query;
    }
    /**
     * Expand legacy bitly URLs
     * @param url
     * @returns {Promise<*>}
     */


    async function expandURL(url) {
      const endpoint = `https://api-ssl.bitly.com/v4/expand`;
      const id = url.startsWith("http://") ? url.substring(7) : url.substring(8);
      const message = {
        "bitlink_id": id
      };
      const response = await fetch(endpoint, {
        method: 'POST',
        // or 'PUT'
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${btoa("ëtá¾´ãÎtsßéÆºÙçµóf¸í¿9snéÝz")}`
        },
        body: JSON.stringify(message)
      });

      if (!response.ok) {
        throw new Error(`Network error (${response.status}): ${response.statusText}`);
      }

      const json = await response.json();
      let longUrl = json.long_url; // Fix some Bitly "normalization"

      longUrl = longUrl.replace("{", "%7B").replace("}", "%7D");
      return longUrl;
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */

    async function init(container, config) {
      Alert$1.init(container);

      if (false !== config.queryParametersSupported) {
        const queryConfig = await extractConfig(window.location.href);

        if (queryConfig) {
          config = queryConfig;
        }
      }

      await restoreSession(container, config); // Return the currently selected browser for backward compatibility with "createBrowser"

      return getCurrentBrowser();
    }

    /*
     *  The MIT License (MIT)
     *
     * Copyright (c) 2016-2017 The Regents of the University of California
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
     * associated documentation files (the "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
     * following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial
     * portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
     * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
     * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *
     */
    var index = {
      version,
      init,
      toJSON,
      restoreSession,
      compressedSession,
      createBrowser,
      getCurrentBrowser,
      setCurrentBrowser,
      getAllBrowsers,
      igvxhr,
      EventBus
    };

    return index;

}));
